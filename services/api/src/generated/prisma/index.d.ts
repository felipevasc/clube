
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model UserCity
 * 
 */
export type UserCity = $Result.DefaultSelection<Prisma.$UserCityPayload>
/**
 * Model Book
 * 
 */
export type Book = $Result.DefaultSelection<Prisma.$BookPayload>
/**
 * Model BookStyleImage
 * 
 */
export type BookStyleImage = $Result.DefaultSelection<Prisma.$BookStyleImagePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model Membership
 * 
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>
/**
 * Model JoinRequest
 * 
 */
export type JoinRequest = $Result.DefaultSelection<Prisma.$JoinRequestPayload>
/**
 * Model GroupInvite
 * 
 */
export type GroupInvite = $Result.DefaultSelection<Prisma.$GroupInvitePayload>
/**
 * Model GroupBookOfMonthSelection
 * 
 */
export type GroupBookOfMonthSelection = $Result.DefaultSelection<Prisma.$GroupBookOfMonthSelectionPayload>
/**
 * Model ClubBook
 * 
 */
export type ClubBook = $Result.DefaultSelection<Prisma.$ClubBookPayload>
/**
 * Model ClubBookMessage
 * 
 */
export type ClubBookMessage = $Result.DefaultSelection<Prisma.$ClubBookMessagePayload>
/**
 * Model ClubBookArtifact
 * 
 */
export type ClubBookArtifact = $Result.DefaultSelection<Prisma.$ClubBookArtifactPayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model ChannelMessage
 * 
 */
export type ChannelMessage = $Result.DefaultSelection<Prisma.$ChannelMessagePayload>
/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = $Result.DefaultSelection<Prisma.$DirectMessagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PostImage
 * 
 */
export type PostImage = $Result.DefaultSelection<Prisma.$PostImagePayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Poll
 * 
 */
export type Poll = $Result.DefaultSelection<Prisma.$PollPayload>
/**
 * Model PollOption
 * 
 */
export type PollOption = $Result.DefaultSelection<Prisma.$PollOptionPayload>
/**
 * Model PollVote
 * 
 */
export type PollVote = $Result.DefaultSelection<Prisma.$PollVotePayload>
/**
 * Model ClubEvent
 * 
 */
export type ClubEvent = $Result.DefaultSelection<Prisma.$ClubEventPayload>
/**
 * Model ClubEventParticipant
 * 
 */
export type ClubEventParticipant = $Result.DefaultSelection<Prisma.$ClubEventParticipantPayload>
/**
 * Model ClubEventPhoto
 * 
 */
export type ClubEventPhoto = $Result.DefaultSelection<Prisma.$ClubEventPhotoPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCity`: Exposes CRUD operations for the **UserCity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCities
    * const userCities = await prisma.userCity.findMany()
    * ```
    */
  get userCity(): Prisma.UserCityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookStyleImage`: Exposes CRUD operations for the **BookStyleImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookStyleImages
    * const bookStyleImages = await prisma.bookStyleImage.findMany()
    * ```
    */
  get bookStyleImage(): Prisma.BookStyleImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.MembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.joinRequest`: Exposes CRUD operations for the **JoinRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JoinRequests
    * const joinRequests = await prisma.joinRequest.findMany()
    * ```
    */
  get joinRequest(): Prisma.JoinRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupInvite`: Exposes CRUD operations for the **GroupInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupInvites
    * const groupInvites = await prisma.groupInvite.findMany()
    * ```
    */
  get groupInvite(): Prisma.GroupInviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupBookOfMonthSelection`: Exposes CRUD operations for the **GroupBookOfMonthSelection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupBookOfMonthSelections
    * const groupBookOfMonthSelections = await prisma.groupBookOfMonthSelection.findMany()
    * ```
    */
  get groupBookOfMonthSelection(): Prisma.GroupBookOfMonthSelectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubBook`: Exposes CRUD operations for the **ClubBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubBooks
    * const clubBooks = await prisma.clubBook.findMany()
    * ```
    */
  get clubBook(): Prisma.ClubBookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubBookMessage`: Exposes CRUD operations for the **ClubBookMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubBookMessages
    * const clubBookMessages = await prisma.clubBookMessage.findMany()
    * ```
    */
  get clubBookMessage(): Prisma.ClubBookMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubBookArtifact`: Exposes CRUD operations for the **ClubBookArtifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubBookArtifacts
    * const clubBookArtifacts = await prisma.clubBookArtifact.findMany()
    * ```
    */
  get clubBookArtifact(): Prisma.ClubBookArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channelMessage`: Exposes CRUD operations for the **ChannelMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelMessages
    * const channelMessages = await prisma.channelMessage.findMany()
    * ```
    */
  get channelMessage(): Prisma.ChannelMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postImage`: Exposes CRUD operations for the **PostImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostImages
    * const postImages = await prisma.postImage.findMany()
    * ```
    */
  get postImage(): Prisma.PostImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poll`: Exposes CRUD operations for the **Poll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Polls
    * const polls = await prisma.poll.findMany()
    * ```
    */
  get poll(): Prisma.PollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pollOption`: Exposes CRUD operations for the **PollOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PollOptions
    * const pollOptions = await prisma.pollOption.findMany()
    * ```
    */
  get pollOption(): Prisma.PollOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pollVote`: Exposes CRUD operations for the **PollVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PollVotes
    * const pollVotes = await prisma.pollVote.findMany()
    * ```
    */
  get pollVote(): Prisma.PollVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubEvent`: Exposes CRUD operations for the **ClubEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubEvents
    * const clubEvents = await prisma.clubEvent.findMany()
    * ```
    */
  get clubEvent(): Prisma.ClubEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubEventParticipant`: Exposes CRUD operations for the **ClubEventParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubEventParticipants
    * const clubEventParticipants = await prisma.clubEventParticipant.findMany()
    * ```
    */
  get clubEventParticipant(): Prisma.ClubEventParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubEventPhoto`: Exposes CRUD operations for the **ClubEventPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubEventPhotos
    * const clubEventPhotos = await prisma.clubEventPhoto.findMany()
    * ```
    */
  get clubEventPhoto(): Prisma.ClubEventPhotoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Invitation: 'Invitation',
    UserCity: 'UserCity',
    Book: 'Book',
    BookStyleImage: 'BookStyleImage',
    Category: 'Category',
    Group: 'Group',
    Membership: 'Membership',
    JoinRequest: 'JoinRequest',
    GroupInvite: 'GroupInvite',
    GroupBookOfMonthSelection: 'GroupBookOfMonthSelection',
    ClubBook: 'ClubBook',
    ClubBookMessage: 'ClubBookMessage',
    ClubBookArtifact: 'ClubBookArtifact',
    Channel: 'Channel',
    ChannelMessage: 'ChannelMessage',
    DirectMessage: 'DirectMessage',
    Post: 'Post',
    PostImage: 'PostImage',
    Like: 'Like',
    Comment: 'Comment',
    Poll: 'Poll',
    PollOption: 'PollOption',
    PollVote: 'PollVote',
    ClubEvent: 'ClubEvent',
    ClubEventParticipant: 'ClubEventParticipant',
    ClubEventPhoto: 'ClubEventPhoto'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "invitation" | "userCity" | "book" | "bookStyleImage" | "category" | "group" | "membership" | "joinRequest" | "groupInvite" | "groupBookOfMonthSelection" | "clubBook" | "clubBookMessage" | "clubBookArtifact" | "channel" | "channelMessage" | "directMessage" | "post" | "postImage" | "like" | "comment" | "poll" | "pollOption" | "pollVote" | "clubEvent" | "clubEventParticipant" | "clubEventPhoto"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      UserCity: {
        payload: Prisma.$UserCityPayload<ExtArgs>
        fields: Prisma.UserCityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>
          }
          findFirst: {
            args: Prisma.UserCityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>
          }
          findMany: {
            args: Prisma.UserCityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>[]
          }
          create: {
            args: Prisma.UserCityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>
          }
          createMany: {
            args: Prisma.UserCityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>[]
          }
          delete: {
            args: Prisma.UserCityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>
          }
          update: {
            args: Prisma.UserCityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>
          }
          deleteMany: {
            args: Prisma.UserCityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>[]
          }
          upsert: {
            args: Prisma.UserCityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCityPayload>
          }
          aggregate: {
            args: Prisma.UserCityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCity>
          }
          groupBy: {
            args: Prisma.UserCityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCityCountArgs<ExtArgs>
            result: $Utils.Optional<UserCityCountAggregateOutputType> | number
          }
        }
      }
      Book: {
        payload: Prisma.$BookPayload<ExtArgs>
        fields: Prisma.BookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findFirst: {
            args: Prisma.BookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findMany: {
            args: Prisma.BookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          create: {
            args: Prisma.BookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          createMany: {
            args: Prisma.BookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          delete: {
            args: Prisma.BookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          update: {
            args: Prisma.BookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          deleteMany: {
            args: Prisma.BookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          upsert: {
            args: Prisma.BookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          aggregate: {
            args: Prisma.BookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook>
          }
          groupBy: {
            args: Prisma.BookGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCountArgs<ExtArgs>
            result: $Utils.Optional<BookCountAggregateOutputType> | number
          }
        }
      }
      BookStyleImage: {
        payload: Prisma.$BookStyleImagePayload<ExtArgs>
        fields: Prisma.BookStyleImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookStyleImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookStyleImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>
          }
          findFirst: {
            args: Prisma.BookStyleImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookStyleImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>
          }
          findMany: {
            args: Prisma.BookStyleImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>[]
          }
          create: {
            args: Prisma.BookStyleImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>
          }
          createMany: {
            args: Prisma.BookStyleImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookStyleImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>[]
          }
          delete: {
            args: Prisma.BookStyleImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>
          }
          update: {
            args: Prisma.BookStyleImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>
          }
          deleteMany: {
            args: Prisma.BookStyleImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookStyleImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookStyleImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>[]
          }
          upsert: {
            args: Prisma.BookStyleImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookStyleImagePayload>
          }
          aggregate: {
            args: Prisma.BookStyleImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookStyleImage>
          }
          groupBy: {
            args: Prisma.BookStyleImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookStyleImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookStyleImageCountArgs<ExtArgs>
            result: $Utils.Optional<BookStyleImageCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>
        fields: Prisma.MembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembership>
          }
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipCountAggregateOutputType> | number
          }
        }
      }
      JoinRequest: {
        payload: Prisma.$JoinRequestPayload<ExtArgs>
        fields: Prisma.JoinRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JoinRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JoinRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          findFirst: {
            args: Prisma.JoinRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JoinRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          findMany: {
            args: Prisma.JoinRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>[]
          }
          create: {
            args: Prisma.JoinRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          createMany: {
            args: Prisma.JoinRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JoinRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>[]
          }
          delete: {
            args: Prisma.JoinRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          update: {
            args: Prisma.JoinRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          deleteMany: {
            args: Prisma.JoinRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JoinRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JoinRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>[]
          }
          upsert: {
            args: Prisma.JoinRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          aggregate: {
            args: Prisma.JoinRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJoinRequest>
          }
          groupBy: {
            args: Prisma.JoinRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<JoinRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.JoinRequestCountArgs<ExtArgs>
            result: $Utils.Optional<JoinRequestCountAggregateOutputType> | number
          }
        }
      }
      GroupInvite: {
        payload: Prisma.$GroupInvitePayload<ExtArgs>
        fields: Prisma.GroupInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>
          }
          findFirst: {
            args: Prisma.GroupInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>
          }
          findMany: {
            args: Prisma.GroupInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>[]
          }
          create: {
            args: Prisma.GroupInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>
          }
          createMany: {
            args: Prisma.GroupInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>[]
          }
          delete: {
            args: Prisma.GroupInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>
          }
          update: {
            args: Prisma.GroupInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>
          }
          deleteMany: {
            args: Prisma.GroupInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupInviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>[]
          }
          upsert: {
            args: Prisma.GroupInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupInvitePayload>
          }
          aggregate: {
            args: Prisma.GroupInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupInvite>
          }
          groupBy: {
            args: Prisma.GroupInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupInviteCountArgs<ExtArgs>
            result: $Utils.Optional<GroupInviteCountAggregateOutputType> | number
          }
        }
      }
      GroupBookOfMonthSelection: {
        payload: Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>
        fields: Prisma.GroupBookOfMonthSelectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupBookOfMonthSelectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupBookOfMonthSelectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>
          }
          findFirst: {
            args: Prisma.GroupBookOfMonthSelectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupBookOfMonthSelectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>
          }
          findMany: {
            args: Prisma.GroupBookOfMonthSelectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>[]
          }
          create: {
            args: Prisma.GroupBookOfMonthSelectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>
          }
          createMany: {
            args: Prisma.GroupBookOfMonthSelectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupBookOfMonthSelectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>[]
          }
          delete: {
            args: Prisma.GroupBookOfMonthSelectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>
          }
          update: {
            args: Prisma.GroupBookOfMonthSelectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>
          }
          deleteMany: {
            args: Prisma.GroupBookOfMonthSelectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupBookOfMonthSelectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupBookOfMonthSelectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>[]
          }
          upsert: {
            args: Prisma.GroupBookOfMonthSelectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookOfMonthSelectionPayload>
          }
          aggregate: {
            args: Prisma.GroupBookOfMonthSelectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupBookOfMonthSelection>
          }
          groupBy: {
            args: Prisma.GroupBookOfMonthSelectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupBookOfMonthSelectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupBookOfMonthSelectionCountArgs<ExtArgs>
            result: $Utils.Optional<GroupBookOfMonthSelectionCountAggregateOutputType> | number
          }
        }
      }
      ClubBook: {
        payload: Prisma.$ClubBookPayload<ExtArgs>
        fields: Prisma.ClubBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>
          }
          findFirst: {
            args: Prisma.ClubBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>
          }
          findMany: {
            args: Prisma.ClubBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>[]
          }
          create: {
            args: Prisma.ClubBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>
          }
          createMany: {
            args: Prisma.ClubBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubBookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>[]
          }
          delete: {
            args: Prisma.ClubBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>
          }
          update: {
            args: Prisma.ClubBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>
          }
          deleteMany: {
            args: Prisma.ClubBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubBookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>[]
          }
          upsert: {
            args: Prisma.ClubBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookPayload>
          }
          aggregate: {
            args: Prisma.ClubBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubBook>
          }
          groupBy: {
            args: Prisma.ClubBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubBookCountArgs<ExtArgs>
            result: $Utils.Optional<ClubBookCountAggregateOutputType> | number
          }
        }
      }
      ClubBookMessage: {
        payload: Prisma.$ClubBookMessagePayload<ExtArgs>
        fields: Prisma.ClubBookMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubBookMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubBookMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>
          }
          findFirst: {
            args: Prisma.ClubBookMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubBookMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>
          }
          findMany: {
            args: Prisma.ClubBookMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>[]
          }
          create: {
            args: Prisma.ClubBookMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>
          }
          createMany: {
            args: Prisma.ClubBookMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubBookMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>[]
          }
          delete: {
            args: Prisma.ClubBookMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>
          }
          update: {
            args: Prisma.ClubBookMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>
          }
          deleteMany: {
            args: Prisma.ClubBookMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubBookMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubBookMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>[]
          }
          upsert: {
            args: Prisma.ClubBookMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookMessagePayload>
          }
          aggregate: {
            args: Prisma.ClubBookMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubBookMessage>
          }
          groupBy: {
            args: Prisma.ClubBookMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubBookMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubBookMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ClubBookMessageCountAggregateOutputType> | number
          }
        }
      }
      ClubBookArtifact: {
        payload: Prisma.$ClubBookArtifactPayload<ExtArgs>
        fields: Prisma.ClubBookArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubBookArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubBookArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>
          }
          findFirst: {
            args: Prisma.ClubBookArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubBookArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>
          }
          findMany: {
            args: Prisma.ClubBookArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>[]
          }
          create: {
            args: Prisma.ClubBookArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>
          }
          createMany: {
            args: Prisma.ClubBookArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubBookArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>[]
          }
          delete: {
            args: Prisma.ClubBookArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>
          }
          update: {
            args: Prisma.ClubBookArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ClubBookArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubBookArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubBookArtifactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>[]
          }
          upsert: {
            args: Prisma.ClubBookArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubBookArtifactPayload>
          }
          aggregate: {
            args: Prisma.ClubBookArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubBookArtifact>
          }
          groupBy: {
            args: Prisma.ClubBookArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubBookArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubBookArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ClubBookArtifactCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      ChannelMessage: {
        payload: Prisma.$ChannelMessagePayload<ExtArgs>
        fields: Prisma.ChannelMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>
          }
          findFirst: {
            args: Prisma.ChannelMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>
          }
          findMany: {
            args: Prisma.ChannelMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>[]
          }
          create: {
            args: Prisma.ChannelMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>
          }
          createMany: {
            args: Prisma.ChannelMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>[]
          }
          delete: {
            args: Prisma.ChannelMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>
          }
          update: {
            args: Prisma.ChannelMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChannelMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChannelMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChannelMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMessagePayload>
          }
          aggregate: {
            args: Prisma.ChannelMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelMessage>
          }
          groupBy: {
            args: Prisma.ChannelMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelMessageCountAggregateOutputType> | number
          }
        }
      }
      DirectMessage: {
        payload: Prisma.$DirectMessagePayload<ExtArgs>
        fields: Prisma.DirectMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirectMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirectMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findFirst: {
            args: Prisma.DirectMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirectMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findMany: {
            args: Prisma.DirectMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          create: {
            args: Prisma.DirectMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          createMany: {
            args: Prisma.DirectMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DirectMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          delete: {
            args: Prisma.DirectMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          update: {
            args: Prisma.DirectMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          deleteMany: {
            args: Prisma.DirectMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirectMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DirectMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          upsert: {
            args: Prisma.DirectMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          aggregate: {
            args: Prisma.DirectMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirectMessage>
          }
          groupBy: {
            args: Prisma.DirectMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirectMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PostImage: {
        payload: Prisma.$PostImagePayload<ExtArgs>
        fields: Prisma.PostImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          findFirst: {
            args: Prisma.PostImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          findMany: {
            args: Prisma.PostImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          create: {
            args: Prisma.PostImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          createMany: {
            args: Prisma.PostImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          delete: {
            args: Prisma.PostImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          update: {
            args: Prisma.PostImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          deleteMany: {
            args: Prisma.PostImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          upsert: {
            args: Prisma.PostImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          aggregate: {
            args: Prisma.PostImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostImage>
          }
          groupBy: {
            args: Prisma.PostImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostImageCountArgs<ExtArgs>
            result: $Utils.Optional<PostImageCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Poll: {
        payload: Prisma.$PollPayload<ExtArgs>
        fields: Prisma.PollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>
          }
          findFirst: {
            args: Prisma.PollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>
          }
          findMany: {
            args: Prisma.PollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>[]
          }
          create: {
            args: Prisma.PollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>
          }
          createMany: {
            args: Prisma.PollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>[]
          }
          delete: {
            args: Prisma.PollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>
          }
          update: {
            args: Prisma.PollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>
          }
          deleteMany: {
            args: Prisma.PollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PollUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>[]
          }
          upsert: {
            args: Prisma.PollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPayload>
          }
          aggregate: {
            args: Prisma.PollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoll>
          }
          groupBy: {
            args: Prisma.PollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PollCountArgs<ExtArgs>
            result: $Utils.Optional<PollCountAggregateOutputType> | number
          }
        }
      }
      PollOption: {
        payload: Prisma.$PollOptionPayload<ExtArgs>
        fields: Prisma.PollOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>
          }
          findFirst: {
            args: Prisma.PollOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>
          }
          findMany: {
            args: Prisma.PollOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>[]
          }
          create: {
            args: Prisma.PollOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>
          }
          createMany: {
            args: Prisma.PollOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PollOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>[]
          }
          delete: {
            args: Prisma.PollOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>
          }
          update: {
            args: Prisma.PollOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>
          }
          deleteMany: {
            args: Prisma.PollOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PollOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>[]
          }
          upsert: {
            args: Prisma.PollOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>
          }
          aggregate: {
            args: Prisma.PollOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePollOption>
          }
          groupBy: {
            args: Prisma.PollOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PollOptionCountArgs<ExtArgs>
            result: $Utils.Optional<PollOptionCountAggregateOutputType> | number
          }
        }
      }
      PollVote: {
        payload: Prisma.$PollVotePayload<ExtArgs>
        fields: Prisma.PollVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          findFirst: {
            args: Prisma.PollVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          findMany: {
            args: Prisma.PollVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          create: {
            args: Prisma.PollVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          createMany: {
            args: Prisma.PollVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PollVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          delete: {
            args: Prisma.PollVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          update: {
            args: Prisma.PollVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          deleteMany: {
            args: Prisma.PollVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PollVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          upsert: {
            args: Prisma.PollVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          aggregate: {
            args: Prisma.PollVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePollVote>
          }
          groupBy: {
            args: Prisma.PollVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PollVoteCountArgs<ExtArgs>
            result: $Utils.Optional<PollVoteCountAggregateOutputType> | number
          }
        }
      }
      ClubEvent: {
        payload: Prisma.$ClubEventPayload<ExtArgs>
        fields: Prisma.ClubEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>
          }
          findFirst: {
            args: Prisma.ClubEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>
          }
          findMany: {
            args: Prisma.ClubEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>[]
          }
          create: {
            args: Prisma.ClubEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>
          }
          createMany: {
            args: Prisma.ClubEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>[]
          }
          delete: {
            args: Prisma.ClubEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>
          }
          update: {
            args: Prisma.ClubEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>
          }
          deleteMany: {
            args: Prisma.ClubEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>[]
          }
          upsert: {
            args: Prisma.ClubEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPayload>
          }
          aggregate: {
            args: Prisma.ClubEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubEvent>
          }
          groupBy: {
            args: Prisma.ClubEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubEventCountArgs<ExtArgs>
            result: $Utils.Optional<ClubEventCountAggregateOutputType> | number
          }
        }
      }
      ClubEventParticipant: {
        payload: Prisma.$ClubEventParticipantPayload<ExtArgs>
        fields: Prisma.ClubEventParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubEventParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubEventParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>
          }
          findFirst: {
            args: Prisma.ClubEventParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubEventParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>
          }
          findMany: {
            args: Prisma.ClubEventParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>[]
          }
          create: {
            args: Prisma.ClubEventParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>
          }
          createMany: {
            args: Prisma.ClubEventParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubEventParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>[]
          }
          delete: {
            args: Prisma.ClubEventParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>
          }
          update: {
            args: Prisma.ClubEventParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ClubEventParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubEventParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubEventParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ClubEventParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventParticipantPayload>
          }
          aggregate: {
            args: Prisma.ClubEventParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubEventParticipant>
          }
          groupBy: {
            args: Prisma.ClubEventParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubEventParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubEventParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ClubEventParticipantCountAggregateOutputType> | number
          }
        }
      }
      ClubEventPhoto: {
        payload: Prisma.$ClubEventPhotoPayload<ExtArgs>
        fields: Prisma.ClubEventPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubEventPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubEventPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>
          }
          findFirst: {
            args: Prisma.ClubEventPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubEventPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>
          }
          findMany: {
            args: Prisma.ClubEventPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>[]
          }
          create: {
            args: Prisma.ClubEventPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>
          }
          createMany: {
            args: Prisma.ClubEventPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubEventPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>[]
          }
          delete: {
            args: Prisma.ClubEventPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>
          }
          update: {
            args: Prisma.ClubEventPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ClubEventPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubEventPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubEventPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>[]
          }
          upsert: {
            args: Prisma.ClubEventPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubEventPhotoPayload>
          }
          aggregate: {
            args: Prisma.ClubEventPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubEventPhoto>
          }
          groupBy: {
            args: Prisma.ClubEventPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubEventPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubEventPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ClubEventPhotoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    invitation?: InvitationOmit
    userCity?: UserCityOmit
    book?: BookOmit
    bookStyleImage?: BookStyleImageOmit
    category?: CategoryOmit
    group?: GroupOmit
    membership?: MembershipOmit
    joinRequest?: JoinRequestOmit
    groupInvite?: GroupInviteOmit
    groupBookOfMonthSelection?: GroupBookOfMonthSelectionOmit
    clubBook?: ClubBookOmit
    clubBookMessage?: ClubBookMessageOmit
    clubBookArtifact?: ClubBookArtifactOmit
    channel?: ChannelOmit
    channelMessage?: ChannelMessageOmit
    directMessage?: DirectMessageOmit
    post?: PostOmit
    postImage?: PostImageOmit
    like?: LikeOmit
    comment?: CommentOmit
    poll?: PollOmit
    pollOption?: PollOptionOmit
    pollVote?: PollVoteOmit
    clubEvent?: ClubEventOmit
    clubEventParticipant?: ClubEventParticipantOmit
    clubEventPhoto?: ClubEventPhotoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    cities: number
    createdBooks: number
    createdClubBooks: number
    clubEventPhotos: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | UserCountOutputTypeCountCitiesArgs
    createdBooks?: boolean | UserCountOutputTypeCountCreatedBooksArgs
    createdClubBooks?: boolean | UserCountOutputTypeCountCreatedClubBooksArgs
    clubEventPhotos?: boolean | UserCountOutputTypeCountClubEventPhotosArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedClubBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubBookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClubEventPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubEventPhotoWhereInput
  }


  /**
   * Count Type BookCountOutputType
   */

  export type BookCountOutputType = {
    categories: number
    styleImages: number
    clubBooks: number
    pollOptions: number
  }

  export type BookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | BookCountOutputTypeCountCategoriesArgs
    styleImages?: boolean | BookCountOutputTypeCountStyleImagesArgs
    clubBooks?: boolean | BookCountOutputTypeCountClubBooksArgs
    pollOptions?: boolean | BookCountOutputTypeCountPollOptionsArgs
  }

  // Custom InputTypes
  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCountOutputType
     */
    select?: BookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountStyleImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookStyleImageWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountClubBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubBookWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountPollOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollOptionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    books: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | CategoryCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    memberships: number
    invites: number
    joinRequests: number
    bookOfMonthSelections: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | GroupCountOutputTypeCountMembershipsArgs
    invites?: boolean | GroupCountOutputTypeCountInvitesArgs
    joinRequests?: boolean | GroupCountOutputTypeCountJoinRequestsArgs
    bookOfMonthSelections?: boolean | GroupCountOutputTypeCountBookOfMonthSelectionsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupInviteWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountJoinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinRequestWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountBookOfMonthSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupBookOfMonthSelectionWhereInput
  }


  /**
   * Count Type ClubBookCountOutputType
   */

  export type ClubBookCountOutputType = {
    messages: number
    artifacts: number
    events: number
  }

  export type ClubBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ClubBookCountOutputTypeCountMessagesArgs
    artifacts?: boolean | ClubBookCountOutputTypeCountArtifactsArgs
    events?: boolean | ClubBookCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * ClubBookCountOutputType without action
   */
  export type ClubBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookCountOutputType
     */
    select?: ClubBookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClubBookCountOutputType without action
   */
  export type ClubBookCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubBookMessageWhereInput
  }

  /**
   * ClubBookCountOutputType without action
   */
  export type ClubBookCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubBookArtifactWhereInput
  }

  /**
   * ClubBookCountOutputType without action
   */
  export type ClubBookCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubEventWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    messages: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChannelCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMessageWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    likes: number
    comments: number
    images: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | PostCountOutputTypeCountLikesArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    images?: boolean | PostCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageWhereInput
  }


  /**
   * Count Type PollCountOutputType
   */

  export type PollCountOutputType = {
    options: number
    votes: number
  }

  export type PollCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | PollCountOutputTypeCountOptionsArgs
    votes?: boolean | PollCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * PollCountOutputType without action
   */
  export type PollCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollCountOutputType
     */
    select?: PollCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PollCountOutputType without action
   */
  export type PollCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollOptionWhereInput
  }

  /**
   * PollCountOutputType without action
   */
  export type PollCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
  }


  /**
   * Count Type PollOptionCountOutputType
   */

  export type PollOptionCountOutputType = {
    votes: number
  }

  export type PollOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | PollOptionCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * PollOptionCountOutputType without action
   */
  export type PollOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOptionCountOutputType
     */
    select?: PollOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PollOptionCountOutputType without action
   */
  export type PollOptionCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
  }


  /**
   * Count Type ClubEventCountOutputType
   */

  export type ClubEventCountOutputType = {
    participants: number
    photos: number
  }

  export type ClubEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ClubEventCountOutputTypeCountParticipantsArgs
    photos?: boolean | ClubEventCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * ClubEventCountOutputType without action
   */
  export type ClubEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventCountOutputType
     */
    select?: ClubEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClubEventCountOutputType without action
   */
  export type ClubEventCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubEventParticipantWhereInput
  }

  /**
   * ClubEventCountOutputType without action
   */
  export type ClubEventCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubEventPhotoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    bio: string | null
    avatarUrl: string | null
    coverUrl: string | null
    isAdmin: boolean | null
    passwordHash: string | null
    passwordResetCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    bio: string | null
    avatarUrl: string | null
    coverUrl: string | null
    isAdmin: boolean | null
    passwordHash: string | null
    passwordResetCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    bio: number
    avatarUrl: number
    coverUrl: number
    isAdmin: number
    passwordHash: number
    passwordResetCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    avatarUrl?: true
    coverUrl?: true
    isAdmin?: true
    passwordHash?: true
    passwordResetCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    avatarUrl?: true
    coverUrl?: true
    isAdmin?: true
    passwordHash?: true
    passwordResetCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    avatarUrl?: true
    coverUrl?: true
    isAdmin?: true
    passwordHash?: true
    passwordResetCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl: string
    isAdmin: boolean
    passwordHash: string
    passwordResetCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    isAdmin?: boolean
    passwordHash?: boolean
    passwordResetCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cities?: boolean | User$citiesArgs<ExtArgs>
    createdBooks?: boolean | User$createdBooksArgs<ExtArgs>
    createdClubBooks?: boolean | User$createdClubBooksArgs<ExtArgs>
    clubEventPhotos?: boolean | User$clubEventPhotosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    isAdmin?: boolean
    passwordHash?: boolean
    passwordResetCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    isAdmin?: boolean
    passwordHash?: boolean
    passwordResetCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    isAdmin?: boolean
    passwordHash?: boolean
    passwordResetCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "bio" | "avatarUrl" | "coverUrl" | "isAdmin" | "passwordHash" | "passwordResetCode" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | User$citiesArgs<ExtArgs>
    createdBooks?: boolean | User$createdBooksArgs<ExtArgs>
    createdClubBooks?: boolean | User$createdClubBooksArgs<ExtArgs>
    clubEventPhotos?: boolean | User$clubEventPhotosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      cities: Prisma.$UserCityPayload<ExtArgs>[]
      createdBooks: Prisma.$BookPayload<ExtArgs>[]
      createdClubBooks: Prisma.$ClubBookPayload<ExtArgs>[]
      clubEventPhotos: Prisma.$ClubEventPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      bio: string
      avatarUrl: string
      coverUrl: string
      isAdmin: boolean
      passwordHash: string
      passwordResetCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends User$citiesArgs<ExtArgs> = {}>(args?: Subset<T, User$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBooks<T extends User$createdBooksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdClubBooks<T extends User$createdClubBooksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdClubBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clubEventPhotos<T extends User$clubEventPhotosArgs<ExtArgs> = {}>(args?: Subset<T, User$clubEventPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly coverUrl: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly passwordResetCode: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.cities
   */
  export type User$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    where?: UserCityWhereInput
    orderBy?: UserCityOrderByWithRelationInput | UserCityOrderByWithRelationInput[]
    cursor?: UserCityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCityScalarFieldEnum | UserCityScalarFieldEnum[]
  }

  /**
   * User.createdBooks
   */
  export type User$createdBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * User.createdClubBooks
   */
  export type User$createdClubBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    where?: ClubBookWhereInput
    orderBy?: ClubBookOrderByWithRelationInput | ClubBookOrderByWithRelationInput[]
    cursor?: ClubBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubBookScalarFieldEnum | ClubBookScalarFieldEnum[]
  }

  /**
   * User.clubEventPhotos
   */
  export type User$clubEventPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    where?: ClubEventPhotoWhereInput
    orderBy?: ClubEventPhotoOrderByWithRelationInput | ClubEventPhotoOrderByWithRelationInput[]
    cursor?: ClubEventPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubEventPhotoScalarFieldEnum | ClubEventPhotoScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    city: string | null
    createdBy: string | null
    isUsed: boolean | null
    usedBy: string | null
    createdAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    city: string | null
    createdBy: string | null
    isUsed: boolean | null
    usedBy: string | null
    createdAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    city: number
    createdBy: number
    isUsed: number
    usedBy: number
    createdAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    city?: true
    createdBy?: true
    isUsed?: true
    usedBy?: true
    createdAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    city?: true
    createdBy?: true
    isUsed?: true
    usedBy?: true
    createdAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    city?: true
    createdBy?: true
    isUsed?: true
    usedBy?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    city: string
    createdBy: string
    isUsed: boolean
    usedBy: string | null
    createdAt: Date
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    city?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    createdAt?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "city" | "createdBy" | "isUsed" | "usedBy" | "createdAt", ExtArgs["result"]["invitation"]>

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      city: string
      createdBy: string
      isUsed: boolean
      usedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly city: FieldRef<"Invitation", 'String'>
    readonly createdBy: FieldRef<"Invitation", 'String'>
    readonly isUsed: FieldRef<"Invitation", 'Boolean'>
    readonly usedBy: FieldRef<"Invitation", 'String'>
    readonly createdAt: FieldRef<"Invitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
  }


  /**
   * Model UserCity
   */

  export type AggregateUserCity = {
    _count: UserCityCountAggregateOutputType | null
    _min: UserCityMinAggregateOutputType | null
    _max: UserCityMaxAggregateOutputType | null
  }

  export type UserCityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    city: string | null
  }

  export type UserCityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    city: string | null
  }

  export type UserCityCountAggregateOutputType = {
    id: number
    userId: number
    city: number
    _all: number
  }


  export type UserCityMinAggregateInputType = {
    id?: true
    userId?: true
    city?: true
  }

  export type UserCityMaxAggregateInputType = {
    id?: true
    userId?: true
    city?: true
  }

  export type UserCityCountAggregateInputType = {
    id?: true
    userId?: true
    city?: true
    _all?: true
  }

  export type UserCityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCity to aggregate.
     */
    where?: UserCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCities to fetch.
     */
    orderBy?: UserCityOrderByWithRelationInput | UserCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCities
    **/
    _count?: true | UserCityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCityMaxAggregateInputType
  }

  export type GetUserCityAggregateType<T extends UserCityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCity[P]>
      : GetScalarType<T[P], AggregateUserCity[P]>
  }




  export type UserCityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCityWhereInput
    orderBy?: UserCityOrderByWithAggregationInput | UserCityOrderByWithAggregationInput[]
    by: UserCityScalarFieldEnum[] | UserCityScalarFieldEnum
    having?: UserCityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCityCountAggregateInputType | true
    _min?: UserCityMinAggregateInputType
    _max?: UserCityMaxAggregateInputType
  }

  export type UserCityGroupByOutputType = {
    id: string
    userId: string
    city: string
    _count: UserCityCountAggregateOutputType | null
    _min: UserCityMinAggregateOutputType | null
    _max: UserCityMaxAggregateOutputType | null
  }

  type GetUserCityGroupByPayload<T extends UserCityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCityGroupByOutputType[P]>
            : GetScalarType<T[P], UserCityGroupByOutputType[P]>
        }
      >
    >


  export type UserCitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    city?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCity"]>

  export type UserCitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    city?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCity"]>

  export type UserCitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    city?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCity"]>

  export type UserCitySelectScalar = {
    id?: boolean
    userId?: boolean
    city?: boolean
  }

  export type UserCityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "city", ExtArgs["result"]["userCity"]>
  export type UserCityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserCityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      city: string
    }, ExtArgs["result"]["userCity"]>
    composites: {}
  }

  type UserCityGetPayload<S extends boolean | null | undefined | UserCityDefaultArgs> = $Result.GetResult<Prisma.$UserCityPayload, S>

  type UserCityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCityCountAggregateInputType | true
    }

  export interface UserCityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCity'], meta: { name: 'UserCity' } }
    /**
     * Find zero or one UserCity that matches the filter.
     * @param {UserCityFindUniqueArgs} args - Arguments to find a UserCity
     * @example
     * // Get one UserCity
     * const userCity = await prisma.userCity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCityFindUniqueArgs>(args: SelectSubset<T, UserCityFindUniqueArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCityFindUniqueOrThrowArgs} args - Arguments to find a UserCity
     * @example
     * // Get one UserCity
     * const userCity = await prisma.userCity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCityFindFirstArgs} args - Arguments to find a UserCity
     * @example
     * // Get one UserCity
     * const userCity = await prisma.userCity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCityFindFirstArgs>(args?: SelectSubset<T, UserCityFindFirstArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCityFindFirstOrThrowArgs} args - Arguments to find a UserCity
     * @example
     * // Get one UserCity
     * const userCity = await prisma.userCity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCities
     * const userCities = await prisma.userCity.findMany()
     * 
     * // Get first 10 UserCities
     * const userCities = await prisma.userCity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCityWithIdOnly = await prisma.userCity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCityFindManyArgs>(args?: SelectSubset<T, UserCityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCity.
     * @param {UserCityCreateArgs} args - Arguments to create a UserCity.
     * @example
     * // Create one UserCity
     * const UserCity = await prisma.userCity.create({
     *   data: {
     *     // ... data to create a UserCity
     *   }
     * })
     * 
     */
    create<T extends UserCityCreateArgs>(args: SelectSubset<T, UserCityCreateArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCities.
     * @param {UserCityCreateManyArgs} args - Arguments to create many UserCities.
     * @example
     * // Create many UserCities
     * const userCity = await prisma.userCity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCityCreateManyArgs>(args?: SelectSubset<T, UserCityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCities and returns the data saved in the database.
     * @param {UserCityCreateManyAndReturnArgs} args - Arguments to create many UserCities.
     * @example
     * // Create many UserCities
     * const userCity = await prisma.userCity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCities and only return the `id`
     * const userCityWithIdOnly = await prisma.userCity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCityCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCity.
     * @param {UserCityDeleteArgs} args - Arguments to delete one UserCity.
     * @example
     * // Delete one UserCity
     * const UserCity = await prisma.userCity.delete({
     *   where: {
     *     // ... filter to delete one UserCity
     *   }
     * })
     * 
     */
    delete<T extends UserCityDeleteArgs>(args: SelectSubset<T, UserCityDeleteArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCity.
     * @param {UserCityUpdateArgs} args - Arguments to update one UserCity.
     * @example
     * // Update one UserCity
     * const userCity = await prisma.userCity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCityUpdateArgs>(args: SelectSubset<T, UserCityUpdateArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCities.
     * @param {UserCityDeleteManyArgs} args - Arguments to filter UserCities to delete.
     * @example
     * // Delete a few UserCities
     * const { count } = await prisma.userCity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCityDeleteManyArgs>(args?: SelectSubset<T, UserCityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCities
     * const userCity = await prisma.userCity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCityUpdateManyArgs>(args: SelectSubset<T, UserCityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCities and returns the data updated in the database.
     * @param {UserCityUpdateManyAndReturnArgs} args - Arguments to update many UserCities.
     * @example
     * // Update many UserCities
     * const userCity = await prisma.userCity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCities and only return the `id`
     * const userCityWithIdOnly = await prisma.userCity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCityUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCity.
     * @param {UserCityUpsertArgs} args - Arguments to update or create a UserCity.
     * @example
     * // Update or create a UserCity
     * const userCity = await prisma.userCity.upsert({
     *   create: {
     *     // ... data to create a UserCity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCity we want to update
     *   }
     * })
     */
    upsert<T extends UserCityUpsertArgs>(args: SelectSubset<T, UserCityUpsertArgs<ExtArgs>>): Prisma__UserCityClient<$Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCityCountArgs} args - Arguments to filter UserCities to count.
     * @example
     * // Count the number of UserCities
     * const count = await prisma.userCity.count({
     *   where: {
     *     // ... the filter for the UserCities we want to count
     *   }
     * })
    **/
    count<T extends UserCityCountArgs>(
      args?: Subset<T, UserCityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCityAggregateArgs>(args: Subset<T, UserCityAggregateArgs>): Prisma.PrismaPromise<GetUserCityAggregateType<T>>

    /**
     * Group by UserCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCityGroupByArgs['orderBy'] }
        : { orderBy?: UserCityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCity model
   */
  readonly fields: UserCityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCity model
   */
  interface UserCityFieldRefs {
    readonly id: FieldRef<"UserCity", 'String'>
    readonly userId: FieldRef<"UserCity", 'String'>
    readonly city: FieldRef<"UserCity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserCity findUnique
   */
  export type UserCityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * Filter, which UserCity to fetch.
     */
    where: UserCityWhereUniqueInput
  }

  /**
   * UserCity findUniqueOrThrow
   */
  export type UserCityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * Filter, which UserCity to fetch.
     */
    where: UserCityWhereUniqueInput
  }

  /**
   * UserCity findFirst
   */
  export type UserCityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * Filter, which UserCity to fetch.
     */
    where?: UserCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCities to fetch.
     */
    orderBy?: UserCityOrderByWithRelationInput | UserCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCities.
     */
    cursor?: UserCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCities.
     */
    distinct?: UserCityScalarFieldEnum | UserCityScalarFieldEnum[]
  }

  /**
   * UserCity findFirstOrThrow
   */
  export type UserCityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * Filter, which UserCity to fetch.
     */
    where?: UserCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCities to fetch.
     */
    orderBy?: UserCityOrderByWithRelationInput | UserCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCities.
     */
    cursor?: UserCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCities.
     */
    distinct?: UserCityScalarFieldEnum | UserCityScalarFieldEnum[]
  }

  /**
   * UserCity findMany
   */
  export type UserCityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * Filter, which UserCities to fetch.
     */
    where?: UserCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCities to fetch.
     */
    orderBy?: UserCityOrderByWithRelationInput | UserCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCities.
     */
    cursor?: UserCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCities.
     */
    skip?: number
    distinct?: UserCityScalarFieldEnum | UserCityScalarFieldEnum[]
  }

  /**
   * UserCity create
   */
  export type UserCityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCity.
     */
    data: XOR<UserCityCreateInput, UserCityUncheckedCreateInput>
  }

  /**
   * UserCity createMany
   */
  export type UserCityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCities.
     */
    data: UserCityCreateManyInput | UserCityCreateManyInput[]
  }

  /**
   * UserCity createManyAndReturn
   */
  export type UserCityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * The data used to create many UserCities.
     */
    data: UserCityCreateManyInput | UserCityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCity update
   */
  export type UserCityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCity.
     */
    data: XOR<UserCityUpdateInput, UserCityUncheckedUpdateInput>
    /**
     * Choose, which UserCity to update.
     */
    where: UserCityWhereUniqueInput
  }

  /**
   * UserCity updateMany
   */
  export type UserCityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCities.
     */
    data: XOR<UserCityUpdateManyMutationInput, UserCityUncheckedUpdateManyInput>
    /**
     * Filter which UserCities to update
     */
    where?: UserCityWhereInput
    /**
     * Limit how many UserCities to update.
     */
    limit?: number
  }

  /**
   * UserCity updateManyAndReturn
   */
  export type UserCityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * The data used to update UserCities.
     */
    data: XOR<UserCityUpdateManyMutationInput, UserCityUncheckedUpdateManyInput>
    /**
     * Filter which UserCities to update
     */
    where?: UserCityWhereInput
    /**
     * Limit how many UserCities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCity upsert
   */
  export type UserCityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCity to update in case it exists.
     */
    where: UserCityWhereUniqueInput
    /**
     * In case the UserCity found by the `where` argument doesn't exist, create a new UserCity with this data.
     */
    create: XOR<UserCityCreateInput, UserCityUncheckedCreateInput>
    /**
     * In case the UserCity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCityUpdateInput, UserCityUncheckedUpdateInput>
  }

  /**
   * UserCity delete
   */
  export type UserCityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
    /**
     * Filter which UserCity to delete.
     */
    where: UserCityWhereUniqueInput
  }

  /**
   * UserCity deleteMany
   */
  export type UserCityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCities to delete
     */
    where?: UserCityWhereInput
    /**
     * Limit how many UserCities to delete.
     */
    limit?: number
  }

  /**
   * UserCity without action
   */
  export type UserCityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCity
     */
    select?: UserCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCity
     */
    omit?: UserCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCityInclude<ExtArgs> | null
  }


  /**
   * Model Book
   */

  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookMinAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    coverUrl: string | null
    synopsis: string | null
    aiStyleDescription: string | null
    createdByUserId: string | null
    indicationComment: string | null
    createdAt: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    coverUrl: string | null
    synopsis: string | null
    aiStyleDescription: string | null
    createdByUserId: string | null
    indicationComment: string | null
    createdAt: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    title: number
    author: number
    coverUrl: number
    synopsis: number
    aiStyleDescription: number
    createdByUserId: number
    indicationComment: number
    createdAt: number
    _all: number
  }


  export type BookMinAggregateInputType = {
    id?: true
    title?: true
    author?: true
    coverUrl?: true
    synopsis?: true
    aiStyleDescription?: true
    createdByUserId?: true
    indicationComment?: true
    createdAt?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    title?: true
    author?: true
    coverUrl?: true
    synopsis?: true
    aiStyleDescription?: true
    createdByUserId?: true
    indicationComment?: true
    createdAt?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    title?: true
    author?: true
    coverUrl?: true
    synopsis?: true
    aiStyleDescription?: true
    createdByUserId?: true
    indicationComment?: true
    createdAt?: true
    _all?: true
  }

  export type BookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
    orderBy?: BookOrderByWithAggregationInput | BookOrderByWithAggregationInput[]
    by: BookScalarFieldEnum[] | BookScalarFieldEnum
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }

  export type BookGroupByOutputType = {
    id: string
    title: string
    author: string
    coverUrl: string
    synopsis: string
    aiStyleDescription: string
    createdByUserId: string | null
    indicationComment: string
    createdAt: Date
    _count: BookCountAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    synopsis?: boolean
    aiStyleDescription?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
    categories?: boolean | Book$categoriesArgs<ExtArgs>
    styleImages?: boolean | Book$styleImagesArgs<ExtArgs>
    createdByUser?: boolean | Book$createdByUserArgs<ExtArgs>
    clubBooks?: boolean | Book$clubBooksArgs<ExtArgs>
    pollOptions?: boolean | Book$pollOptionsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    synopsis?: boolean
    aiStyleDescription?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
    createdByUser?: boolean | Book$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    synopsis?: boolean
    aiStyleDescription?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
    createdByUser?: boolean | Book$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectScalar = {
    id?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    synopsis?: boolean
    aiStyleDescription?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
  }

  export type BookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "author" | "coverUrl" | "synopsis" | "aiStyleDescription" | "createdByUserId" | "indicationComment" | "createdAt", ExtArgs["result"]["book"]>
  export type BookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Book$categoriesArgs<ExtArgs>
    styleImages?: boolean | Book$styleImagesArgs<ExtArgs>
    createdByUser?: boolean | Book$createdByUserArgs<ExtArgs>
    clubBooks?: boolean | Book$clubBooksArgs<ExtArgs>
    pollOptions?: boolean | Book$pollOptionsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Book$createdByUserArgs<ExtArgs>
  }
  export type BookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Book$createdByUserArgs<ExtArgs>
  }

  export type $BookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      styleImages: Prisma.$BookStyleImagePayload<ExtArgs>[]
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
      clubBooks: Prisma.$ClubBookPayload<ExtArgs>[]
      pollOptions: Prisma.$PollOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      author: string
      coverUrl: string
      synopsis: string
      aiStyleDescription: string
      createdByUserId: string | null
      indicationComment: string
      createdAt: Date
    }, ExtArgs["result"]["book"]>
    composites: {}
  }

  type BookGetPayload<S extends boolean | null | undefined | BookDefaultArgs> = $Result.GetResult<Prisma.$BookPayload, S>

  type BookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book'], meta: { name: 'Book' } }
    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookFindUniqueArgs>(args: SelectSubset<T, BookFindUniqueArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(args: SelectSubset<T, BookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookFindFirstArgs>(args?: SelectSubset<T, BookFindFirstArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(args?: SelectSubset<T, BookFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookFindManyArgs>(args?: SelectSubset<T, BookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
     */
    create<T extends BookCreateArgs>(args: SelectSubset<T, BookCreateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {BookCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCreateManyArgs>(args?: SelectSubset<T, BookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {BookCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookCreateManyAndReturnArgs>(args?: SelectSubset<T, BookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
     */
    delete<T extends BookDeleteArgs>(args: SelectSubset<T, BookDeleteArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookUpdateArgs>(args: SelectSubset<T, BookUpdateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookDeleteManyArgs>(args?: SelectSubset<T, BookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookUpdateManyArgs>(args: SelectSubset<T, BookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books and returns the data updated in the database.
     * @param {BookUpdateManyAndReturnArgs} args - Arguments to update many Books.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookUpdateManyAndReturnArgs>(args: SelectSubset<T, BookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
     */
    upsert<T extends BookUpsertArgs>(args: SelectSubset<T, BookUpsertArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book model
   */
  readonly fields: BookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Book$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Book$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    styleImages<T extends Book$styleImagesArgs<ExtArgs> = {}>(args?: Subset<T, Book$styleImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdByUser<T extends Book$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, Book$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clubBooks<T extends Book$clubBooksArgs<ExtArgs> = {}>(args?: Subset<T, Book$clubBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pollOptions<T extends Book$pollOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Book$pollOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book model
   */
  interface BookFieldRefs {
    readonly id: FieldRef<"Book", 'String'>
    readonly title: FieldRef<"Book", 'String'>
    readonly author: FieldRef<"Book", 'String'>
    readonly coverUrl: FieldRef<"Book", 'String'>
    readonly synopsis: FieldRef<"Book", 'String'>
    readonly aiStyleDescription: FieldRef<"Book", 'String'>
    readonly createdByUserId: FieldRef<"Book", 'String'>
    readonly indicationComment: FieldRef<"Book", 'String'>
    readonly createdAt: FieldRef<"Book", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Book findUnique
   */
  export type BookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findFirst
   */
  export type BookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findMany
   */
  export type BookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book create
   */
  export type BookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }

  /**
   * Book createMany
   */
  export type BookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
  }

  /**
   * Book createManyAndReturn
   */
  export type BookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book update
   */
  export type BookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Book updateManyAndReturn
   */
  export type BookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book upsert
   */
  export type BookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }

  /**
   * Book delete
   */
  export type BookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to delete.
     */
    limit?: number
  }

  /**
   * Book.categories
   */
  export type Book$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Book.styleImages
   */
  export type Book$styleImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    where?: BookStyleImageWhereInput
    orderBy?: BookStyleImageOrderByWithRelationInput | BookStyleImageOrderByWithRelationInput[]
    cursor?: BookStyleImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookStyleImageScalarFieldEnum | BookStyleImageScalarFieldEnum[]
  }

  /**
   * Book.createdByUser
   */
  export type Book$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Book.clubBooks
   */
  export type Book$clubBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    where?: ClubBookWhereInput
    orderBy?: ClubBookOrderByWithRelationInput | ClubBookOrderByWithRelationInput[]
    cursor?: ClubBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubBookScalarFieldEnum | ClubBookScalarFieldEnum[]
  }

  /**
   * Book.pollOptions
   */
  export type Book$pollOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    where?: PollOptionWhereInput
    orderBy?: PollOptionOrderByWithRelationInput | PollOptionOrderByWithRelationInput[]
    cursor?: PollOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[]
  }

  /**
   * Book without action
   */
  export type BookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
  }


  /**
   * Model BookStyleImage
   */

  export type AggregateBookStyleImage = {
    _count: BookStyleImageCountAggregateOutputType | null
    _min: BookStyleImageMinAggregateOutputType | null
    _max: BookStyleImageMaxAggregateOutputType | null
  }

  export type BookStyleImageMinAggregateOutputType = {
    id: string | null
    bookId: string | null
    url: string | null
  }

  export type BookStyleImageMaxAggregateOutputType = {
    id: string | null
    bookId: string | null
    url: string | null
  }

  export type BookStyleImageCountAggregateOutputType = {
    id: number
    bookId: number
    url: number
    _all: number
  }


  export type BookStyleImageMinAggregateInputType = {
    id?: true
    bookId?: true
    url?: true
  }

  export type BookStyleImageMaxAggregateInputType = {
    id?: true
    bookId?: true
    url?: true
  }

  export type BookStyleImageCountAggregateInputType = {
    id?: true
    bookId?: true
    url?: true
    _all?: true
  }

  export type BookStyleImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookStyleImage to aggregate.
     */
    where?: BookStyleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookStyleImages to fetch.
     */
    orderBy?: BookStyleImageOrderByWithRelationInput | BookStyleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookStyleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookStyleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookStyleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookStyleImages
    **/
    _count?: true | BookStyleImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookStyleImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookStyleImageMaxAggregateInputType
  }

  export type GetBookStyleImageAggregateType<T extends BookStyleImageAggregateArgs> = {
        [P in keyof T & keyof AggregateBookStyleImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookStyleImage[P]>
      : GetScalarType<T[P], AggregateBookStyleImage[P]>
  }




  export type BookStyleImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookStyleImageWhereInput
    orderBy?: BookStyleImageOrderByWithAggregationInput | BookStyleImageOrderByWithAggregationInput[]
    by: BookStyleImageScalarFieldEnum[] | BookStyleImageScalarFieldEnum
    having?: BookStyleImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookStyleImageCountAggregateInputType | true
    _min?: BookStyleImageMinAggregateInputType
    _max?: BookStyleImageMaxAggregateInputType
  }

  export type BookStyleImageGroupByOutputType = {
    id: string
    bookId: string
    url: string
    _count: BookStyleImageCountAggregateOutputType | null
    _min: BookStyleImageMinAggregateOutputType | null
    _max: BookStyleImageMaxAggregateOutputType | null
  }

  type GetBookStyleImageGroupByPayload<T extends BookStyleImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookStyleImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookStyleImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookStyleImageGroupByOutputType[P]>
            : GetScalarType<T[P], BookStyleImageGroupByOutputType[P]>
        }
      >
    >


  export type BookStyleImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    url?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookStyleImage"]>

  export type BookStyleImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    url?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookStyleImage"]>

  export type BookStyleImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    url?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookStyleImage"]>

  export type BookStyleImageSelectScalar = {
    id?: boolean
    bookId?: boolean
    url?: boolean
  }

  export type BookStyleImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookId" | "url", ExtArgs["result"]["bookStyleImage"]>
  export type BookStyleImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
  }
  export type BookStyleImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
  }
  export type BookStyleImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
  }

  export type $BookStyleImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookStyleImage"
    objects: {
      book: Prisma.$BookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookId: string
      url: string
    }, ExtArgs["result"]["bookStyleImage"]>
    composites: {}
  }

  type BookStyleImageGetPayload<S extends boolean | null | undefined | BookStyleImageDefaultArgs> = $Result.GetResult<Prisma.$BookStyleImagePayload, S>

  type BookStyleImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookStyleImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookStyleImageCountAggregateInputType | true
    }

  export interface BookStyleImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookStyleImage'], meta: { name: 'BookStyleImage' } }
    /**
     * Find zero or one BookStyleImage that matches the filter.
     * @param {BookStyleImageFindUniqueArgs} args - Arguments to find a BookStyleImage
     * @example
     * // Get one BookStyleImage
     * const bookStyleImage = await prisma.bookStyleImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookStyleImageFindUniqueArgs>(args: SelectSubset<T, BookStyleImageFindUniqueArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookStyleImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookStyleImageFindUniqueOrThrowArgs} args - Arguments to find a BookStyleImage
     * @example
     * // Get one BookStyleImage
     * const bookStyleImage = await prisma.bookStyleImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookStyleImageFindUniqueOrThrowArgs>(args: SelectSubset<T, BookStyleImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookStyleImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookStyleImageFindFirstArgs} args - Arguments to find a BookStyleImage
     * @example
     * // Get one BookStyleImage
     * const bookStyleImage = await prisma.bookStyleImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookStyleImageFindFirstArgs>(args?: SelectSubset<T, BookStyleImageFindFirstArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookStyleImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookStyleImageFindFirstOrThrowArgs} args - Arguments to find a BookStyleImage
     * @example
     * // Get one BookStyleImage
     * const bookStyleImage = await prisma.bookStyleImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookStyleImageFindFirstOrThrowArgs>(args?: SelectSubset<T, BookStyleImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookStyleImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookStyleImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookStyleImages
     * const bookStyleImages = await prisma.bookStyleImage.findMany()
     * 
     * // Get first 10 BookStyleImages
     * const bookStyleImages = await prisma.bookStyleImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookStyleImageWithIdOnly = await prisma.bookStyleImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookStyleImageFindManyArgs>(args?: SelectSubset<T, BookStyleImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookStyleImage.
     * @param {BookStyleImageCreateArgs} args - Arguments to create a BookStyleImage.
     * @example
     * // Create one BookStyleImage
     * const BookStyleImage = await prisma.bookStyleImage.create({
     *   data: {
     *     // ... data to create a BookStyleImage
     *   }
     * })
     * 
     */
    create<T extends BookStyleImageCreateArgs>(args: SelectSubset<T, BookStyleImageCreateArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookStyleImages.
     * @param {BookStyleImageCreateManyArgs} args - Arguments to create many BookStyleImages.
     * @example
     * // Create many BookStyleImages
     * const bookStyleImage = await prisma.bookStyleImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookStyleImageCreateManyArgs>(args?: SelectSubset<T, BookStyleImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookStyleImages and returns the data saved in the database.
     * @param {BookStyleImageCreateManyAndReturnArgs} args - Arguments to create many BookStyleImages.
     * @example
     * // Create many BookStyleImages
     * const bookStyleImage = await prisma.bookStyleImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookStyleImages and only return the `id`
     * const bookStyleImageWithIdOnly = await prisma.bookStyleImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookStyleImageCreateManyAndReturnArgs>(args?: SelectSubset<T, BookStyleImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookStyleImage.
     * @param {BookStyleImageDeleteArgs} args - Arguments to delete one BookStyleImage.
     * @example
     * // Delete one BookStyleImage
     * const BookStyleImage = await prisma.bookStyleImage.delete({
     *   where: {
     *     // ... filter to delete one BookStyleImage
     *   }
     * })
     * 
     */
    delete<T extends BookStyleImageDeleteArgs>(args: SelectSubset<T, BookStyleImageDeleteArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookStyleImage.
     * @param {BookStyleImageUpdateArgs} args - Arguments to update one BookStyleImage.
     * @example
     * // Update one BookStyleImage
     * const bookStyleImage = await prisma.bookStyleImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookStyleImageUpdateArgs>(args: SelectSubset<T, BookStyleImageUpdateArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookStyleImages.
     * @param {BookStyleImageDeleteManyArgs} args - Arguments to filter BookStyleImages to delete.
     * @example
     * // Delete a few BookStyleImages
     * const { count } = await prisma.bookStyleImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookStyleImageDeleteManyArgs>(args?: SelectSubset<T, BookStyleImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookStyleImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookStyleImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookStyleImages
     * const bookStyleImage = await prisma.bookStyleImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookStyleImageUpdateManyArgs>(args: SelectSubset<T, BookStyleImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookStyleImages and returns the data updated in the database.
     * @param {BookStyleImageUpdateManyAndReturnArgs} args - Arguments to update many BookStyleImages.
     * @example
     * // Update many BookStyleImages
     * const bookStyleImage = await prisma.bookStyleImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookStyleImages and only return the `id`
     * const bookStyleImageWithIdOnly = await prisma.bookStyleImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookStyleImageUpdateManyAndReturnArgs>(args: SelectSubset<T, BookStyleImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookStyleImage.
     * @param {BookStyleImageUpsertArgs} args - Arguments to update or create a BookStyleImage.
     * @example
     * // Update or create a BookStyleImage
     * const bookStyleImage = await prisma.bookStyleImage.upsert({
     *   create: {
     *     // ... data to create a BookStyleImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookStyleImage we want to update
     *   }
     * })
     */
    upsert<T extends BookStyleImageUpsertArgs>(args: SelectSubset<T, BookStyleImageUpsertArgs<ExtArgs>>): Prisma__BookStyleImageClient<$Result.GetResult<Prisma.$BookStyleImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookStyleImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookStyleImageCountArgs} args - Arguments to filter BookStyleImages to count.
     * @example
     * // Count the number of BookStyleImages
     * const count = await prisma.bookStyleImage.count({
     *   where: {
     *     // ... the filter for the BookStyleImages we want to count
     *   }
     * })
    **/
    count<T extends BookStyleImageCountArgs>(
      args?: Subset<T, BookStyleImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookStyleImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookStyleImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookStyleImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookStyleImageAggregateArgs>(args: Subset<T, BookStyleImageAggregateArgs>): Prisma.PrismaPromise<GetBookStyleImageAggregateType<T>>

    /**
     * Group by BookStyleImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookStyleImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookStyleImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookStyleImageGroupByArgs['orderBy'] }
        : { orderBy?: BookStyleImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookStyleImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookStyleImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookStyleImage model
   */
  readonly fields: BookStyleImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookStyleImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookStyleImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookDefaultArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookStyleImage model
   */
  interface BookStyleImageFieldRefs {
    readonly id: FieldRef<"BookStyleImage", 'String'>
    readonly bookId: FieldRef<"BookStyleImage", 'String'>
    readonly url: FieldRef<"BookStyleImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookStyleImage findUnique
   */
  export type BookStyleImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * Filter, which BookStyleImage to fetch.
     */
    where: BookStyleImageWhereUniqueInput
  }

  /**
   * BookStyleImage findUniqueOrThrow
   */
  export type BookStyleImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * Filter, which BookStyleImage to fetch.
     */
    where: BookStyleImageWhereUniqueInput
  }

  /**
   * BookStyleImage findFirst
   */
  export type BookStyleImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * Filter, which BookStyleImage to fetch.
     */
    where?: BookStyleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookStyleImages to fetch.
     */
    orderBy?: BookStyleImageOrderByWithRelationInput | BookStyleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookStyleImages.
     */
    cursor?: BookStyleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookStyleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookStyleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookStyleImages.
     */
    distinct?: BookStyleImageScalarFieldEnum | BookStyleImageScalarFieldEnum[]
  }

  /**
   * BookStyleImage findFirstOrThrow
   */
  export type BookStyleImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * Filter, which BookStyleImage to fetch.
     */
    where?: BookStyleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookStyleImages to fetch.
     */
    orderBy?: BookStyleImageOrderByWithRelationInput | BookStyleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookStyleImages.
     */
    cursor?: BookStyleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookStyleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookStyleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookStyleImages.
     */
    distinct?: BookStyleImageScalarFieldEnum | BookStyleImageScalarFieldEnum[]
  }

  /**
   * BookStyleImage findMany
   */
  export type BookStyleImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * Filter, which BookStyleImages to fetch.
     */
    where?: BookStyleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookStyleImages to fetch.
     */
    orderBy?: BookStyleImageOrderByWithRelationInput | BookStyleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookStyleImages.
     */
    cursor?: BookStyleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookStyleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookStyleImages.
     */
    skip?: number
    distinct?: BookStyleImageScalarFieldEnum | BookStyleImageScalarFieldEnum[]
  }

  /**
   * BookStyleImage create
   */
  export type BookStyleImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * The data needed to create a BookStyleImage.
     */
    data: XOR<BookStyleImageCreateInput, BookStyleImageUncheckedCreateInput>
  }

  /**
   * BookStyleImage createMany
   */
  export type BookStyleImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookStyleImages.
     */
    data: BookStyleImageCreateManyInput | BookStyleImageCreateManyInput[]
  }

  /**
   * BookStyleImage createManyAndReturn
   */
  export type BookStyleImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * The data used to create many BookStyleImages.
     */
    data: BookStyleImageCreateManyInput | BookStyleImageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookStyleImage update
   */
  export type BookStyleImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * The data needed to update a BookStyleImage.
     */
    data: XOR<BookStyleImageUpdateInput, BookStyleImageUncheckedUpdateInput>
    /**
     * Choose, which BookStyleImage to update.
     */
    where: BookStyleImageWhereUniqueInput
  }

  /**
   * BookStyleImage updateMany
   */
  export type BookStyleImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookStyleImages.
     */
    data: XOR<BookStyleImageUpdateManyMutationInput, BookStyleImageUncheckedUpdateManyInput>
    /**
     * Filter which BookStyleImages to update
     */
    where?: BookStyleImageWhereInput
    /**
     * Limit how many BookStyleImages to update.
     */
    limit?: number
  }

  /**
   * BookStyleImage updateManyAndReturn
   */
  export type BookStyleImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * The data used to update BookStyleImages.
     */
    data: XOR<BookStyleImageUpdateManyMutationInput, BookStyleImageUncheckedUpdateManyInput>
    /**
     * Filter which BookStyleImages to update
     */
    where?: BookStyleImageWhereInput
    /**
     * Limit how many BookStyleImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookStyleImage upsert
   */
  export type BookStyleImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * The filter to search for the BookStyleImage to update in case it exists.
     */
    where: BookStyleImageWhereUniqueInput
    /**
     * In case the BookStyleImage found by the `where` argument doesn't exist, create a new BookStyleImage with this data.
     */
    create: XOR<BookStyleImageCreateInput, BookStyleImageUncheckedCreateInput>
    /**
     * In case the BookStyleImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookStyleImageUpdateInput, BookStyleImageUncheckedUpdateInput>
  }

  /**
   * BookStyleImage delete
   */
  export type BookStyleImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
    /**
     * Filter which BookStyleImage to delete.
     */
    where: BookStyleImageWhereUniqueInput
  }

  /**
   * BookStyleImage deleteMany
   */
  export type BookStyleImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookStyleImages to delete
     */
    where?: BookStyleImageWhereInput
    /**
     * Limit how many BookStyleImages to delete.
     */
    limit?: number
  }

  /**
   * BookStyleImage without action
   */
  export type BookStyleImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookStyleImage
     */
    select?: BookStyleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookStyleImage
     */
    omit?: BookStyleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookStyleImageInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    books?: boolean | Category$booksArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Category$booksArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      books: Prisma.$BookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Category$booksArgs<ExtArgs> = {}>(args?: Subset<T, Category$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.books
   */
  export type Category$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    createdAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    description: string
    ownerId: string
    createdAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    memberships?: boolean | Group$membershipsArgs<ExtArgs>
    invites?: boolean | Group$invitesArgs<ExtArgs>
    joinRequests?: boolean | Group$joinRequestsArgs<ExtArgs>
    bookOfMonthSelections?: boolean | Group$bookOfMonthSelectionsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ownerId" | "createdAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | Group$membershipsArgs<ExtArgs>
    invites?: boolean | Group$invitesArgs<ExtArgs>
    joinRequests?: boolean | Group$joinRequestsArgs<ExtArgs>
    bookOfMonthSelections?: boolean | Group$bookOfMonthSelectionsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      memberships: Prisma.$MembershipPayload<ExtArgs>[]
      invites: Prisma.$GroupInvitePayload<ExtArgs>[]
      joinRequests: Prisma.$JoinRequestPayload<ExtArgs>[]
      bookOfMonthSelections: Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      ownerId: string
      createdAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends Group$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Group$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invites<T extends Group$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Group$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    joinRequests<T extends Group$joinRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Group$joinRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookOfMonthSelections<T extends Group$bookOfMonthSelectionsArgs<ExtArgs> = {}>(args?: Subset<T, Group$bookOfMonthSelectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly ownerId: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.memberships
   */
  export type Group$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    cursor?: MembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Group.invites
   */
  export type Group$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    where?: GroupInviteWhereInput
    orderBy?: GroupInviteOrderByWithRelationInput | GroupInviteOrderByWithRelationInput[]
    cursor?: GroupInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupInviteScalarFieldEnum | GroupInviteScalarFieldEnum[]
  }

  /**
   * Group.joinRequests
   */
  export type Group$joinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    where?: JoinRequestWhereInput
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    cursor?: JoinRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * Group.bookOfMonthSelections
   */
  export type Group$bookOfMonthSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    where?: GroupBookOfMonthSelectionWhereInput
    orderBy?: GroupBookOfMonthSelectionOrderByWithRelationInput | GroupBookOfMonthSelectionOrderByWithRelationInput[]
    cursor?: GroupBookOfMonthSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupBookOfMonthSelectionScalarFieldEnum | GroupBookOfMonthSelectionScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: string | null
  }

  export type MembershipMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: string | null
  }

  export type MembershipCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    role: number
    _all: number
  }


  export type MembershipMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
  }

  export type MembershipMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
  }

  export type MembershipCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type MembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithAggregationInput | MembershipOrderByWithAggregationInput[]
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum
    having?: MembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }

  export type MembershipGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    role: string
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type MembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
  }

  export type MembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "role", ExtArgs["result"]["membership"]>
  export type MembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $MembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Membership"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      role: string
    }, ExtArgs["result"]["membership"]>
    composites: {}
  }

  type MembershipGetPayload<S extends boolean | null | undefined | MembershipDefaultArgs> = $Result.GetResult<Prisma.$MembershipPayload, S>

  type MembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipCountAggregateInputType | true
    }

  export interface MembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Membership'], meta: { name: 'Membership' } }
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipFindManyArgs>(args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
     */
    create<T extends MembershipCreateArgs>(args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipCreateManyArgs>(args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
     */
    delete<T extends MembershipDeleteArgs>(args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUpdateArgs>(args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipDeleteManyArgs>(args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUpdateManyArgs>(args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships and returns the data updated in the database.
     * @param {MembershipUpdateManyAndReturnArgs} args - Arguments to update many Memberships.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): Prisma.PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Membership model
   */
  readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Membership model
   */
  interface MembershipFieldRefs {
    readonly id: FieldRef<"Membership", 'String'>
    readonly groupId: FieldRef<"Membership", 'String'>
    readonly userId: FieldRef<"Membership", 'String'>
    readonly role: FieldRef<"Membership", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership create
   */
  export type MembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
  }

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
  }

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
  }

  /**
   * Membership updateManyAndReturn
   */
  export type MembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
  }

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to delete.
     */
    limit?: number
  }

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
  }


  /**
   * Model JoinRequest
   */

  export type AggregateJoinRequest = {
    _count: JoinRequestCountAggregateOutputType | null
    _min: JoinRequestMinAggregateOutputType | null
    _max: JoinRequestMaxAggregateOutputType | null
  }

  export type JoinRequestMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type JoinRequestMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type JoinRequestCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    status: number
    createdAt: number
    _all: number
  }


  export type JoinRequestMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type JoinRequestMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type JoinRequestCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type JoinRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinRequest to aggregate.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JoinRequests
    **/
    _count?: true | JoinRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JoinRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JoinRequestMaxAggregateInputType
  }

  export type GetJoinRequestAggregateType<T extends JoinRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateJoinRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJoinRequest[P]>
      : GetScalarType<T[P], AggregateJoinRequest[P]>
  }




  export type JoinRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinRequestWhereInput
    orderBy?: JoinRequestOrderByWithAggregationInput | JoinRequestOrderByWithAggregationInput[]
    by: JoinRequestScalarFieldEnum[] | JoinRequestScalarFieldEnum
    having?: JoinRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JoinRequestCountAggregateInputType | true
    _min?: JoinRequestMinAggregateInputType
    _max?: JoinRequestMaxAggregateInputType
  }

  export type JoinRequestGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    status: string
    createdAt: Date
    _count: JoinRequestCountAggregateOutputType | null
    _min: JoinRequestMinAggregateOutputType | null
    _max: JoinRequestMaxAggregateOutputType | null
  }

  type GetJoinRequestGroupByPayload<T extends JoinRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JoinRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JoinRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JoinRequestGroupByOutputType[P]>
            : GetScalarType<T[P], JoinRequestGroupByOutputType[P]>
        }
      >
    >


  export type JoinRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinRequest"]>

  export type JoinRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinRequest"]>

  export type JoinRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinRequest"]>

  export type JoinRequestSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type JoinRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "status" | "createdAt", ExtArgs["result"]["joinRequest"]>
  export type JoinRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type JoinRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type JoinRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $JoinRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JoinRequest"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["joinRequest"]>
    composites: {}
  }

  type JoinRequestGetPayload<S extends boolean | null | undefined | JoinRequestDefaultArgs> = $Result.GetResult<Prisma.$JoinRequestPayload, S>

  type JoinRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JoinRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JoinRequestCountAggregateInputType | true
    }

  export interface JoinRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JoinRequest'], meta: { name: 'JoinRequest' } }
    /**
     * Find zero or one JoinRequest that matches the filter.
     * @param {JoinRequestFindUniqueArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JoinRequestFindUniqueArgs>(args: SelectSubset<T, JoinRequestFindUniqueArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JoinRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JoinRequestFindUniqueOrThrowArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JoinRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, JoinRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JoinRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestFindFirstArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JoinRequestFindFirstArgs>(args?: SelectSubset<T, JoinRequestFindFirstArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JoinRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestFindFirstOrThrowArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JoinRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, JoinRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JoinRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JoinRequests
     * const joinRequests = await prisma.joinRequest.findMany()
     * 
     * // Get first 10 JoinRequests
     * const joinRequests = await prisma.joinRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const joinRequestWithIdOnly = await prisma.joinRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JoinRequestFindManyArgs>(args?: SelectSubset<T, JoinRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JoinRequest.
     * @param {JoinRequestCreateArgs} args - Arguments to create a JoinRequest.
     * @example
     * // Create one JoinRequest
     * const JoinRequest = await prisma.joinRequest.create({
     *   data: {
     *     // ... data to create a JoinRequest
     *   }
     * })
     * 
     */
    create<T extends JoinRequestCreateArgs>(args: SelectSubset<T, JoinRequestCreateArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JoinRequests.
     * @param {JoinRequestCreateManyArgs} args - Arguments to create many JoinRequests.
     * @example
     * // Create many JoinRequests
     * const joinRequest = await prisma.joinRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JoinRequestCreateManyArgs>(args?: SelectSubset<T, JoinRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JoinRequests and returns the data saved in the database.
     * @param {JoinRequestCreateManyAndReturnArgs} args - Arguments to create many JoinRequests.
     * @example
     * // Create many JoinRequests
     * const joinRequest = await prisma.joinRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JoinRequests and only return the `id`
     * const joinRequestWithIdOnly = await prisma.joinRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JoinRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, JoinRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JoinRequest.
     * @param {JoinRequestDeleteArgs} args - Arguments to delete one JoinRequest.
     * @example
     * // Delete one JoinRequest
     * const JoinRequest = await prisma.joinRequest.delete({
     *   where: {
     *     // ... filter to delete one JoinRequest
     *   }
     * })
     * 
     */
    delete<T extends JoinRequestDeleteArgs>(args: SelectSubset<T, JoinRequestDeleteArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JoinRequest.
     * @param {JoinRequestUpdateArgs} args - Arguments to update one JoinRequest.
     * @example
     * // Update one JoinRequest
     * const joinRequest = await prisma.joinRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JoinRequestUpdateArgs>(args: SelectSubset<T, JoinRequestUpdateArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JoinRequests.
     * @param {JoinRequestDeleteManyArgs} args - Arguments to filter JoinRequests to delete.
     * @example
     * // Delete a few JoinRequests
     * const { count } = await prisma.joinRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JoinRequestDeleteManyArgs>(args?: SelectSubset<T, JoinRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JoinRequests
     * const joinRequest = await prisma.joinRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JoinRequestUpdateManyArgs>(args: SelectSubset<T, JoinRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinRequests and returns the data updated in the database.
     * @param {JoinRequestUpdateManyAndReturnArgs} args - Arguments to update many JoinRequests.
     * @example
     * // Update many JoinRequests
     * const joinRequest = await prisma.joinRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JoinRequests and only return the `id`
     * const joinRequestWithIdOnly = await prisma.joinRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JoinRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, JoinRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JoinRequest.
     * @param {JoinRequestUpsertArgs} args - Arguments to update or create a JoinRequest.
     * @example
     * // Update or create a JoinRequest
     * const joinRequest = await prisma.joinRequest.upsert({
     *   create: {
     *     // ... data to create a JoinRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JoinRequest we want to update
     *   }
     * })
     */
    upsert<T extends JoinRequestUpsertArgs>(args: SelectSubset<T, JoinRequestUpsertArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestCountArgs} args - Arguments to filter JoinRequests to count.
     * @example
     * // Count the number of JoinRequests
     * const count = await prisma.joinRequest.count({
     *   where: {
     *     // ... the filter for the JoinRequests we want to count
     *   }
     * })
    **/
    count<T extends JoinRequestCountArgs>(
      args?: Subset<T, JoinRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JoinRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JoinRequestAggregateArgs>(args: Subset<T, JoinRequestAggregateArgs>): Prisma.PrismaPromise<GetJoinRequestAggregateType<T>>

    /**
     * Group by JoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JoinRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JoinRequestGroupByArgs['orderBy'] }
        : { orderBy?: JoinRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JoinRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJoinRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JoinRequest model
   */
  readonly fields: JoinRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JoinRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JoinRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JoinRequest model
   */
  interface JoinRequestFieldRefs {
    readonly id: FieldRef<"JoinRequest", 'String'>
    readonly groupId: FieldRef<"JoinRequest", 'String'>
    readonly userId: FieldRef<"JoinRequest", 'String'>
    readonly status: FieldRef<"JoinRequest", 'String'>
    readonly createdAt: FieldRef<"JoinRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JoinRequest findUnique
   */
  export type JoinRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest findUniqueOrThrow
   */
  export type JoinRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest findFirst
   */
  export type JoinRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinRequests.
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinRequests.
     */
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * JoinRequest findFirstOrThrow
   */
  export type JoinRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinRequests.
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinRequests.
     */
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * JoinRequest findMany
   */
  export type JoinRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequests to fetch.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JoinRequests.
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * JoinRequest create
   */
  export type JoinRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a JoinRequest.
     */
    data: XOR<JoinRequestCreateInput, JoinRequestUncheckedCreateInput>
  }

  /**
   * JoinRequest createMany
   */
  export type JoinRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JoinRequests.
     */
    data: JoinRequestCreateManyInput | JoinRequestCreateManyInput[]
  }

  /**
   * JoinRequest createManyAndReturn
   */
  export type JoinRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * The data used to create many JoinRequests.
     */
    data: JoinRequestCreateManyInput | JoinRequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinRequest update
   */
  export type JoinRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a JoinRequest.
     */
    data: XOR<JoinRequestUpdateInput, JoinRequestUncheckedUpdateInput>
    /**
     * Choose, which JoinRequest to update.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest updateMany
   */
  export type JoinRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JoinRequests.
     */
    data: XOR<JoinRequestUpdateManyMutationInput, JoinRequestUncheckedUpdateManyInput>
    /**
     * Filter which JoinRequests to update
     */
    where?: JoinRequestWhereInput
    /**
     * Limit how many JoinRequests to update.
     */
    limit?: number
  }

  /**
   * JoinRequest updateManyAndReturn
   */
  export type JoinRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * The data used to update JoinRequests.
     */
    data: XOR<JoinRequestUpdateManyMutationInput, JoinRequestUncheckedUpdateManyInput>
    /**
     * Filter which JoinRequests to update
     */
    where?: JoinRequestWhereInput
    /**
     * Limit how many JoinRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinRequest upsert
   */
  export type JoinRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the JoinRequest to update in case it exists.
     */
    where: JoinRequestWhereUniqueInput
    /**
     * In case the JoinRequest found by the `where` argument doesn't exist, create a new JoinRequest with this data.
     */
    create: XOR<JoinRequestCreateInput, JoinRequestUncheckedCreateInput>
    /**
     * In case the JoinRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JoinRequestUpdateInput, JoinRequestUncheckedUpdateInput>
  }

  /**
   * JoinRequest delete
   */
  export type JoinRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter which JoinRequest to delete.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest deleteMany
   */
  export type JoinRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinRequests to delete
     */
    where?: JoinRequestWhereInput
    /**
     * Limit how many JoinRequests to delete.
     */
    limit?: number
  }

  /**
   * JoinRequest without action
   */
  export type JoinRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
  }


  /**
   * Model GroupInvite
   */

  export type AggregateGroupInvite = {
    _count: GroupInviteCountAggregateOutputType | null
    _min: GroupInviteMinAggregateOutputType | null
    _max: GroupInviteMaxAggregateOutputType | null
  }

  export type GroupInviteMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    createdByUserId: string | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type GroupInviteMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    createdByUserId: string | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type GroupInviteCountAggregateOutputType = {
    id: number
    groupId: number
    createdByUserId: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type GroupInviteMinAggregateInputType = {
    id?: true
    groupId?: true
    createdByUserId?: true
    createdAt?: true
    revokedAt?: true
  }

  export type GroupInviteMaxAggregateInputType = {
    id?: true
    groupId?: true
    createdByUserId?: true
    createdAt?: true
    revokedAt?: true
  }

  export type GroupInviteCountAggregateInputType = {
    id?: true
    groupId?: true
    createdByUserId?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type GroupInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupInvite to aggregate.
     */
    where?: GroupInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupInvites to fetch.
     */
    orderBy?: GroupInviteOrderByWithRelationInput | GroupInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupInvites
    **/
    _count?: true | GroupInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupInviteMaxAggregateInputType
  }

  export type GetGroupInviteAggregateType<T extends GroupInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupInvite[P]>
      : GetScalarType<T[P], AggregateGroupInvite[P]>
  }




  export type GroupInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupInviteWhereInput
    orderBy?: GroupInviteOrderByWithAggregationInput | GroupInviteOrderByWithAggregationInput[]
    by: GroupInviteScalarFieldEnum[] | GroupInviteScalarFieldEnum
    having?: GroupInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupInviteCountAggregateInputType | true
    _min?: GroupInviteMinAggregateInputType
    _max?: GroupInviteMaxAggregateInputType
  }

  export type GroupInviteGroupByOutputType = {
    id: string
    groupId: string
    createdByUserId: string
    createdAt: Date
    revokedAt: Date | null
    _count: GroupInviteCountAggregateOutputType | null
    _min: GroupInviteMinAggregateOutputType | null
    _max: GroupInviteMaxAggregateOutputType | null
  }

  type GetGroupInviteGroupByPayload<T extends GroupInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupInviteGroupByOutputType[P]>
            : GetScalarType<T[P], GroupInviteGroupByOutputType[P]>
        }
      >
    >


  export type GroupInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupInvite"]>

  export type GroupInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupInvite"]>

  export type GroupInviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupInvite"]>

  export type GroupInviteSelectScalar = {
    id?: boolean
    groupId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type GroupInviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "createdByUserId" | "createdAt" | "revokedAt", ExtArgs["result"]["groupInvite"]>
  export type GroupInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupInviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $GroupInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupInvite"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      createdByUserId: string
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["groupInvite"]>
    composites: {}
  }

  type GroupInviteGetPayload<S extends boolean | null | undefined | GroupInviteDefaultArgs> = $Result.GetResult<Prisma.$GroupInvitePayload, S>

  type GroupInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupInviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupInviteCountAggregateInputType | true
    }

  export interface GroupInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupInvite'], meta: { name: 'GroupInvite' } }
    /**
     * Find zero or one GroupInvite that matches the filter.
     * @param {GroupInviteFindUniqueArgs} args - Arguments to find a GroupInvite
     * @example
     * // Get one GroupInvite
     * const groupInvite = await prisma.groupInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupInviteFindUniqueArgs>(args: SelectSubset<T, GroupInviteFindUniqueArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupInvite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupInviteFindUniqueOrThrowArgs} args - Arguments to find a GroupInvite
     * @example
     * // Get one GroupInvite
     * const groupInvite = await prisma.groupInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupInviteFindFirstArgs} args - Arguments to find a GroupInvite
     * @example
     * // Get one GroupInvite
     * const groupInvite = await prisma.groupInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupInviteFindFirstArgs>(args?: SelectSubset<T, GroupInviteFindFirstArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupInviteFindFirstOrThrowArgs} args - Arguments to find a GroupInvite
     * @example
     * // Get one GroupInvite
     * const groupInvite = await prisma.groupInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupInvites
     * const groupInvites = await prisma.groupInvite.findMany()
     * 
     * // Get first 10 GroupInvites
     * const groupInvites = await prisma.groupInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupInviteWithIdOnly = await prisma.groupInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupInviteFindManyArgs>(args?: SelectSubset<T, GroupInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupInvite.
     * @param {GroupInviteCreateArgs} args - Arguments to create a GroupInvite.
     * @example
     * // Create one GroupInvite
     * const GroupInvite = await prisma.groupInvite.create({
     *   data: {
     *     // ... data to create a GroupInvite
     *   }
     * })
     * 
     */
    create<T extends GroupInviteCreateArgs>(args: SelectSubset<T, GroupInviteCreateArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupInvites.
     * @param {GroupInviteCreateManyArgs} args - Arguments to create many GroupInvites.
     * @example
     * // Create many GroupInvites
     * const groupInvite = await prisma.groupInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupInviteCreateManyArgs>(args?: SelectSubset<T, GroupInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupInvites and returns the data saved in the database.
     * @param {GroupInviteCreateManyAndReturnArgs} args - Arguments to create many GroupInvites.
     * @example
     * // Create many GroupInvites
     * const groupInvite = await prisma.groupInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupInvites and only return the `id`
     * const groupInviteWithIdOnly = await prisma.groupInvite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupInvite.
     * @param {GroupInviteDeleteArgs} args - Arguments to delete one GroupInvite.
     * @example
     * // Delete one GroupInvite
     * const GroupInvite = await prisma.groupInvite.delete({
     *   where: {
     *     // ... filter to delete one GroupInvite
     *   }
     * })
     * 
     */
    delete<T extends GroupInviteDeleteArgs>(args: SelectSubset<T, GroupInviteDeleteArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupInvite.
     * @param {GroupInviteUpdateArgs} args - Arguments to update one GroupInvite.
     * @example
     * // Update one GroupInvite
     * const groupInvite = await prisma.groupInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupInviteUpdateArgs>(args: SelectSubset<T, GroupInviteUpdateArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupInvites.
     * @param {GroupInviteDeleteManyArgs} args - Arguments to filter GroupInvites to delete.
     * @example
     * // Delete a few GroupInvites
     * const { count } = await prisma.groupInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupInviteDeleteManyArgs>(args?: SelectSubset<T, GroupInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupInvites
     * const groupInvite = await prisma.groupInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupInviteUpdateManyArgs>(args: SelectSubset<T, GroupInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupInvites and returns the data updated in the database.
     * @param {GroupInviteUpdateManyAndReturnArgs} args - Arguments to update many GroupInvites.
     * @example
     * // Update many GroupInvites
     * const groupInvite = await prisma.groupInvite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupInvites and only return the `id`
     * const groupInviteWithIdOnly = await prisma.groupInvite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupInviteUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupInviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupInvite.
     * @param {GroupInviteUpsertArgs} args - Arguments to update or create a GroupInvite.
     * @example
     * // Update or create a GroupInvite
     * const groupInvite = await prisma.groupInvite.upsert({
     *   create: {
     *     // ... data to create a GroupInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupInvite we want to update
     *   }
     * })
     */
    upsert<T extends GroupInviteUpsertArgs>(args: SelectSubset<T, GroupInviteUpsertArgs<ExtArgs>>): Prisma__GroupInviteClient<$Result.GetResult<Prisma.$GroupInvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupInviteCountArgs} args - Arguments to filter GroupInvites to count.
     * @example
     * // Count the number of GroupInvites
     * const count = await prisma.groupInvite.count({
     *   where: {
     *     // ... the filter for the GroupInvites we want to count
     *   }
     * })
    **/
    count<T extends GroupInviteCountArgs>(
      args?: Subset<T, GroupInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupInviteAggregateArgs>(args: Subset<T, GroupInviteAggregateArgs>): Prisma.PrismaPromise<GetGroupInviteAggregateType<T>>

    /**
     * Group by GroupInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupInviteGroupByArgs['orderBy'] }
        : { orderBy?: GroupInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupInvite model
   */
  readonly fields: GroupInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupInvite model
   */
  interface GroupInviteFieldRefs {
    readonly id: FieldRef<"GroupInvite", 'String'>
    readonly groupId: FieldRef<"GroupInvite", 'String'>
    readonly createdByUserId: FieldRef<"GroupInvite", 'String'>
    readonly createdAt: FieldRef<"GroupInvite", 'DateTime'>
    readonly revokedAt: FieldRef<"GroupInvite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupInvite findUnique
   */
  export type GroupInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * Filter, which GroupInvite to fetch.
     */
    where: GroupInviteWhereUniqueInput
  }

  /**
   * GroupInvite findUniqueOrThrow
   */
  export type GroupInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * Filter, which GroupInvite to fetch.
     */
    where: GroupInviteWhereUniqueInput
  }

  /**
   * GroupInvite findFirst
   */
  export type GroupInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * Filter, which GroupInvite to fetch.
     */
    where?: GroupInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupInvites to fetch.
     */
    orderBy?: GroupInviteOrderByWithRelationInput | GroupInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupInvites.
     */
    cursor?: GroupInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupInvites.
     */
    distinct?: GroupInviteScalarFieldEnum | GroupInviteScalarFieldEnum[]
  }

  /**
   * GroupInvite findFirstOrThrow
   */
  export type GroupInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * Filter, which GroupInvite to fetch.
     */
    where?: GroupInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupInvites to fetch.
     */
    orderBy?: GroupInviteOrderByWithRelationInput | GroupInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupInvites.
     */
    cursor?: GroupInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupInvites.
     */
    distinct?: GroupInviteScalarFieldEnum | GroupInviteScalarFieldEnum[]
  }

  /**
   * GroupInvite findMany
   */
  export type GroupInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * Filter, which GroupInvites to fetch.
     */
    where?: GroupInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupInvites to fetch.
     */
    orderBy?: GroupInviteOrderByWithRelationInput | GroupInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupInvites.
     */
    cursor?: GroupInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupInvites.
     */
    skip?: number
    distinct?: GroupInviteScalarFieldEnum | GroupInviteScalarFieldEnum[]
  }

  /**
   * GroupInvite create
   */
  export type GroupInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupInvite.
     */
    data: XOR<GroupInviteCreateInput, GroupInviteUncheckedCreateInput>
  }

  /**
   * GroupInvite createMany
   */
  export type GroupInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupInvites.
     */
    data: GroupInviteCreateManyInput | GroupInviteCreateManyInput[]
  }

  /**
   * GroupInvite createManyAndReturn
   */
  export type GroupInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * The data used to create many GroupInvites.
     */
    data: GroupInviteCreateManyInput | GroupInviteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupInvite update
   */
  export type GroupInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupInvite.
     */
    data: XOR<GroupInviteUpdateInput, GroupInviteUncheckedUpdateInput>
    /**
     * Choose, which GroupInvite to update.
     */
    where: GroupInviteWhereUniqueInput
  }

  /**
   * GroupInvite updateMany
   */
  export type GroupInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupInvites.
     */
    data: XOR<GroupInviteUpdateManyMutationInput, GroupInviteUncheckedUpdateManyInput>
    /**
     * Filter which GroupInvites to update
     */
    where?: GroupInviteWhereInput
    /**
     * Limit how many GroupInvites to update.
     */
    limit?: number
  }

  /**
   * GroupInvite updateManyAndReturn
   */
  export type GroupInviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * The data used to update GroupInvites.
     */
    data: XOR<GroupInviteUpdateManyMutationInput, GroupInviteUncheckedUpdateManyInput>
    /**
     * Filter which GroupInvites to update
     */
    where?: GroupInviteWhereInput
    /**
     * Limit how many GroupInvites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupInvite upsert
   */
  export type GroupInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupInvite to update in case it exists.
     */
    where: GroupInviteWhereUniqueInput
    /**
     * In case the GroupInvite found by the `where` argument doesn't exist, create a new GroupInvite with this data.
     */
    create: XOR<GroupInviteCreateInput, GroupInviteUncheckedCreateInput>
    /**
     * In case the GroupInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupInviteUpdateInput, GroupInviteUncheckedUpdateInput>
  }

  /**
   * GroupInvite delete
   */
  export type GroupInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
    /**
     * Filter which GroupInvite to delete.
     */
    where: GroupInviteWhereUniqueInput
  }

  /**
   * GroupInvite deleteMany
   */
  export type GroupInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupInvites to delete
     */
    where?: GroupInviteWhereInput
    /**
     * Limit how many GroupInvites to delete.
     */
    limit?: number
  }

  /**
   * GroupInvite without action
   */
  export type GroupInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupInvite
     */
    select?: GroupInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupInvite
     */
    omit?: GroupInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInviteInclude<ExtArgs> | null
  }


  /**
   * Model GroupBookOfMonthSelection
   */

  export type AggregateGroupBookOfMonthSelection = {
    _count: GroupBookOfMonthSelectionCountAggregateOutputType | null
    _min: GroupBookOfMonthSelectionMinAggregateOutputType | null
    _max: GroupBookOfMonthSelectionMaxAggregateOutputType | null
  }

  export type GroupBookOfMonthSelectionMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    bookId: string | null
    setByUserId: string | null
    setAt: Date | null
  }

  export type GroupBookOfMonthSelectionMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    bookId: string | null
    setByUserId: string | null
    setAt: Date | null
  }

  export type GroupBookOfMonthSelectionCountAggregateOutputType = {
    id: number
    groupId: number
    bookId: number
    setByUserId: number
    setAt: number
    _all: number
  }


  export type GroupBookOfMonthSelectionMinAggregateInputType = {
    id?: true
    groupId?: true
    bookId?: true
    setByUserId?: true
    setAt?: true
  }

  export type GroupBookOfMonthSelectionMaxAggregateInputType = {
    id?: true
    groupId?: true
    bookId?: true
    setByUserId?: true
    setAt?: true
  }

  export type GroupBookOfMonthSelectionCountAggregateInputType = {
    id?: true
    groupId?: true
    bookId?: true
    setByUserId?: true
    setAt?: true
    _all?: true
  }

  export type GroupBookOfMonthSelectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupBookOfMonthSelection to aggregate.
     */
    where?: GroupBookOfMonthSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookOfMonthSelections to fetch.
     */
    orderBy?: GroupBookOfMonthSelectionOrderByWithRelationInput | GroupBookOfMonthSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupBookOfMonthSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookOfMonthSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookOfMonthSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupBookOfMonthSelections
    **/
    _count?: true | GroupBookOfMonthSelectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupBookOfMonthSelectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupBookOfMonthSelectionMaxAggregateInputType
  }

  export type GetGroupBookOfMonthSelectionAggregateType<T extends GroupBookOfMonthSelectionAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupBookOfMonthSelection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupBookOfMonthSelection[P]>
      : GetScalarType<T[P], AggregateGroupBookOfMonthSelection[P]>
  }




  export type GroupBookOfMonthSelectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupBookOfMonthSelectionWhereInput
    orderBy?: GroupBookOfMonthSelectionOrderByWithAggregationInput | GroupBookOfMonthSelectionOrderByWithAggregationInput[]
    by: GroupBookOfMonthSelectionScalarFieldEnum[] | GroupBookOfMonthSelectionScalarFieldEnum
    having?: GroupBookOfMonthSelectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupBookOfMonthSelectionCountAggregateInputType | true
    _min?: GroupBookOfMonthSelectionMinAggregateInputType
    _max?: GroupBookOfMonthSelectionMaxAggregateInputType
  }

  export type GroupBookOfMonthSelectionGroupByOutputType = {
    id: string
    groupId: string
    bookId: string
    setByUserId: string
    setAt: Date
    _count: GroupBookOfMonthSelectionCountAggregateOutputType | null
    _min: GroupBookOfMonthSelectionMinAggregateOutputType | null
    _max: GroupBookOfMonthSelectionMaxAggregateOutputType | null
  }

  type GetGroupBookOfMonthSelectionGroupByPayload<T extends GroupBookOfMonthSelectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupBookOfMonthSelectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupBookOfMonthSelectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupBookOfMonthSelectionGroupByOutputType[P]>
            : GetScalarType<T[P], GroupBookOfMonthSelectionGroupByOutputType[P]>
        }
      >
    >


  export type GroupBookOfMonthSelectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    bookId?: boolean
    setByUserId?: boolean
    setAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupBookOfMonthSelection"]>

  export type GroupBookOfMonthSelectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    bookId?: boolean
    setByUserId?: boolean
    setAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupBookOfMonthSelection"]>

  export type GroupBookOfMonthSelectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    bookId?: boolean
    setByUserId?: boolean
    setAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupBookOfMonthSelection"]>

  export type GroupBookOfMonthSelectionSelectScalar = {
    id?: boolean
    groupId?: boolean
    bookId?: boolean
    setByUserId?: boolean
    setAt?: boolean
  }

  export type GroupBookOfMonthSelectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "bookId" | "setByUserId" | "setAt", ExtArgs["result"]["groupBookOfMonthSelection"]>
  export type GroupBookOfMonthSelectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupBookOfMonthSelectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupBookOfMonthSelectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $GroupBookOfMonthSelectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupBookOfMonthSelection"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      bookId: string
      setByUserId: string
      setAt: Date
    }, ExtArgs["result"]["groupBookOfMonthSelection"]>
    composites: {}
  }

  type GroupBookOfMonthSelectionGetPayload<S extends boolean | null | undefined | GroupBookOfMonthSelectionDefaultArgs> = $Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload, S>

  type GroupBookOfMonthSelectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupBookOfMonthSelectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupBookOfMonthSelectionCountAggregateInputType | true
    }

  export interface GroupBookOfMonthSelectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupBookOfMonthSelection'], meta: { name: 'GroupBookOfMonthSelection' } }
    /**
     * Find zero or one GroupBookOfMonthSelection that matches the filter.
     * @param {GroupBookOfMonthSelectionFindUniqueArgs} args - Arguments to find a GroupBookOfMonthSelection
     * @example
     * // Get one GroupBookOfMonthSelection
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupBookOfMonthSelectionFindUniqueArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionFindUniqueArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupBookOfMonthSelection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupBookOfMonthSelectionFindUniqueOrThrowArgs} args - Arguments to find a GroupBookOfMonthSelection
     * @example
     * // Get one GroupBookOfMonthSelection
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupBookOfMonthSelectionFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupBookOfMonthSelection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookOfMonthSelectionFindFirstArgs} args - Arguments to find a GroupBookOfMonthSelection
     * @example
     * // Get one GroupBookOfMonthSelection
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupBookOfMonthSelectionFindFirstArgs>(args?: SelectSubset<T, GroupBookOfMonthSelectionFindFirstArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupBookOfMonthSelection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookOfMonthSelectionFindFirstOrThrowArgs} args - Arguments to find a GroupBookOfMonthSelection
     * @example
     * // Get one GroupBookOfMonthSelection
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupBookOfMonthSelectionFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupBookOfMonthSelectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupBookOfMonthSelections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookOfMonthSelectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupBookOfMonthSelections
     * const groupBookOfMonthSelections = await prisma.groupBookOfMonthSelection.findMany()
     * 
     * // Get first 10 GroupBookOfMonthSelections
     * const groupBookOfMonthSelections = await prisma.groupBookOfMonthSelection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupBookOfMonthSelectionWithIdOnly = await prisma.groupBookOfMonthSelection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupBookOfMonthSelectionFindManyArgs>(args?: SelectSubset<T, GroupBookOfMonthSelectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupBookOfMonthSelection.
     * @param {GroupBookOfMonthSelectionCreateArgs} args - Arguments to create a GroupBookOfMonthSelection.
     * @example
     * // Create one GroupBookOfMonthSelection
     * const GroupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.create({
     *   data: {
     *     // ... data to create a GroupBookOfMonthSelection
     *   }
     * })
     * 
     */
    create<T extends GroupBookOfMonthSelectionCreateArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionCreateArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupBookOfMonthSelections.
     * @param {GroupBookOfMonthSelectionCreateManyArgs} args - Arguments to create many GroupBookOfMonthSelections.
     * @example
     * // Create many GroupBookOfMonthSelections
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupBookOfMonthSelectionCreateManyArgs>(args?: SelectSubset<T, GroupBookOfMonthSelectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupBookOfMonthSelections and returns the data saved in the database.
     * @param {GroupBookOfMonthSelectionCreateManyAndReturnArgs} args - Arguments to create many GroupBookOfMonthSelections.
     * @example
     * // Create many GroupBookOfMonthSelections
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupBookOfMonthSelections and only return the `id`
     * const groupBookOfMonthSelectionWithIdOnly = await prisma.groupBookOfMonthSelection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupBookOfMonthSelectionCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupBookOfMonthSelectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupBookOfMonthSelection.
     * @param {GroupBookOfMonthSelectionDeleteArgs} args - Arguments to delete one GroupBookOfMonthSelection.
     * @example
     * // Delete one GroupBookOfMonthSelection
     * const GroupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.delete({
     *   where: {
     *     // ... filter to delete one GroupBookOfMonthSelection
     *   }
     * })
     * 
     */
    delete<T extends GroupBookOfMonthSelectionDeleteArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionDeleteArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupBookOfMonthSelection.
     * @param {GroupBookOfMonthSelectionUpdateArgs} args - Arguments to update one GroupBookOfMonthSelection.
     * @example
     * // Update one GroupBookOfMonthSelection
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupBookOfMonthSelectionUpdateArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionUpdateArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupBookOfMonthSelections.
     * @param {GroupBookOfMonthSelectionDeleteManyArgs} args - Arguments to filter GroupBookOfMonthSelections to delete.
     * @example
     * // Delete a few GroupBookOfMonthSelections
     * const { count } = await prisma.groupBookOfMonthSelection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupBookOfMonthSelectionDeleteManyArgs>(args?: SelectSubset<T, GroupBookOfMonthSelectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupBookOfMonthSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookOfMonthSelectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupBookOfMonthSelections
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupBookOfMonthSelectionUpdateManyArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupBookOfMonthSelections and returns the data updated in the database.
     * @param {GroupBookOfMonthSelectionUpdateManyAndReturnArgs} args - Arguments to update many GroupBookOfMonthSelections.
     * @example
     * // Update many GroupBookOfMonthSelections
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupBookOfMonthSelections and only return the `id`
     * const groupBookOfMonthSelectionWithIdOnly = await prisma.groupBookOfMonthSelection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupBookOfMonthSelectionUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupBookOfMonthSelection.
     * @param {GroupBookOfMonthSelectionUpsertArgs} args - Arguments to update or create a GroupBookOfMonthSelection.
     * @example
     * // Update or create a GroupBookOfMonthSelection
     * const groupBookOfMonthSelection = await prisma.groupBookOfMonthSelection.upsert({
     *   create: {
     *     // ... data to create a GroupBookOfMonthSelection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupBookOfMonthSelection we want to update
     *   }
     * })
     */
    upsert<T extends GroupBookOfMonthSelectionUpsertArgs>(args: SelectSubset<T, GroupBookOfMonthSelectionUpsertArgs<ExtArgs>>): Prisma__GroupBookOfMonthSelectionClient<$Result.GetResult<Prisma.$GroupBookOfMonthSelectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupBookOfMonthSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookOfMonthSelectionCountArgs} args - Arguments to filter GroupBookOfMonthSelections to count.
     * @example
     * // Count the number of GroupBookOfMonthSelections
     * const count = await prisma.groupBookOfMonthSelection.count({
     *   where: {
     *     // ... the filter for the GroupBookOfMonthSelections we want to count
     *   }
     * })
    **/
    count<T extends GroupBookOfMonthSelectionCountArgs>(
      args?: Subset<T, GroupBookOfMonthSelectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupBookOfMonthSelectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupBookOfMonthSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookOfMonthSelectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupBookOfMonthSelectionAggregateArgs>(args: Subset<T, GroupBookOfMonthSelectionAggregateArgs>): Prisma.PrismaPromise<GetGroupBookOfMonthSelectionAggregateType<T>>

    /**
     * Group by GroupBookOfMonthSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookOfMonthSelectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupBookOfMonthSelectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupBookOfMonthSelectionGroupByArgs['orderBy'] }
        : { orderBy?: GroupBookOfMonthSelectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupBookOfMonthSelectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupBookOfMonthSelectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupBookOfMonthSelection model
   */
  readonly fields: GroupBookOfMonthSelectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupBookOfMonthSelection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupBookOfMonthSelectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupBookOfMonthSelection model
   */
  interface GroupBookOfMonthSelectionFieldRefs {
    readonly id: FieldRef<"GroupBookOfMonthSelection", 'String'>
    readonly groupId: FieldRef<"GroupBookOfMonthSelection", 'String'>
    readonly bookId: FieldRef<"GroupBookOfMonthSelection", 'String'>
    readonly setByUserId: FieldRef<"GroupBookOfMonthSelection", 'String'>
    readonly setAt: FieldRef<"GroupBookOfMonthSelection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupBookOfMonthSelection findUnique
   */
  export type GroupBookOfMonthSelectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookOfMonthSelection to fetch.
     */
    where: GroupBookOfMonthSelectionWhereUniqueInput
  }

  /**
   * GroupBookOfMonthSelection findUniqueOrThrow
   */
  export type GroupBookOfMonthSelectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookOfMonthSelection to fetch.
     */
    where: GroupBookOfMonthSelectionWhereUniqueInput
  }

  /**
   * GroupBookOfMonthSelection findFirst
   */
  export type GroupBookOfMonthSelectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookOfMonthSelection to fetch.
     */
    where?: GroupBookOfMonthSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookOfMonthSelections to fetch.
     */
    orderBy?: GroupBookOfMonthSelectionOrderByWithRelationInput | GroupBookOfMonthSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupBookOfMonthSelections.
     */
    cursor?: GroupBookOfMonthSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookOfMonthSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookOfMonthSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupBookOfMonthSelections.
     */
    distinct?: GroupBookOfMonthSelectionScalarFieldEnum | GroupBookOfMonthSelectionScalarFieldEnum[]
  }

  /**
   * GroupBookOfMonthSelection findFirstOrThrow
   */
  export type GroupBookOfMonthSelectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookOfMonthSelection to fetch.
     */
    where?: GroupBookOfMonthSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookOfMonthSelections to fetch.
     */
    orderBy?: GroupBookOfMonthSelectionOrderByWithRelationInput | GroupBookOfMonthSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupBookOfMonthSelections.
     */
    cursor?: GroupBookOfMonthSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookOfMonthSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookOfMonthSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupBookOfMonthSelections.
     */
    distinct?: GroupBookOfMonthSelectionScalarFieldEnum | GroupBookOfMonthSelectionScalarFieldEnum[]
  }

  /**
   * GroupBookOfMonthSelection findMany
   */
  export type GroupBookOfMonthSelectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookOfMonthSelections to fetch.
     */
    where?: GroupBookOfMonthSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookOfMonthSelections to fetch.
     */
    orderBy?: GroupBookOfMonthSelectionOrderByWithRelationInput | GroupBookOfMonthSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupBookOfMonthSelections.
     */
    cursor?: GroupBookOfMonthSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookOfMonthSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookOfMonthSelections.
     */
    skip?: number
    distinct?: GroupBookOfMonthSelectionScalarFieldEnum | GroupBookOfMonthSelectionScalarFieldEnum[]
  }

  /**
   * GroupBookOfMonthSelection create
   */
  export type GroupBookOfMonthSelectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupBookOfMonthSelection.
     */
    data: XOR<GroupBookOfMonthSelectionCreateInput, GroupBookOfMonthSelectionUncheckedCreateInput>
  }

  /**
   * GroupBookOfMonthSelection createMany
   */
  export type GroupBookOfMonthSelectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupBookOfMonthSelections.
     */
    data: GroupBookOfMonthSelectionCreateManyInput | GroupBookOfMonthSelectionCreateManyInput[]
  }

  /**
   * GroupBookOfMonthSelection createManyAndReturn
   */
  export type GroupBookOfMonthSelectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * The data used to create many GroupBookOfMonthSelections.
     */
    data: GroupBookOfMonthSelectionCreateManyInput | GroupBookOfMonthSelectionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupBookOfMonthSelection update
   */
  export type GroupBookOfMonthSelectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupBookOfMonthSelection.
     */
    data: XOR<GroupBookOfMonthSelectionUpdateInput, GroupBookOfMonthSelectionUncheckedUpdateInput>
    /**
     * Choose, which GroupBookOfMonthSelection to update.
     */
    where: GroupBookOfMonthSelectionWhereUniqueInput
  }

  /**
   * GroupBookOfMonthSelection updateMany
   */
  export type GroupBookOfMonthSelectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupBookOfMonthSelections.
     */
    data: XOR<GroupBookOfMonthSelectionUpdateManyMutationInput, GroupBookOfMonthSelectionUncheckedUpdateManyInput>
    /**
     * Filter which GroupBookOfMonthSelections to update
     */
    where?: GroupBookOfMonthSelectionWhereInput
    /**
     * Limit how many GroupBookOfMonthSelections to update.
     */
    limit?: number
  }

  /**
   * GroupBookOfMonthSelection updateManyAndReturn
   */
  export type GroupBookOfMonthSelectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * The data used to update GroupBookOfMonthSelections.
     */
    data: XOR<GroupBookOfMonthSelectionUpdateManyMutationInput, GroupBookOfMonthSelectionUncheckedUpdateManyInput>
    /**
     * Filter which GroupBookOfMonthSelections to update
     */
    where?: GroupBookOfMonthSelectionWhereInput
    /**
     * Limit how many GroupBookOfMonthSelections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupBookOfMonthSelection upsert
   */
  export type GroupBookOfMonthSelectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupBookOfMonthSelection to update in case it exists.
     */
    where: GroupBookOfMonthSelectionWhereUniqueInput
    /**
     * In case the GroupBookOfMonthSelection found by the `where` argument doesn't exist, create a new GroupBookOfMonthSelection with this data.
     */
    create: XOR<GroupBookOfMonthSelectionCreateInput, GroupBookOfMonthSelectionUncheckedCreateInput>
    /**
     * In case the GroupBookOfMonthSelection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupBookOfMonthSelectionUpdateInput, GroupBookOfMonthSelectionUncheckedUpdateInput>
  }

  /**
   * GroupBookOfMonthSelection delete
   */
  export type GroupBookOfMonthSelectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
    /**
     * Filter which GroupBookOfMonthSelection to delete.
     */
    where: GroupBookOfMonthSelectionWhereUniqueInput
  }

  /**
   * GroupBookOfMonthSelection deleteMany
   */
  export type GroupBookOfMonthSelectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupBookOfMonthSelections to delete
     */
    where?: GroupBookOfMonthSelectionWhereInput
    /**
     * Limit how many GroupBookOfMonthSelections to delete.
     */
    limit?: number
  }

  /**
   * GroupBookOfMonthSelection without action
   */
  export type GroupBookOfMonthSelectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookOfMonthSelection
     */
    select?: GroupBookOfMonthSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupBookOfMonthSelection
     */
    omit?: GroupBookOfMonthSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookOfMonthSelectionInclude<ExtArgs> | null
  }


  /**
   * Model ClubBook
   */

  export type AggregateClubBook = {
    _count: ClubBookCountAggregateOutputType | null
    _avg: ClubBookAvgAggregateOutputType | null
    _sum: ClubBookSumAggregateOutputType | null
    _min: ClubBookMinAggregateOutputType | null
    _max: ClubBookMaxAggregateOutputType | null
  }

  export type ClubBookAvgAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type ClubBookSumAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type ClubBookMinAggregateOutputType = {
    id: string | null
    bookId: string | null
    title: string | null
    author: string | null
    coverUrl: string | null
    colorKey: string | null
    city: string | null
    month: number | null
    year: number | null
    isActive: boolean | null
    createdByUserId: string | null
    indicationComment: string | null
    createdAt: Date | null
    activatedAt: Date | null
  }

  export type ClubBookMaxAggregateOutputType = {
    id: string | null
    bookId: string | null
    title: string | null
    author: string | null
    coverUrl: string | null
    colorKey: string | null
    city: string | null
    month: number | null
    year: number | null
    isActive: boolean | null
    createdByUserId: string | null
    indicationComment: string | null
    createdAt: Date | null
    activatedAt: Date | null
  }

  export type ClubBookCountAggregateOutputType = {
    id: number
    bookId: number
    title: number
    author: number
    coverUrl: number
    colorKey: number
    city: number
    month: number
    year: number
    isActive: number
    createdByUserId: number
    indicationComment: number
    createdAt: number
    activatedAt: number
    _all: number
  }


  export type ClubBookAvgAggregateInputType = {
    month?: true
    year?: true
  }

  export type ClubBookSumAggregateInputType = {
    month?: true
    year?: true
  }

  export type ClubBookMinAggregateInputType = {
    id?: true
    bookId?: true
    title?: true
    author?: true
    coverUrl?: true
    colorKey?: true
    city?: true
    month?: true
    year?: true
    isActive?: true
    createdByUserId?: true
    indicationComment?: true
    createdAt?: true
    activatedAt?: true
  }

  export type ClubBookMaxAggregateInputType = {
    id?: true
    bookId?: true
    title?: true
    author?: true
    coverUrl?: true
    colorKey?: true
    city?: true
    month?: true
    year?: true
    isActive?: true
    createdByUserId?: true
    indicationComment?: true
    createdAt?: true
    activatedAt?: true
  }

  export type ClubBookCountAggregateInputType = {
    id?: true
    bookId?: true
    title?: true
    author?: true
    coverUrl?: true
    colorKey?: true
    city?: true
    month?: true
    year?: true
    isActive?: true
    createdByUserId?: true
    indicationComment?: true
    createdAt?: true
    activatedAt?: true
    _all?: true
  }

  export type ClubBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubBook to aggregate.
     */
    where?: ClubBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBooks to fetch.
     */
    orderBy?: ClubBookOrderByWithRelationInput | ClubBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubBooks
    **/
    _count?: true | ClubBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClubBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClubBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubBookMaxAggregateInputType
  }

  export type GetClubBookAggregateType<T extends ClubBookAggregateArgs> = {
        [P in keyof T & keyof AggregateClubBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubBook[P]>
      : GetScalarType<T[P], AggregateClubBook[P]>
  }




  export type ClubBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubBookWhereInput
    orderBy?: ClubBookOrderByWithAggregationInput | ClubBookOrderByWithAggregationInput[]
    by: ClubBookScalarFieldEnum[] | ClubBookScalarFieldEnum
    having?: ClubBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubBookCountAggregateInputType | true
    _avg?: ClubBookAvgAggregateInputType
    _sum?: ClubBookSumAggregateInputType
    _min?: ClubBookMinAggregateInputType
    _max?: ClubBookMaxAggregateInputType
  }

  export type ClubBookGroupByOutputType = {
    id: string
    bookId: string
    title: string
    author: string
    coverUrl: string
    colorKey: string
    city: string
    month: number
    year: number
    isActive: boolean
    createdByUserId: string
    indicationComment: string
    createdAt: Date
    activatedAt: Date | null
    _count: ClubBookCountAggregateOutputType | null
    _avg: ClubBookAvgAggregateOutputType | null
    _sum: ClubBookSumAggregateOutputType | null
    _min: ClubBookMinAggregateOutputType | null
    _max: ClubBookMaxAggregateOutputType | null
  }

  type GetClubBookGroupByPayload<T extends ClubBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubBookGroupByOutputType[P]>
            : GetScalarType<T[P], ClubBookGroupByOutputType[P]>
        }
      >
    >


  export type ClubBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    colorKey?: boolean
    city?: boolean
    month?: boolean
    year?: boolean
    isActive?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
    activatedAt?: boolean
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
    messages?: boolean | ClubBook$messagesArgs<ExtArgs>
    artifacts?: boolean | ClubBook$artifactsArgs<ExtArgs>
    events?: boolean | ClubBook$eventsArgs<ExtArgs>
    _count?: boolean | ClubBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBook"]>

  export type ClubBookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    colorKey?: boolean
    city?: boolean
    month?: boolean
    year?: boolean
    isActive?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
    activatedAt?: boolean
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBook"]>

  export type ClubBookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    colorKey?: boolean
    city?: boolean
    month?: boolean
    year?: boolean
    isActive?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
    activatedAt?: boolean
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBook"]>

  export type ClubBookSelectScalar = {
    id?: boolean
    bookId?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    colorKey?: boolean
    city?: boolean
    month?: boolean
    year?: boolean
    isActive?: boolean
    createdByUserId?: boolean
    indicationComment?: boolean
    createdAt?: boolean
    activatedAt?: boolean
  }

  export type ClubBookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookId" | "title" | "author" | "coverUrl" | "colorKey" | "city" | "month" | "year" | "isActive" | "createdByUserId" | "indicationComment" | "createdAt" | "activatedAt", ExtArgs["result"]["clubBook"]>
  export type ClubBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
    messages?: boolean | ClubBook$messagesArgs<ExtArgs>
    artifacts?: boolean | ClubBook$artifactsArgs<ExtArgs>
    events?: boolean | ClubBook$eventsArgs<ExtArgs>
    _count?: boolean | ClubBookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClubBookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
  }
  export type ClubBookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
  }

  export type $ClubBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubBook"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs>
      book: Prisma.$BookPayload<ExtArgs>
      messages: Prisma.$ClubBookMessagePayload<ExtArgs>[]
      artifacts: Prisma.$ClubBookArtifactPayload<ExtArgs>[]
      events: Prisma.$ClubEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookId: string
      title: string
      author: string
      coverUrl: string
      colorKey: string
      city: string
      month: number
      year: number
      isActive: boolean
      createdByUserId: string
      indicationComment: string
      createdAt: Date
      activatedAt: Date | null
    }, ExtArgs["result"]["clubBook"]>
    composites: {}
  }

  type ClubBookGetPayload<S extends boolean | null | undefined | ClubBookDefaultArgs> = $Result.GetResult<Prisma.$ClubBookPayload, S>

  type ClubBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubBookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubBookCountAggregateInputType | true
    }

  export interface ClubBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubBook'], meta: { name: 'ClubBook' } }
    /**
     * Find zero or one ClubBook that matches the filter.
     * @param {ClubBookFindUniqueArgs} args - Arguments to find a ClubBook
     * @example
     * // Get one ClubBook
     * const clubBook = await prisma.clubBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubBookFindUniqueArgs>(args: SelectSubset<T, ClubBookFindUniqueArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubBook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubBookFindUniqueOrThrowArgs} args - Arguments to find a ClubBook
     * @example
     * // Get one ClubBook
     * const clubBook = await prisma.clubBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubBookFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookFindFirstArgs} args - Arguments to find a ClubBook
     * @example
     * // Get one ClubBook
     * const clubBook = await prisma.clubBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubBookFindFirstArgs>(args?: SelectSubset<T, ClubBookFindFirstArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookFindFirstOrThrowArgs} args - Arguments to find a ClubBook
     * @example
     * // Get one ClubBook
     * const clubBook = await prisma.clubBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubBookFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubBooks
     * const clubBooks = await prisma.clubBook.findMany()
     * 
     * // Get first 10 ClubBooks
     * const clubBooks = await prisma.clubBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubBookWithIdOnly = await prisma.clubBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubBookFindManyArgs>(args?: SelectSubset<T, ClubBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubBook.
     * @param {ClubBookCreateArgs} args - Arguments to create a ClubBook.
     * @example
     * // Create one ClubBook
     * const ClubBook = await prisma.clubBook.create({
     *   data: {
     *     // ... data to create a ClubBook
     *   }
     * })
     * 
     */
    create<T extends ClubBookCreateArgs>(args: SelectSubset<T, ClubBookCreateArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubBooks.
     * @param {ClubBookCreateManyArgs} args - Arguments to create many ClubBooks.
     * @example
     * // Create many ClubBooks
     * const clubBook = await prisma.clubBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubBookCreateManyArgs>(args?: SelectSubset<T, ClubBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubBooks and returns the data saved in the database.
     * @param {ClubBookCreateManyAndReturnArgs} args - Arguments to create many ClubBooks.
     * @example
     * // Create many ClubBooks
     * const clubBook = await prisma.clubBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubBooks and only return the `id`
     * const clubBookWithIdOnly = await prisma.clubBook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubBookCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubBookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubBook.
     * @param {ClubBookDeleteArgs} args - Arguments to delete one ClubBook.
     * @example
     * // Delete one ClubBook
     * const ClubBook = await prisma.clubBook.delete({
     *   where: {
     *     // ... filter to delete one ClubBook
     *   }
     * })
     * 
     */
    delete<T extends ClubBookDeleteArgs>(args: SelectSubset<T, ClubBookDeleteArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubBook.
     * @param {ClubBookUpdateArgs} args - Arguments to update one ClubBook.
     * @example
     * // Update one ClubBook
     * const clubBook = await prisma.clubBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubBookUpdateArgs>(args: SelectSubset<T, ClubBookUpdateArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubBooks.
     * @param {ClubBookDeleteManyArgs} args - Arguments to filter ClubBooks to delete.
     * @example
     * // Delete a few ClubBooks
     * const { count } = await prisma.clubBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubBookDeleteManyArgs>(args?: SelectSubset<T, ClubBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubBooks
     * const clubBook = await prisma.clubBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubBookUpdateManyArgs>(args: SelectSubset<T, ClubBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubBooks and returns the data updated in the database.
     * @param {ClubBookUpdateManyAndReturnArgs} args - Arguments to update many ClubBooks.
     * @example
     * // Update many ClubBooks
     * const clubBook = await prisma.clubBook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubBooks and only return the `id`
     * const clubBookWithIdOnly = await prisma.clubBook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubBookUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubBookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubBook.
     * @param {ClubBookUpsertArgs} args - Arguments to update or create a ClubBook.
     * @example
     * // Update or create a ClubBook
     * const clubBook = await prisma.clubBook.upsert({
     *   create: {
     *     // ... data to create a ClubBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubBook we want to update
     *   }
     * })
     */
    upsert<T extends ClubBookUpsertArgs>(args: SelectSubset<T, ClubBookUpsertArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookCountArgs} args - Arguments to filter ClubBooks to count.
     * @example
     * // Count the number of ClubBooks
     * const count = await prisma.clubBook.count({
     *   where: {
     *     // ... the filter for the ClubBooks we want to count
     *   }
     * })
    **/
    count<T extends ClubBookCountArgs>(
      args?: Subset<T, ClubBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubBookAggregateArgs>(args: Subset<T, ClubBookAggregateArgs>): Prisma.PrismaPromise<GetClubBookAggregateType<T>>

    /**
     * Group by ClubBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubBookGroupByArgs['orderBy'] }
        : { orderBy?: ClubBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubBook model
   */
  readonly fields: ClubBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookDefaultArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ClubBook$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ClubBook$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artifacts<T extends ClubBook$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, ClubBook$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends ClubBook$eventsArgs<ExtArgs> = {}>(args?: Subset<T, ClubBook$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubBook model
   */
  interface ClubBookFieldRefs {
    readonly id: FieldRef<"ClubBook", 'String'>
    readonly bookId: FieldRef<"ClubBook", 'String'>
    readonly title: FieldRef<"ClubBook", 'String'>
    readonly author: FieldRef<"ClubBook", 'String'>
    readonly coverUrl: FieldRef<"ClubBook", 'String'>
    readonly colorKey: FieldRef<"ClubBook", 'String'>
    readonly city: FieldRef<"ClubBook", 'String'>
    readonly month: FieldRef<"ClubBook", 'Int'>
    readonly year: FieldRef<"ClubBook", 'Int'>
    readonly isActive: FieldRef<"ClubBook", 'Boolean'>
    readonly createdByUserId: FieldRef<"ClubBook", 'String'>
    readonly indicationComment: FieldRef<"ClubBook", 'String'>
    readonly createdAt: FieldRef<"ClubBook", 'DateTime'>
    readonly activatedAt: FieldRef<"ClubBook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubBook findUnique
   */
  export type ClubBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * Filter, which ClubBook to fetch.
     */
    where: ClubBookWhereUniqueInput
  }

  /**
   * ClubBook findUniqueOrThrow
   */
  export type ClubBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * Filter, which ClubBook to fetch.
     */
    where: ClubBookWhereUniqueInput
  }

  /**
   * ClubBook findFirst
   */
  export type ClubBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * Filter, which ClubBook to fetch.
     */
    where?: ClubBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBooks to fetch.
     */
    orderBy?: ClubBookOrderByWithRelationInput | ClubBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubBooks.
     */
    cursor?: ClubBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubBooks.
     */
    distinct?: ClubBookScalarFieldEnum | ClubBookScalarFieldEnum[]
  }

  /**
   * ClubBook findFirstOrThrow
   */
  export type ClubBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * Filter, which ClubBook to fetch.
     */
    where?: ClubBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBooks to fetch.
     */
    orderBy?: ClubBookOrderByWithRelationInput | ClubBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubBooks.
     */
    cursor?: ClubBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubBooks.
     */
    distinct?: ClubBookScalarFieldEnum | ClubBookScalarFieldEnum[]
  }

  /**
   * ClubBook findMany
   */
  export type ClubBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * Filter, which ClubBooks to fetch.
     */
    where?: ClubBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBooks to fetch.
     */
    orderBy?: ClubBookOrderByWithRelationInput | ClubBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubBooks.
     */
    cursor?: ClubBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBooks.
     */
    skip?: number
    distinct?: ClubBookScalarFieldEnum | ClubBookScalarFieldEnum[]
  }

  /**
   * ClubBook create
   */
  export type ClubBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubBook.
     */
    data: XOR<ClubBookCreateInput, ClubBookUncheckedCreateInput>
  }

  /**
   * ClubBook createMany
   */
  export type ClubBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubBooks.
     */
    data: ClubBookCreateManyInput | ClubBookCreateManyInput[]
  }

  /**
   * ClubBook createManyAndReturn
   */
  export type ClubBookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * The data used to create many ClubBooks.
     */
    data: ClubBookCreateManyInput | ClubBookCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubBook update
   */
  export type ClubBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubBook.
     */
    data: XOR<ClubBookUpdateInput, ClubBookUncheckedUpdateInput>
    /**
     * Choose, which ClubBook to update.
     */
    where: ClubBookWhereUniqueInput
  }

  /**
   * ClubBook updateMany
   */
  export type ClubBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubBooks.
     */
    data: XOR<ClubBookUpdateManyMutationInput, ClubBookUncheckedUpdateManyInput>
    /**
     * Filter which ClubBooks to update
     */
    where?: ClubBookWhereInput
    /**
     * Limit how many ClubBooks to update.
     */
    limit?: number
  }

  /**
   * ClubBook updateManyAndReturn
   */
  export type ClubBookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * The data used to update ClubBooks.
     */
    data: XOR<ClubBookUpdateManyMutationInput, ClubBookUncheckedUpdateManyInput>
    /**
     * Filter which ClubBooks to update
     */
    where?: ClubBookWhereInput
    /**
     * Limit how many ClubBooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubBook upsert
   */
  export type ClubBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubBook to update in case it exists.
     */
    where: ClubBookWhereUniqueInput
    /**
     * In case the ClubBook found by the `where` argument doesn't exist, create a new ClubBook with this data.
     */
    create: XOR<ClubBookCreateInput, ClubBookUncheckedCreateInput>
    /**
     * In case the ClubBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubBookUpdateInput, ClubBookUncheckedUpdateInput>
  }

  /**
   * ClubBook delete
   */
  export type ClubBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    /**
     * Filter which ClubBook to delete.
     */
    where: ClubBookWhereUniqueInput
  }

  /**
   * ClubBook deleteMany
   */
  export type ClubBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubBooks to delete
     */
    where?: ClubBookWhereInput
    /**
     * Limit how many ClubBooks to delete.
     */
    limit?: number
  }

  /**
   * ClubBook.messages
   */
  export type ClubBook$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    where?: ClubBookMessageWhereInput
    orderBy?: ClubBookMessageOrderByWithRelationInput | ClubBookMessageOrderByWithRelationInput[]
    cursor?: ClubBookMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubBookMessageScalarFieldEnum | ClubBookMessageScalarFieldEnum[]
  }

  /**
   * ClubBook.artifacts
   */
  export type ClubBook$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    where?: ClubBookArtifactWhereInput
    orderBy?: ClubBookArtifactOrderByWithRelationInput | ClubBookArtifactOrderByWithRelationInput[]
    cursor?: ClubBookArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubBookArtifactScalarFieldEnum | ClubBookArtifactScalarFieldEnum[]
  }

  /**
   * ClubBook.events
   */
  export type ClubBook$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    where?: ClubEventWhereInput
    orderBy?: ClubEventOrderByWithRelationInput | ClubEventOrderByWithRelationInput[]
    cursor?: ClubEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubEventScalarFieldEnum | ClubEventScalarFieldEnum[]
  }

  /**
   * ClubBook without action
   */
  export type ClubBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
  }


  /**
   * Model ClubBookMessage
   */

  export type AggregateClubBookMessage = {
    _count: ClubBookMessageCountAggregateOutputType | null
    _min: ClubBookMessageMinAggregateOutputType | null
    _max: ClubBookMessageMaxAggregateOutputType | null
  }

  export type ClubBookMessageMinAggregateOutputType = {
    id: string | null
    clubBookId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type ClubBookMessageMaxAggregateOutputType = {
    id: string | null
    clubBookId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type ClubBookMessageCountAggregateOutputType = {
    id: number
    clubBookId: number
    userId: number
    text: number
    createdAt: number
    _all: number
  }


  export type ClubBookMessageMinAggregateInputType = {
    id?: true
    clubBookId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type ClubBookMessageMaxAggregateInputType = {
    id?: true
    clubBookId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type ClubBookMessageCountAggregateInputType = {
    id?: true
    clubBookId?: true
    userId?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type ClubBookMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubBookMessage to aggregate.
     */
    where?: ClubBookMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookMessages to fetch.
     */
    orderBy?: ClubBookMessageOrderByWithRelationInput | ClubBookMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubBookMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubBookMessages
    **/
    _count?: true | ClubBookMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubBookMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubBookMessageMaxAggregateInputType
  }

  export type GetClubBookMessageAggregateType<T extends ClubBookMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateClubBookMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubBookMessage[P]>
      : GetScalarType<T[P], AggregateClubBookMessage[P]>
  }




  export type ClubBookMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubBookMessageWhereInput
    orderBy?: ClubBookMessageOrderByWithAggregationInput | ClubBookMessageOrderByWithAggregationInput[]
    by: ClubBookMessageScalarFieldEnum[] | ClubBookMessageScalarFieldEnum
    having?: ClubBookMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubBookMessageCountAggregateInputType | true
    _min?: ClubBookMessageMinAggregateInputType
    _max?: ClubBookMessageMaxAggregateInputType
  }

  export type ClubBookMessageGroupByOutputType = {
    id: string
    clubBookId: string
    userId: string
    text: string
    createdAt: Date
    _count: ClubBookMessageCountAggregateOutputType | null
    _min: ClubBookMessageMinAggregateOutputType | null
    _max: ClubBookMessageMaxAggregateOutputType | null
  }

  type GetClubBookMessageGroupByPayload<T extends ClubBookMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubBookMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubBookMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubBookMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ClubBookMessageGroupByOutputType[P]>
        }
      >
    >


  export type ClubBookMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBookMessage"]>

  export type ClubBookMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBookMessage"]>

  export type ClubBookMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBookMessage"]>

  export type ClubBookMessageSelectScalar = {
    id?: boolean
    clubBookId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type ClubBookMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clubBookId" | "userId" | "text" | "createdAt", ExtArgs["result"]["clubBookMessage"]>
  export type ClubBookMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }
  export type ClubBookMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }
  export type ClubBookMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }

  export type $ClubBookMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubBookMessage"
    objects: {
      clubBook: Prisma.$ClubBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clubBookId: string
      userId: string
      text: string
      createdAt: Date
    }, ExtArgs["result"]["clubBookMessage"]>
    composites: {}
  }

  type ClubBookMessageGetPayload<S extends boolean | null | undefined | ClubBookMessageDefaultArgs> = $Result.GetResult<Prisma.$ClubBookMessagePayload, S>

  type ClubBookMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubBookMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubBookMessageCountAggregateInputType | true
    }

  export interface ClubBookMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubBookMessage'], meta: { name: 'ClubBookMessage' } }
    /**
     * Find zero or one ClubBookMessage that matches the filter.
     * @param {ClubBookMessageFindUniqueArgs} args - Arguments to find a ClubBookMessage
     * @example
     * // Get one ClubBookMessage
     * const clubBookMessage = await prisma.clubBookMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubBookMessageFindUniqueArgs>(args: SelectSubset<T, ClubBookMessageFindUniqueArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubBookMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubBookMessageFindUniqueOrThrowArgs} args - Arguments to find a ClubBookMessage
     * @example
     * // Get one ClubBookMessage
     * const clubBookMessage = await prisma.clubBookMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubBookMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubBookMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubBookMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookMessageFindFirstArgs} args - Arguments to find a ClubBookMessage
     * @example
     * // Get one ClubBookMessage
     * const clubBookMessage = await prisma.clubBookMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubBookMessageFindFirstArgs>(args?: SelectSubset<T, ClubBookMessageFindFirstArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubBookMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookMessageFindFirstOrThrowArgs} args - Arguments to find a ClubBookMessage
     * @example
     * // Get one ClubBookMessage
     * const clubBookMessage = await prisma.clubBookMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubBookMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubBookMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubBookMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubBookMessages
     * const clubBookMessages = await prisma.clubBookMessage.findMany()
     * 
     * // Get first 10 ClubBookMessages
     * const clubBookMessages = await prisma.clubBookMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubBookMessageWithIdOnly = await prisma.clubBookMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubBookMessageFindManyArgs>(args?: SelectSubset<T, ClubBookMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubBookMessage.
     * @param {ClubBookMessageCreateArgs} args - Arguments to create a ClubBookMessage.
     * @example
     * // Create one ClubBookMessage
     * const ClubBookMessage = await prisma.clubBookMessage.create({
     *   data: {
     *     // ... data to create a ClubBookMessage
     *   }
     * })
     * 
     */
    create<T extends ClubBookMessageCreateArgs>(args: SelectSubset<T, ClubBookMessageCreateArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubBookMessages.
     * @param {ClubBookMessageCreateManyArgs} args - Arguments to create many ClubBookMessages.
     * @example
     * // Create many ClubBookMessages
     * const clubBookMessage = await prisma.clubBookMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubBookMessageCreateManyArgs>(args?: SelectSubset<T, ClubBookMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubBookMessages and returns the data saved in the database.
     * @param {ClubBookMessageCreateManyAndReturnArgs} args - Arguments to create many ClubBookMessages.
     * @example
     * // Create many ClubBookMessages
     * const clubBookMessage = await prisma.clubBookMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubBookMessages and only return the `id`
     * const clubBookMessageWithIdOnly = await prisma.clubBookMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubBookMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubBookMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubBookMessage.
     * @param {ClubBookMessageDeleteArgs} args - Arguments to delete one ClubBookMessage.
     * @example
     * // Delete one ClubBookMessage
     * const ClubBookMessage = await prisma.clubBookMessage.delete({
     *   where: {
     *     // ... filter to delete one ClubBookMessage
     *   }
     * })
     * 
     */
    delete<T extends ClubBookMessageDeleteArgs>(args: SelectSubset<T, ClubBookMessageDeleteArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubBookMessage.
     * @param {ClubBookMessageUpdateArgs} args - Arguments to update one ClubBookMessage.
     * @example
     * // Update one ClubBookMessage
     * const clubBookMessage = await prisma.clubBookMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubBookMessageUpdateArgs>(args: SelectSubset<T, ClubBookMessageUpdateArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubBookMessages.
     * @param {ClubBookMessageDeleteManyArgs} args - Arguments to filter ClubBookMessages to delete.
     * @example
     * // Delete a few ClubBookMessages
     * const { count } = await prisma.clubBookMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubBookMessageDeleteManyArgs>(args?: SelectSubset<T, ClubBookMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubBookMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubBookMessages
     * const clubBookMessage = await prisma.clubBookMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubBookMessageUpdateManyArgs>(args: SelectSubset<T, ClubBookMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubBookMessages and returns the data updated in the database.
     * @param {ClubBookMessageUpdateManyAndReturnArgs} args - Arguments to update many ClubBookMessages.
     * @example
     * // Update many ClubBookMessages
     * const clubBookMessage = await prisma.clubBookMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubBookMessages and only return the `id`
     * const clubBookMessageWithIdOnly = await prisma.clubBookMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubBookMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubBookMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubBookMessage.
     * @param {ClubBookMessageUpsertArgs} args - Arguments to update or create a ClubBookMessage.
     * @example
     * // Update or create a ClubBookMessage
     * const clubBookMessage = await prisma.clubBookMessage.upsert({
     *   create: {
     *     // ... data to create a ClubBookMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubBookMessage we want to update
     *   }
     * })
     */
    upsert<T extends ClubBookMessageUpsertArgs>(args: SelectSubset<T, ClubBookMessageUpsertArgs<ExtArgs>>): Prisma__ClubBookMessageClient<$Result.GetResult<Prisma.$ClubBookMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubBookMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookMessageCountArgs} args - Arguments to filter ClubBookMessages to count.
     * @example
     * // Count the number of ClubBookMessages
     * const count = await prisma.clubBookMessage.count({
     *   where: {
     *     // ... the filter for the ClubBookMessages we want to count
     *   }
     * })
    **/
    count<T extends ClubBookMessageCountArgs>(
      args?: Subset<T, ClubBookMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubBookMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubBookMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubBookMessageAggregateArgs>(args: Subset<T, ClubBookMessageAggregateArgs>): Prisma.PrismaPromise<GetClubBookMessageAggregateType<T>>

    /**
     * Group by ClubBookMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubBookMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubBookMessageGroupByArgs['orderBy'] }
        : { orderBy?: ClubBookMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubBookMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubBookMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubBookMessage model
   */
  readonly fields: ClubBookMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubBookMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubBookMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clubBook<T extends ClubBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubBookDefaultArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubBookMessage model
   */
  interface ClubBookMessageFieldRefs {
    readonly id: FieldRef<"ClubBookMessage", 'String'>
    readonly clubBookId: FieldRef<"ClubBookMessage", 'String'>
    readonly userId: FieldRef<"ClubBookMessage", 'String'>
    readonly text: FieldRef<"ClubBookMessage", 'String'>
    readonly createdAt: FieldRef<"ClubBookMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubBookMessage findUnique
   */
  export type ClubBookMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookMessage to fetch.
     */
    where: ClubBookMessageWhereUniqueInput
  }

  /**
   * ClubBookMessage findUniqueOrThrow
   */
  export type ClubBookMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookMessage to fetch.
     */
    where: ClubBookMessageWhereUniqueInput
  }

  /**
   * ClubBookMessage findFirst
   */
  export type ClubBookMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookMessage to fetch.
     */
    where?: ClubBookMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookMessages to fetch.
     */
    orderBy?: ClubBookMessageOrderByWithRelationInput | ClubBookMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubBookMessages.
     */
    cursor?: ClubBookMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubBookMessages.
     */
    distinct?: ClubBookMessageScalarFieldEnum | ClubBookMessageScalarFieldEnum[]
  }

  /**
   * ClubBookMessage findFirstOrThrow
   */
  export type ClubBookMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookMessage to fetch.
     */
    where?: ClubBookMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookMessages to fetch.
     */
    orderBy?: ClubBookMessageOrderByWithRelationInput | ClubBookMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubBookMessages.
     */
    cursor?: ClubBookMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubBookMessages.
     */
    distinct?: ClubBookMessageScalarFieldEnum | ClubBookMessageScalarFieldEnum[]
  }

  /**
   * ClubBookMessage findMany
   */
  export type ClubBookMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookMessages to fetch.
     */
    where?: ClubBookMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookMessages to fetch.
     */
    orderBy?: ClubBookMessageOrderByWithRelationInput | ClubBookMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubBookMessages.
     */
    cursor?: ClubBookMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookMessages.
     */
    skip?: number
    distinct?: ClubBookMessageScalarFieldEnum | ClubBookMessageScalarFieldEnum[]
  }

  /**
   * ClubBookMessage create
   */
  export type ClubBookMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubBookMessage.
     */
    data: XOR<ClubBookMessageCreateInput, ClubBookMessageUncheckedCreateInput>
  }

  /**
   * ClubBookMessage createMany
   */
  export type ClubBookMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubBookMessages.
     */
    data: ClubBookMessageCreateManyInput | ClubBookMessageCreateManyInput[]
  }

  /**
   * ClubBookMessage createManyAndReturn
   */
  export type ClubBookMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ClubBookMessages.
     */
    data: ClubBookMessageCreateManyInput | ClubBookMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubBookMessage update
   */
  export type ClubBookMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubBookMessage.
     */
    data: XOR<ClubBookMessageUpdateInput, ClubBookMessageUncheckedUpdateInput>
    /**
     * Choose, which ClubBookMessage to update.
     */
    where: ClubBookMessageWhereUniqueInput
  }

  /**
   * ClubBookMessage updateMany
   */
  export type ClubBookMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubBookMessages.
     */
    data: XOR<ClubBookMessageUpdateManyMutationInput, ClubBookMessageUncheckedUpdateManyInput>
    /**
     * Filter which ClubBookMessages to update
     */
    where?: ClubBookMessageWhereInput
    /**
     * Limit how many ClubBookMessages to update.
     */
    limit?: number
  }

  /**
   * ClubBookMessage updateManyAndReturn
   */
  export type ClubBookMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * The data used to update ClubBookMessages.
     */
    data: XOR<ClubBookMessageUpdateManyMutationInput, ClubBookMessageUncheckedUpdateManyInput>
    /**
     * Filter which ClubBookMessages to update
     */
    where?: ClubBookMessageWhereInput
    /**
     * Limit how many ClubBookMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubBookMessage upsert
   */
  export type ClubBookMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubBookMessage to update in case it exists.
     */
    where: ClubBookMessageWhereUniqueInput
    /**
     * In case the ClubBookMessage found by the `where` argument doesn't exist, create a new ClubBookMessage with this data.
     */
    create: XOR<ClubBookMessageCreateInput, ClubBookMessageUncheckedCreateInput>
    /**
     * In case the ClubBookMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubBookMessageUpdateInput, ClubBookMessageUncheckedUpdateInput>
  }

  /**
   * ClubBookMessage delete
   */
  export type ClubBookMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
    /**
     * Filter which ClubBookMessage to delete.
     */
    where: ClubBookMessageWhereUniqueInput
  }

  /**
   * ClubBookMessage deleteMany
   */
  export type ClubBookMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubBookMessages to delete
     */
    where?: ClubBookMessageWhereInput
    /**
     * Limit how many ClubBookMessages to delete.
     */
    limit?: number
  }

  /**
   * ClubBookMessage without action
   */
  export type ClubBookMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookMessage
     */
    select?: ClubBookMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookMessage
     */
    omit?: ClubBookMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookMessageInclude<ExtArgs> | null
  }


  /**
   * Model ClubBookArtifact
   */

  export type AggregateClubBookArtifact = {
    _count: ClubBookArtifactCountAggregateOutputType | null
    _avg: ClubBookArtifactAvgAggregateOutputType | null
    _sum: ClubBookArtifactSumAggregateOutputType | null
    _min: ClubBookArtifactMinAggregateOutputType | null
    _max: ClubBookArtifactMaxAggregateOutputType | null
  }

  export type ClubBookArtifactAvgAggregateOutputType = {
    size: number | null
  }

  export type ClubBookArtifactSumAggregateOutputType = {
    size: number | null
  }

  export type ClubBookArtifactMinAggregateOutputType = {
    id: string | null
    clubBookId: string | null
    fileName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedByUserId: string | null
    createdAt: Date | null
  }

  export type ClubBookArtifactMaxAggregateOutputType = {
    id: string | null
    clubBookId: string | null
    fileName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedByUserId: string | null
    createdAt: Date | null
  }

  export type ClubBookArtifactCountAggregateOutputType = {
    id: number
    clubBookId: number
    fileName: number
    mimeType: number
    size: number
    url: number
    uploadedByUserId: number
    createdAt: number
    _all: number
  }


  export type ClubBookArtifactAvgAggregateInputType = {
    size?: true
  }

  export type ClubBookArtifactSumAggregateInputType = {
    size?: true
  }

  export type ClubBookArtifactMinAggregateInputType = {
    id?: true
    clubBookId?: true
    fileName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedByUserId?: true
    createdAt?: true
  }

  export type ClubBookArtifactMaxAggregateInputType = {
    id?: true
    clubBookId?: true
    fileName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedByUserId?: true
    createdAt?: true
  }

  export type ClubBookArtifactCountAggregateInputType = {
    id?: true
    clubBookId?: true
    fileName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type ClubBookArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubBookArtifact to aggregate.
     */
    where?: ClubBookArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookArtifacts to fetch.
     */
    orderBy?: ClubBookArtifactOrderByWithRelationInput | ClubBookArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubBookArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubBookArtifacts
    **/
    _count?: true | ClubBookArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClubBookArtifactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClubBookArtifactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubBookArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubBookArtifactMaxAggregateInputType
  }

  export type GetClubBookArtifactAggregateType<T extends ClubBookArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateClubBookArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubBookArtifact[P]>
      : GetScalarType<T[P], AggregateClubBookArtifact[P]>
  }




  export type ClubBookArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubBookArtifactWhereInput
    orderBy?: ClubBookArtifactOrderByWithAggregationInput | ClubBookArtifactOrderByWithAggregationInput[]
    by: ClubBookArtifactScalarFieldEnum[] | ClubBookArtifactScalarFieldEnum
    having?: ClubBookArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubBookArtifactCountAggregateInputType | true
    _avg?: ClubBookArtifactAvgAggregateInputType
    _sum?: ClubBookArtifactSumAggregateInputType
    _min?: ClubBookArtifactMinAggregateInputType
    _max?: ClubBookArtifactMaxAggregateInputType
  }

  export type ClubBookArtifactGroupByOutputType = {
    id: string
    clubBookId: string
    fileName: string
    mimeType: string
    size: number
    url: string
    uploadedByUserId: string
    createdAt: Date
    _count: ClubBookArtifactCountAggregateOutputType | null
    _avg: ClubBookArtifactAvgAggregateOutputType | null
    _sum: ClubBookArtifactSumAggregateOutputType | null
    _min: ClubBookArtifactMinAggregateOutputType | null
    _max: ClubBookArtifactMaxAggregateOutputType | null
  }

  type GetClubBookArtifactGroupByPayload<T extends ClubBookArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubBookArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubBookArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubBookArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ClubBookArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ClubBookArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedByUserId?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBookArtifact"]>

  export type ClubBookArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedByUserId?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBookArtifact"]>

  export type ClubBookArtifactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedByUserId?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubBookArtifact"]>

  export type ClubBookArtifactSelectScalar = {
    id?: boolean
    clubBookId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedByUserId?: boolean
    createdAt?: boolean
  }

  export type ClubBookArtifactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clubBookId" | "fileName" | "mimeType" | "size" | "url" | "uploadedByUserId" | "createdAt", ExtArgs["result"]["clubBookArtifact"]>
  export type ClubBookArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }
  export type ClubBookArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }
  export type ClubBookArtifactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubBookDefaultArgs<ExtArgs>
  }

  export type $ClubBookArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubBookArtifact"
    objects: {
      clubBook: Prisma.$ClubBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clubBookId: string
      fileName: string
      mimeType: string
      size: number
      url: string
      uploadedByUserId: string
      createdAt: Date
    }, ExtArgs["result"]["clubBookArtifact"]>
    composites: {}
  }

  type ClubBookArtifactGetPayload<S extends boolean | null | undefined | ClubBookArtifactDefaultArgs> = $Result.GetResult<Prisma.$ClubBookArtifactPayload, S>

  type ClubBookArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubBookArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubBookArtifactCountAggregateInputType | true
    }

  export interface ClubBookArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubBookArtifact'], meta: { name: 'ClubBookArtifact' } }
    /**
     * Find zero or one ClubBookArtifact that matches the filter.
     * @param {ClubBookArtifactFindUniqueArgs} args - Arguments to find a ClubBookArtifact
     * @example
     * // Get one ClubBookArtifact
     * const clubBookArtifact = await prisma.clubBookArtifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubBookArtifactFindUniqueArgs>(args: SelectSubset<T, ClubBookArtifactFindUniqueArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubBookArtifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubBookArtifactFindUniqueOrThrowArgs} args - Arguments to find a ClubBookArtifact
     * @example
     * // Get one ClubBookArtifact
     * const clubBookArtifact = await prisma.clubBookArtifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubBookArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubBookArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubBookArtifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookArtifactFindFirstArgs} args - Arguments to find a ClubBookArtifact
     * @example
     * // Get one ClubBookArtifact
     * const clubBookArtifact = await prisma.clubBookArtifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubBookArtifactFindFirstArgs>(args?: SelectSubset<T, ClubBookArtifactFindFirstArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubBookArtifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookArtifactFindFirstOrThrowArgs} args - Arguments to find a ClubBookArtifact
     * @example
     * // Get one ClubBookArtifact
     * const clubBookArtifact = await prisma.clubBookArtifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubBookArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubBookArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubBookArtifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubBookArtifacts
     * const clubBookArtifacts = await prisma.clubBookArtifact.findMany()
     * 
     * // Get first 10 ClubBookArtifacts
     * const clubBookArtifacts = await prisma.clubBookArtifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubBookArtifactWithIdOnly = await prisma.clubBookArtifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubBookArtifactFindManyArgs>(args?: SelectSubset<T, ClubBookArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubBookArtifact.
     * @param {ClubBookArtifactCreateArgs} args - Arguments to create a ClubBookArtifact.
     * @example
     * // Create one ClubBookArtifact
     * const ClubBookArtifact = await prisma.clubBookArtifact.create({
     *   data: {
     *     // ... data to create a ClubBookArtifact
     *   }
     * })
     * 
     */
    create<T extends ClubBookArtifactCreateArgs>(args: SelectSubset<T, ClubBookArtifactCreateArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubBookArtifacts.
     * @param {ClubBookArtifactCreateManyArgs} args - Arguments to create many ClubBookArtifacts.
     * @example
     * // Create many ClubBookArtifacts
     * const clubBookArtifact = await prisma.clubBookArtifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubBookArtifactCreateManyArgs>(args?: SelectSubset<T, ClubBookArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubBookArtifacts and returns the data saved in the database.
     * @param {ClubBookArtifactCreateManyAndReturnArgs} args - Arguments to create many ClubBookArtifacts.
     * @example
     * // Create many ClubBookArtifacts
     * const clubBookArtifact = await prisma.clubBookArtifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubBookArtifacts and only return the `id`
     * const clubBookArtifactWithIdOnly = await prisma.clubBookArtifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubBookArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubBookArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubBookArtifact.
     * @param {ClubBookArtifactDeleteArgs} args - Arguments to delete one ClubBookArtifact.
     * @example
     * // Delete one ClubBookArtifact
     * const ClubBookArtifact = await prisma.clubBookArtifact.delete({
     *   where: {
     *     // ... filter to delete one ClubBookArtifact
     *   }
     * })
     * 
     */
    delete<T extends ClubBookArtifactDeleteArgs>(args: SelectSubset<T, ClubBookArtifactDeleteArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubBookArtifact.
     * @param {ClubBookArtifactUpdateArgs} args - Arguments to update one ClubBookArtifact.
     * @example
     * // Update one ClubBookArtifact
     * const clubBookArtifact = await prisma.clubBookArtifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubBookArtifactUpdateArgs>(args: SelectSubset<T, ClubBookArtifactUpdateArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubBookArtifacts.
     * @param {ClubBookArtifactDeleteManyArgs} args - Arguments to filter ClubBookArtifacts to delete.
     * @example
     * // Delete a few ClubBookArtifacts
     * const { count } = await prisma.clubBookArtifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubBookArtifactDeleteManyArgs>(args?: SelectSubset<T, ClubBookArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubBookArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubBookArtifacts
     * const clubBookArtifact = await prisma.clubBookArtifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubBookArtifactUpdateManyArgs>(args: SelectSubset<T, ClubBookArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubBookArtifacts and returns the data updated in the database.
     * @param {ClubBookArtifactUpdateManyAndReturnArgs} args - Arguments to update many ClubBookArtifacts.
     * @example
     * // Update many ClubBookArtifacts
     * const clubBookArtifact = await prisma.clubBookArtifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubBookArtifacts and only return the `id`
     * const clubBookArtifactWithIdOnly = await prisma.clubBookArtifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubBookArtifactUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubBookArtifactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubBookArtifact.
     * @param {ClubBookArtifactUpsertArgs} args - Arguments to update or create a ClubBookArtifact.
     * @example
     * // Update or create a ClubBookArtifact
     * const clubBookArtifact = await prisma.clubBookArtifact.upsert({
     *   create: {
     *     // ... data to create a ClubBookArtifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubBookArtifact we want to update
     *   }
     * })
     */
    upsert<T extends ClubBookArtifactUpsertArgs>(args: SelectSubset<T, ClubBookArtifactUpsertArgs<ExtArgs>>): Prisma__ClubBookArtifactClient<$Result.GetResult<Prisma.$ClubBookArtifactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubBookArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookArtifactCountArgs} args - Arguments to filter ClubBookArtifacts to count.
     * @example
     * // Count the number of ClubBookArtifacts
     * const count = await prisma.clubBookArtifact.count({
     *   where: {
     *     // ... the filter for the ClubBookArtifacts we want to count
     *   }
     * })
    **/
    count<T extends ClubBookArtifactCountArgs>(
      args?: Subset<T, ClubBookArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubBookArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubBookArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubBookArtifactAggregateArgs>(args: Subset<T, ClubBookArtifactAggregateArgs>): Prisma.PrismaPromise<GetClubBookArtifactAggregateType<T>>

    /**
     * Group by ClubBookArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubBookArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubBookArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubBookArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ClubBookArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubBookArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubBookArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubBookArtifact model
   */
  readonly fields: ClubBookArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubBookArtifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubBookArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clubBook<T extends ClubBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubBookDefaultArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubBookArtifact model
   */
  interface ClubBookArtifactFieldRefs {
    readonly id: FieldRef<"ClubBookArtifact", 'String'>
    readonly clubBookId: FieldRef<"ClubBookArtifact", 'String'>
    readonly fileName: FieldRef<"ClubBookArtifact", 'String'>
    readonly mimeType: FieldRef<"ClubBookArtifact", 'String'>
    readonly size: FieldRef<"ClubBookArtifact", 'Int'>
    readonly url: FieldRef<"ClubBookArtifact", 'String'>
    readonly uploadedByUserId: FieldRef<"ClubBookArtifact", 'String'>
    readonly createdAt: FieldRef<"ClubBookArtifact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubBookArtifact findUnique
   */
  export type ClubBookArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookArtifact to fetch.
     */
    where: ClubBookArtifactWhereUniqueInput
  }

  /**
   * ClubBookArtifact findUniqueOrThrow
   */
  export type ClubBookArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookArtifact to fetch.
     */
    where: ClubBookArtifactWhereUniqueInput
  }

  /**
   * ClubBookArtifact findFirst
   */
  export type ClubBookArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookArtifact to fetch.
     */
    where?: ClubBookArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookArtifacts to fetch.
     */
    orderBy?: ClubBookArtifactOrderByWithRelationInput | ClubBookArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubBookArtifacts.
     */
    cursor?: ClubBookArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubBookArtifacts.
     */
    distinct?: ClubBookArtifactScalarFieldEnum | ClubBookArtifactScalarFieldEnum[]
  }

  /**
   * ClubBookArtifact findFirstOrThrow
   */
  export type ClubBookArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookArtifact to fetch.
     */
    where?: ClubBookArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookArtifacts to fetch.
     */
    orderBy?: ClubBookArtifactOrderByWithRelationInput | ClubBookArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubBookArtifacts.
     */
    cursor?: ClubBookArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubBookArtifacts.
     */
    distinct?: ClubBookArtifactScalarFieldEnum | ClubBookArtifactScalarFieldEnum[]
  }

  /**
   * ClubBookArtifact findMany
   */
  export type ClubBookArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ClubBookArtifacts to fetch.
     */
    where?: ClubBookArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubBookArtifacts to fetch.
     */
    orderBy?: ClubBookArtifactOrderByWithRelationInput | ClubBookArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubBookArtifacts.
     */
    cursor?: ClubBookArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubBookArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubBookArtifacts.
     */
    skip?: number
    distinct?: ClubBookArtifactScalarFieldEnum | ClubBookArtifactScalarFieldEnum[]
  }

  /**
   * ClubBookArtifact create
   */
  export type ClubBookArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubBookArtifact.
     */
    data: XOR<ClubBookArtifactCreateInput, ClubBookArtifactUncheckedCreateInput>
  }

  /**
   * ClubBookArtifact createMany
   */
  export type ClubBookArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubBookArtifacts.
     */
    data: ClubBookArtifactCreateManyInput | ClubBookArtifactCreateManyInput[]
  }

  /**
   * ClubBookArtifact createManyAndReturn
   */
  export type ClubBookArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * The data used to create many ClubBookArtifacts.
     */
    data: ClubBookArtifactCreateManyInput | ClubBookArtifactCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubBookArtifact update
   */
  export type ClubBookArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubBookArtifact.
     */
    data: XOR<ClubBookArtifactUpdateInput, ClubBookArtifactUncheckedUpdateInput>
    /**
     * Choose, which ClubBookArtifact to update.
     */
    where: ClubBookArtifactWhereUniqueInput
  }

  /**
   * ClubBookArtifact updateMany
   */
  export type ClubBookArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubBookArtifacts.
     */
    data: XOR<ClubBookArtifactUpdateManyMutationInput, ClubBookArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ClubBookArtifacts to update
     */
    where?: ClubBookArtifactWhereInput
    /**
     * Limit how many ClubBookArtifacts to update.
     */
    limit?: number
  }

  /**
   * ClubBookArtifact updateManyAndReturn
   */
  export type ClubBookArtifactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * The data used to update ClubBookArtifacts.
     */
    data: XOR<ClubBookArtifactUpdateManyMutationInput, ClubBookArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ClubBookArtifacts to update
     */
    where?: ClubBookArtifactWhereInput
    /**
     * Limit how many ClubBookArtifacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubBookArtifact upsert
   */
  export type ClubBookArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubBookArtifact to update in case it exists.
     */
    where: ClubBookArtifactWhereUniqueInput
    /**
     * In case the ClubBookArtifact found by the `where` argument doesn't exist, create a new ClubBookArtifact with this data.
     */
    create: XOR<ClubBookArtifactCreateInput, ClubBookArtifactUncheckedCreateInput>
    /**
     * In case the ClubBookArtifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubBookArtifactUpdateInput, ClubBookArtifactUncheckedUpdateInput>
  }

  /**
   * ClubBookArtifact delete
   */
  export type ClubBookArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
    /**
     * Filter which ClubBookArtifact to delete.
     */
    where: ClubBookArtifactWhereUniqueInput
  }

  /**
   * ClubBookArtifact deleteMany
   */
  export type ClubBookArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubBookArtifacts to delete
     */
    where?: ClubBookArtifactWhereInput
    /**
     * Limit how many ClubBookArtifacts to delete.
     */
    limit?: number
  }

  /**
   * ClubBookArtifact without action
   */
  export type ClubBookArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBookArtifact
     */
    select?: ClubBookArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBookArtifact
     */
    omit?: ClubBookArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookArtifactInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    cityCode: string | null
    createdAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    cityCode: string | null
    createdAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    type: number
    cityCode: number
    createdAt: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cityCode?: true
    createdAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cityCode?: true
    createdAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cityCode?: true
    createdAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    name: string
    type: string
    cityCode: string | null
    createdAt: Date
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    cityCode?: boolean
    createdAt?: boolean
    messages?: boolean | Channel$messagesArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    cityCode?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    cityCode?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    cityCode?: boolean
    createdAt?: boolean
  }

  export type ChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "cityCode" | "createdAt", ExtArgs["result"]["channel"]>
  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Channel$messagesArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      messages: Prisma.$ChannelMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      cityCode: string | null
      createdAt: Date
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {ChannelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels and returns the data updated in the database.
     * @param {ChannelUpdateManyAndReturnArgs} args - Arguments to update many Channels.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, ChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Channel$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly name: FieldRef<"Channel", 'String'>
    readonly type: FieldRef<"Channel", 'String'>
    readonly cityCode: FieldRef<"Channel", 'String'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
  }

  /**
   * Channel createManyAndReturn
   */
  export type ChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
    /**
     * Limit how many Channels to update.
     */
    limit?: number
  }

  /**
   * Channel updateManyAndReturn
   */
  export type ChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
    /**
     * Limit how many Channels to update.
     */
    limit?: number
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
    /**
     * Limit how many Channels to delete.
     */
    limit?: number
  }

  /**
   * Channel.messages
   */
  export type Channel$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    where?: ChannelMessageWhereInput
    orderBy?: ChannelMessageOrderByWithRelationInput | ChannelMessageOrderByWithRelationInput[]
    cursor?: ChannelMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelMessageScalarFieldEnum | ChannelMessageScalarFieldEnum[]
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model ChannelMessage
   */

  export type AggregateChannelMessage = {
    _count: ChannelMessageCountAggregateOutputType | null
    _min: ChannelMessageMinAggregateOutputType | null
    _max: ChannelMessageMaxAggregateOutputType | null
  }

  export type ChannelMessageMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type ChannelMessageMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type ChannelMessageCountAggregateOutputType = {
    id: number
    channelId: number
    userId: number
    text: number
    createdAt: number
    _all: number
  }


  export type ChannelMessageMinAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type ChannelMessageMaxAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type ChannelMessageCountAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type ChannelMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMessage to aggregate.
     */
    where?: ChannelMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMessages to fetch.
     */
    orderBy?: ChannelMessageOrderByWithRelationInput | ChannelMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelMessages
    **/
    _count?: true | ChannelMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMessageMaxAggregateInputType
  }

  export type GetChannelMessageAggregateType<T extends ChannelMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelMessage[P]>
      : GetScalarType<T[P], AggregateChannelMessage[P]>
  }




  export type ChannelMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMessageWhereInput
    orderBy?: ChannelMessageOrderByWithAggregationInput | ChannelMessageOrderByWithAggregationInput[]
    by: ChannelMessageScalarFieldEnum[] | ChannelMessageScalarFieldEnum
    having?: ChannelMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelMessageCountAggregateInputType | true
    _min?: ChannelMessageMinAggregateInputType
    _max?: ChannelMessageMaxAggregateInputType
  }

  export type ChannelMessageGroupByOutputType = {
    id: string
    channelId: string
    userId: string
    text: string
    createdAt: Date
    _count: ChannelMessageCountAggregateOutputType | null
    _min: ChannelMessageMinAggregateOutputType | null
    _max: ChannelMessageMaxAggregateOutputType | null
  }

  type GetChannelMessageGroupByPayload<T extends ChannelMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChannelMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelMessage"]>

  export type ChannelMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelMessage"]>

  export type ChannelMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelMessage"]>

  export type ChannelMessageSelectScalar = {
    id?: boolean
    channelId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type ChannelMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "channelId" | "userId" | "text" | "createdAt", ExtArgs["result"]["channelMessage"]>
  export type ChannelMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }
  export type ChannelMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }
  export type ChannelMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }

  export type $ChannelMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelMessage"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      userId: string
      text: string
      createdAt: Date
    }, ExtArgs["result"]["channelMessage"]>
    composites: {}
  }

  type ChannelMessageGetPayload<S extends boolean | null | undefined | ChannelMessageDefaultArgs> = $Result.GetResult<Prisma.$ChannelMessagePayload, S>

  type ChannelMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelMessageCountAggregateInputType | true
    }

  export interface ChannelMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelMessage'], meta: { name: 'ChannelMessage' } }
    /**
     * Find zero or one ChannelMessage that matches the filter.
     * @param {ChannelMessageFindUniqueArgs} args - Arguments to find a ChannelMessage
     * @example
     * // Get one ChannelMessage
     * const channelMessage = await prisma.channelMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelMessageFindUniqueArgs>(args: SelectSubset<T, ChannelMessageFindUniqueArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChannelMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelMessageFindUniqueOrThrowArgs} args - Arguments to find a ChannelMessage
     * @example
     * // Get one ChannelMessage
     * const channelMessage = await prisma.channelMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMessageFindFirstArgs} args - Arguments to find a ChannelMessage
     * @example
     * // Get one ChannelMessage
     * const channelMessage = await prisma.channelMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelMessageFindFirstArgs>(args?: SelectSubset<T, ChannelMessageFindFirstArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMessageFindFirstOrThrowArgs} args - Arguments to find a ChannelMessage
     * @example
     * // Get one ChannelMessage
     * const channelMessage = await prisma.channelMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChannelMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelMessages
     * const channelMessages = await prisma.channelMessage.findMany()
     * 
     * // Get first 10 ChannelMessages
     * const channelMessages = await prisma.channelMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelMessageWithIdOnly = await prisma.channelMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelMessageFindManyArgs>(args?: SelectSubset<T, ChannelMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChannelMessage.
     * @param {ChannelMessageCreateArgs} args - Arguments to create a ChannelMessage.
     * @example
     * // Create one ChannelMessage
     * const ChannelMessage = await prisma.channelMessage.create({
     *   data: {
     *     // ... data to create a ChannelMessage
     *   }
     * })
     * 
     */
    create<T extends ChannelMessageCreateArgs>(args: SelectSubset<T, ChannelMessageCreateArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChannelMessages.
     * @param {ChannelMessageCreateManyArgs} args - Arguments to create many ChannelMessages.
     * @example
     * // Create many ChannelMessages
     * const channelMessage = await prisma.channelMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelMessageCreateManyArgs>(args?: SelectSubset<T, ChannelMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelMessages and returns the data saved in the database.
     * @param {ChannelMessageCreateManyAndReturnArgs} args - Arguments to create many ChannelMessages.
     * @example
     * // Create many ChannelMessages
     * const channelMessage = await prisma.channelMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelMessages and only return the `id`
     * const channelMessageWithIdOnly = await prisma.channelMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChannelMessage.
     * @param {ChannelMessageDeleteArgs} args - Arguments to delete one ChannelMessage.
     * @example
     * // Delete one ChannelMessage
     * const ChannelMessage = await prisma.channelMessage.delete({
     *   where: {
     *     // ... filter to delete one ChannelMessage
     *   }
     * })
     * 
     */
    delete<T extends ChannelMessageDeleteArgs>(args: SelectSubset<T, ChannelMessageDeleteArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChannelMessage.
     * @param {ChannelMessageUpdateArgs} args - Arguments to update one ChannelMessage.
     * @example
     * // Update one ChannelMessage
     * const channelMessage = await prisma.channelMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelMessageUpdateArgs>(args: SelectSubset<T, ChannelMessageUpdateArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChannelMessages.
     * @param {ChannelMessageDeleteManyArgs} args - Arguments to filter ChannelMessages to delete.
     * @example
     * // Delete a few ChannelMessages
     * const { count } = await prisma.channelMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelMessageDeleteManyArgs>(args?: SelectSubset<T, ChannelMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelMessages
     * const channelMessage = await prisma.channelMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelMessageUpdateManyArgs>(args: SelectSubset<T, ChannelMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelMessages and returns the data updated in the database.
     * @param {ChannelMessageUpdateManyAndReturnArgs} args - Arguments to update many ChannelMessages.
     * @example
     * // Update many ChannelMessages
     * const channelMessage = await prisma.channelMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChannelMessages and only return the `id`
     * const channelMessageWithIdOnly = await prisma.channelMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChannelMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChannelMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChannelMessage.
     * @param {ChannelMessageUpsertArgs} args - Arguments to update or create a ChannelMessage.
     * @example
     * // Update or create a ChannelMessage
     * const channelMessage = await prisma.channelMessage.upsert({
     *   create: {
     *     // ... data to create a ChannelMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChannelMessageUpsertArgs>(args: SelectSubset<T, ChannelMessageUpsertArgs<ExtArgs>>): Prisma__ChannelMessageClient<$Result.GetResult<Prisma.$ChannelMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChannelMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMessageCountArgs} args - Arguments to filter ChannelMessages to count.
     * @example
     * // Count the number of ChannelMessages
     * const count = await prisma.channelMessage.count({
     *   where: {
     *     // ... the filter for the ChannelMessages we want to count
     *   }
     * })
    **/
    count<T extends ChannelMessageCountArgs>(
      args?: Subset<T, ChannelMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelMessageAggregateArgs>(args: Subset<T, ChannelMessageAggregateArgs>): Prisma.PrismaPromise<GetChannelMessageAggregateType<T>>

    /**
     * Group by ChannelMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChannelMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelMessage model
   */
  readonly fields: ChannelMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelMessage model
   */
  interface ChannelMessageFieldRefs {
    readonly id: FieldRef<"ChannelMessage", 'String'>
    readonly channelId: FieldRef<"ChannelMessage", 'String'>
    readonly userId: FieldRef<"ChannelMessage", 'String'>
    readonly text: FieldRef<"ChannelMessage", 'String'>
    readonly createdAt: FieldRef<"ChannelMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelMessage findUnique
   */
  export type ChannelMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMessage to fetch.
     */
    where: ChannelMessageWhereUniqueInput
  }

  /**
   * ChannelMessage findUniqueOrThrow
   */
  export type ChannelMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMessage to fetch.
     */
    where: ChannelMessageWhereUniqueInput
  }

  /**
   * ChannelMessage findFirst
   */
  export type ChannelMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMessage to fetch.
     */
    where?: ChannelMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMessages to fetch.
     */
    orderBy?: ChannelMessageOrderByWithRelationInput | ChannelMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMessages.
     */
    cursor?: ChannelMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMessages.
     */
    distinct?: ChannelMessageScalarFieldEnum | ChannelMessageScalarFieldEnum[]
  }

  /**
   * ChannelMessage findFirstOrThrow
   */
  export type ChannelMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMessage to fetch.
     */
    where?: ChannelMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMessages to fetch.
     */
    orderBy?: ChannelMessageOrderByWithRelationInput | ChannelMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMessages.
     */
    cursor?: ChannelMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMessages.
     */
    distinct?: ChannelMessageScalarFieldEnum | ChannelMessageScalarFieldEnum[]
  }

  /**
   * ChannelMessage findMany
   */
  export type ChannelMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMessages to fetch.
     */
    where?: ChannelMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMessages to fetch.
     */
    orderBy?: ChannelMessageOrderByWithRelationInput | ChannelMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelMessages.
     */
    cursor?: ChannelMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMessages.
     */
    skip?: number
    distinct?: ChannelMessageScalarFieldEnum | ChannelMessageScalarFieldEnum[]
  }

  /**
   * ChannelMessage create
   */
  export type ChannelMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelMessage.
     */
    data: XOR<ChannelMessageCreateInput, ChannelMessageUncheckedCreateInput>
  }

  /**
   * ChannelMessage createMany
   */
  export type ChannelMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelMessages.
     */
    data: ChannelMessageCreateManyInput | ChannelMessageCreateManyInput[]
  }

  /**
   * ChannelMessage createManyAndReturn
   */
  export type ChannelMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChannelMessages.
     */
    data: ChannelMessageCreateManyInput | ChannelMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelMessage update
   */
  export type ChannelMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelMessage.
     */
    data: XOR<ChannelMessageUpdateInput, ChannelMessageUncheckedUpdateInput>
    /**
     * Choose, which ChannelMessage to update.
     */
    where: ChannelMessageWhereUniqueInput
  }

  /**
   * ChannelMessage updateMany
   */
  export type ChannelMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelMessages.
     */
    data: XOR<ChannelMessageUpdateManyMutationInput, ChannelMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChannelMessages to update
     */
    where?: ChannelMessageWhereInput
    /**
     * Limit how many ChannelMessages to update.
     */
    limit?: number
  }

  /**
   * ChannelMessage updateManyAndReturn
   */
  export type ChannelMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChannelMessages.
     */
    data: XOR<ChannelMessageUpdateManyMutationInput, ChannelMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChannelMessages to update
     */
    where?: ChannelMessageWhereInput
    /**
     * Limit how many ChannelMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelMessage upsert
   */
  export type ChannelMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelMessage to update in case it exists.
     */
    where: ChannelMessageWhereUniqueInput
    /**
     * In case the ChannelMessage found by the `where` argument doesn't exist, create a new ChannelMessage with this data.
     */
    create: XOR<ChannelMessageCreateInput, ChannelMessageUncheckedCreateInput>
    /**
     * In case the ChannelMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelMessageUpdateInput, ChannelMessageUncheckedUpdateInput>
  }

  /**
   * ChannelMessage delete
   */
  export type ChannelMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
    /**
     * Filter which ChannelMessage to delete.
     */
    where: ChannelMessageWhereUniqueInput
  }

  /**
   * ChannelMessage deleteMany
   */
  export type ChannelMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMessages to delete
     */
    where?: ChannelMessageWhereInput
    /**
     * Limit how many ChannelMessages to delete.
     */
    limit?: number
  }

  /**
   * ChannelMessage without action
   */
  export type ChannelMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMessage
     */
    select?: ChannelMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelMessage
     */
    omit?: ChannelMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMessageInclude<ExtArgs> | null
  }


  /**
   * Model DirectMessage
   */

  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    text: number
    createdAt: number
    _all: number
  }


  export type DirectMessageMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithAggregationInput | DirectMessageOrderByWithAggregationInput[]
    by: DirectMessageScalarFieldEnum[] | DirectMessageScalarFieldEnum
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }

  export type DirectMessageGroupByOutputType = {
    id: string
    fromUserId: string
    toUserId: string
    text: string
    createdAt: Date
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    text?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    text?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    text?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectScalar = {
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type DirectMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromUserId" | "toUserId" | "text" | "createdAt", ExtArgs["result"]["directMessage"]>

  export type $DirectMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DirectMessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromUserId: string
      toUserId: string
      text: string
      createdAt: Date
    }, ExtArgs["result"]["directMessage"]>
    composites: {}
  }

  type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageDefaultArgs> = $Result.GetResult<Prisma.$DirectMessagePayload, S>

  type DirectMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DirectMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DirectMessage'], meta: { name: 'DirectMessage' } }
    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirectMessageFindUniqueArgs>(args: SelectSubset<T, DirectMessageFindUniqueArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DirectMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirectMessageFindFirstArgs>(args?: SelectSubset<T, DirectMessageFindFirstArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirectMessageFindManyArgs>(args?: SelectSubset<T, DirectMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
     */
    create<T extends DirectMessageCreateArgs>(args: SelectSubset<T, DirectMessageCreateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DirectMessages.
     * @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirectMessageCreateManyArgs>(args?: SelectSubset<T, DirectMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DirectMessages and returns the data saved in the database.
     * @param {DirectMessageCreateManyAndReturnArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DirectMessages and only return the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DirectMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DirectMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
     */
    delete<T extends DirectMessageDeleteArgs>(args: SelectSubset<T, DirectMessageDeleteArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirectMessageUpdateArgs>(args: SelectSubset<T, DirectMessageUpdateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirectMessageDeleteManyArgs>(args?: SelectSubset<T, DirectMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirectMessageUpdateManyArgs>(args: SelectSubset<T, DirectMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages and returns the data updated in the database.
     * @param {DirectMessageUpdateManyAndReturnArgs} args - Arguments to update many DirectMessages.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DirectMessages and only return the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DirectMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, DirectMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
     */
    upsert<T extends DirectMessageUpsertArgs>(args: SelectSubset<T, DirectMessageUpsertArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DirectMessage model
   */
  readonly fields: DirectMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirectMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DirectMessage model
   */
  interface DirectMessageFieldRefs {
    readonly id: FieldRef<"DirectMessage", 'String'>
    readonly fromUserId: FieldRef<"DirectMessage", 'String'>
    readonly toUserId: FieldRef<"DirectMessage", 'String'>
    readonly text: FieldRef<"DirectMessage", 'String'>
    readonly createdAt: FieldRef<"DirectMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DirectMessage findUnique
   */
  export type DirectMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findFirst
   */
  export type DirectMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }

  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
  }

  /**
   * DirectMessage createManyAndReturn
   */
  export type DirectMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
  }

  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
    /**
     * Limit how many DirectMessages to update.
     */
    limit?: number
  }

  /**
   * DirectMessage updateManyAndReturn
   */
  export type DirectMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
    /**
     * Limit how many DirectMessages to update.
     */
    limit?: number
  }

  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }

  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
    /**
     * Limit how many DirectMessages to delete.
     */
    limit?: number
  }

  /**
   * DirectMessage without action
   */
  export type DirectMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    userId: string | null
    text: string | null
    imageUrl: string | null
    clubBookId: string | null
    createdAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    text: string | null
    imageUrl: string | null
    clubBookId: string | null
    createdAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    userId: number
    text: number
    imageUrl: number
    clubBookId: number
    createdAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    imageUrl?: true
    clubBookId?: true
    createdAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    imageUrl?: true
    clubBookId?: true
    createdAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    imageUrl?: true
    clubBookId?: true
    createdAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    userId: string
    text: string
    imageUrl: string | null
    clubBookId: string | null
    createdAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    text?: boolean
    imageUrl?: boolean
    clubBookId?: boolean
    createdAt?: boolean
    likes?: boolean | Post$likesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    text?: boolean
    imageUrl?: boolean
    clubBookId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    text?: boolean
    imageUrl?: boolean
    clubBookId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    userId?: boolean
    text?: boolean
    imageUrl?: boolean
    clubBookId?: boolean
    createdAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "text" | "imageUrl" | "clubBookId" | "createdAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | Post$likesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      likes: Prisma.$LikePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      images: Prisma.$PostImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      text: string
      imageUrl: string | null
      clubBookId: string | null
      createdAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    likes<T extends Post$likesArgs<ExtArgs> = {}>(args?: Subset<T, Post$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Post$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Post$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly userId: FieldRef<"Post", 'String'>
    readonly text: FieldRef<"Post", 'String'>
    readonly imageUrl: FieldRef<"Post", 'String'>
    readonly clubBookId: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.likes
   */
  export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.images
   */
  export type Post$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    where?: PostImageWhereInput
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    cursor?: PostImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PostImage
   */

  export type AggregatePostImage = {
    _count: PostImageCountAggregateOutputType | null
    _avg: PostImageAvgAggregateOutputType | null
    _sum: PostImageSumAggregateOutputType | null
    _min: PostImageMinAggregateOutputType | null
    _max: PostImageMaxAggregateOutputType | null
  }

  export type PostImageAvgAggregateOutputType = {
    index: number | null
  }

  export type PostImageSumAggregateOutputType = {
    index: number | null
  }

  export type PostImageMinAggregateOutputType = {
    id: string | null
    postId: string | null
    url: string | null
    index: number | null
  }

  export type PostImageMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    url: string | null
    index: number | null
  }

  export type PostImageCountAggregateOutputType = {
    id: number
    postId: number
    url: number
    index: number
    _all: number
  }


  export type PostImageAvgAggregateInputType = {
    index?: true
  }

  export type PostImageSumAggregateInputType = {
    index?: true
  }

  export type PostImageMinAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    index?: true
  }

  export type PostImageMaxAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    index?: true
  }

  export type PostImageCountAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    index?: true
    _all?: true
  }

  export type PostImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImage to aggregate.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostImages
    **/
    _count?: true | PostImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostImageMaxAggregateInputType
  }

  export type GetPostImageAggregateType<T extends PostImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePostImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostImage[P]>
      : GetScalarType<T[P], AggregatePostImage[P]>
  }




  export type PostImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageWhereInput
    orderBy?: PostImageOrderByWithAggregationInput | PostImageOrderByWithAggregationInput[]
    by: PostImageScalarFieldEnum[] | PostImageScalarFieldEnum
    having?: PostImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostImageCountAggregateInputType | true
    _avg?: PostImageAvgAggregateInputType
    _sum?: PostImageSumAggregateInputType
    _min?: PostImageMinAggregateInputType
    _max?: PostImageMaxAggregateInputType
  }

  export type PostImageGroupByOutputType = {
    id: string
    postId: string
    url: string
    index: number
    _count: PostImageCountAggregateOutputType | null
    _avg: PostImageAvgAggregateOutputType | null
    _sum: PostImageSumAggregateOutputType | null
    _min: PostImageMinAggregateOutputType | null
    _max: PostImageMaxAggregateOutputType | null
  }

  type GetPostImageGroupByPayload<T extends PostImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostImageGroupByOutputType[P]>
            : GetScalarType<T[P], PostImageGroupByOutputType[P]>
        }
      >
    >


  export type PostImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    url?: boolean
    index?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    url?: boolean
    index?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    url?: boolean
    index?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectScalar = {
    id?: boolean
    postId?: boolean
    url?: boolean
    index?: boolean
  }

  export type PostImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "url" | "index", ExtArgs["result"]["postImage"]>
  export type PostImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostImage"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      url: string
      index: number
    }, ExtArgs["result"]["postImage"]>
    composites: {}
  }

  type PostImageGetPayload<S extends boolean | null | undefined | PostImageDefaultArgs> = $Result.GetResult<Prisma.$PostImagePayload, S>

  type PostImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostImageCountAggregateInputType | true
    }

  export interface PostImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostImage'], meta: { name: 'PostImage' } }
    /**
     * Find zero or one PostImage that matches the filter.
     * @param {PostImageFindUniqueArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostImageFindUniqueArgs>(args: SelectSubset<T, PostImageFindUniqueArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostImageFindUniqueOrThrowArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PostImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindFirstArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostImageFindFirstArgs>(args?: SelectSubset<T, PostImageFindFirstArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindFirstOrThrowArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PostImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostImages
     * const postImages = await prisma.postImage.findMany()
     * 
     * // Get first 10 PostImages
     * const postImages = await prisma.postImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postImageWithIdOnly = await prisma.postImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostImageFindManyArgs>(args?: SelectSubset<T, PostImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostImage.
     * @param {PostImageCreateArgs} args - Arguments to create a PostImage.
     * @example
     * // Create one PostImage
     * const PostImage = await prisma.postImage.create({
     *   data: {
     *     // ... data to create a PostImage
     *   }
     * })
     * 
     */
    create<T extends PostImageCreateArgs>(args: SelectSubset<T, PostImageCreateArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostImages.
     * @param {PostImageCreateManyArgs} args - Arguments to create many PostImages.
     * @example
     * // Create many PostImages
     * const postImage = await prisma.postImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostImageCreateManyArgs>(args?: SelectSubset<T, PostImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostImages and returns the data saved in the database.
     * @param {PostImageCreateManyAndReturnArgs} args - Arguments to create many PostImages.
     * @example
     * // Create many PostImages
     * const postImage = await prisma.postImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostImages and only return the `id`
     * const postImageWithIdOnly = await prisma.postImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PostImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostImage.
     * @param {PostImageDeleteArgs} args - Arguments to delete one PostImage.
     * @example
     * // Delete one PostImage
     * const PostImage = await prisma.postImage.delete({
     *   where: {
     *     // ... filter to delete one PostImage
     *   }
     * })
     * 
     */
    delete<T extends PostImageDeleteArgs>(args: SelectSubset<T, PostImageDeleteArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostImage.
     * @param {PostImageUpdateArgs} args - Arguments to update one PostImage.
     * @example
     * // Update one PostImage
     * const postImage = await prisma.postImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostImageUpdateArgs>(args: SelectSubset<T, PostImageUpdateArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostImages.
     * @param {PostImageDeleteManyArgs} args - Arguments to filter PostImages to delete.
     * @example
     * // Delete a few PostImages
     * const { count } = await prisma.postImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostImageDeleteManyArgs>(args?: SelectSubset<T, PostImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostImages
     * const postImage = await prisma.postImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostImageUpdateManyArgs>(args: SelectSubset<T, PostImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostImages and returns the data updated in the database.
     * @param {PostImageUpdateManyAndReturnArgs} args - Arguments to update many PostImages.
     * @example
     * // Update many PostImages
     * const postImage = await prisma.postImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostImages and only return the `id`
     * const postImageWithIdOnly = await prisma.postImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostImageUpdateManyAndReturnArgs>(args: SelectSubset<T, PostImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostImage.
     * @param {PostImageUpsertArgs} args - Arguments to update or create a PostImage.
     * @example
     * // Update or create a PostImage
     * const postImage = await prisma.postImage.upsert({
     *   create: {
     *     // ... data to create a PostImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostImage we want to update
     *   }
     * })
     */
    upsert<T extends PostImageUpsertArgs>(args: SelectSubset<T, PostImageUpsertArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageCountArgs} args - Arguments to filter PostImages to count.
     * @example
     * // Count the number of PostImages
     * const count = await prisma.postImage.count({
     *   where: {
     *     // ... the filter for the PostImages we want to count
     *   }
     * })
    **/
    count<T extends PostImageCountArgs>(
      args?: Subset<T, PostImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostImageAggregateArgs>(args: Subset<T, PostImageAggregateArgs>): Prisma.PrismaPromise<GetPostImageAggregateType<T>>

    /**
     * Group by PostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostImageGroupByArgs['orderBy'] }
        : { orderBy?: PostImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostImage model
   */
  readonly fields: PostImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostImage model
   */
  interface PostImageFieldRefs {
    readonly id: FieldRef<"PostImage", 'String'>
    readonly postId: FieldRef<"PostImage", 'String'>
    readonly url: FieldRef<"PostImage", 'String'>
    readonly index: FieldRef<"PostImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PostImage findUnique
   */
  export type PostImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage findUniqueOrThrow
   */
  export type PostImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage findFirst
   */
  export type PostImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImages.
     */
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage findFirstOrThrow
   */
  export type PostImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImages.
     */
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage findMany
   */
  export type PostImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImages to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage create
   */
  export type PostImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PostImage.
     */
    data: XOR<PostImageCreateInput, PostImageUncheckedCreateInput>
  }

  /**
   * PostImage createMany
   */
  export type PostImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostImages.
     */
    data: PostImageCreateManyInput | PostImageCreateManyInput[]
  }

  /**
   * PostImage createManyAndReturn
   */
  export type PostImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * The data used to create many PostImages.
     */
    data: PostImageCreateManyInput | PostImageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostImage update
   */
  export type PostImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PostImage.
     */
    data: XOR<PostImageUpdateInput, PostImageUncheckedUpdateInput>
    /**
     * Choose, which PostImage to update.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage updateMany
   */
  export type PostImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostImages.
     */
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyInput>
    /**
     * Filter which PostImages to update
     */
    where?: PostImageWhereInput
    /**
     * Limit how many PostImages to update.
     */
    limit?: number
  }

  /**
   * PostImage updateManyAndReturn
   */
  export type PostImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * The data used to update PostImages.
     */
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyInput>
    /**
     * Filter which PostImages to update
     */
    where?: PostImageWhereInput
    /**
     * Limit how many PostImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostImage upsert
   */
  export type PostImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PostImage to update in case it exists.
     */
    where: PostImageWhereUniqueInput
    /**
     * In case the PostImage found by the `where` argument doesn't exist, create a new PostImage with this data.
     */
    create: XOR<PostImageCreateInput, PostImageUncheckedCreateInput>
    /**
     * In case the PostImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostImageUpdateInput, PostImageUncheckedUpdateInput>
  }

  /**
   * PostImage delete
   */
  export type PostImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter which PostImage to delete.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage deleteMany
   */
  export type PostImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImages to delete
     */
    where?: PostImageWhereInput
    /**
     * Limit how many PostImages to delete.
     */
    limit?: number
  }

  /**
   * PostImage without action
   */
  export type PostImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    postId: string
    userId: string
    type: string
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type LikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "type" | "createdAt", ExtArgs["result"]["like"]>
  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type LikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes and returns the data updated in the database.
     * @param {LikeUpdateManyAndReturnArgs} args - Arguments to update many Likes.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly postId: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
    readonly type: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
  }

  /**
   * Like updateManyAndReturn
   */
  export type LikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to delete.
     */
    limit?: number
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    text: number
    createdAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    userId: string
    text: string
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "text" | "createdAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      text: string
      createdAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Poll
   */

  export type AggregatePoll = {
    _count: PollCountAggregateOutputType | null
    _min: PollMinAggregateOutputType | null
    _max: PollMaxAggregateOutputType | null
  }

  export type PollMinAggregateOutputType = {
    id: string | null
    clubBookId: string | null
    city: string | null
    userId: string | null
    question: string | null
    description: string | null
    imageUrl: string | null
    multiChoice: boolean | null
    publicVotes: boolean | null
    createdAt: Date | null
  }

  export type PollMaxAggregateOutputType = {
    id: string | null
    clubBookId: string | null
    city: string | null
    userId: string | null
    question: string | null
    description: string | null
    imageUrl: string | null
    multiChoice: boolean | null
    publicVotes: boolean | null
    createdAt: Date | null
  }

  export type PollCountAggregateOutputType = {
    id: number
    clubBookId: number
    city: number
    userId: number
    question: number
    description: number
    imageUrl: number
    multiChoice: number
    publicVotes: number
    createdAt: number
    _all: number
  }


  export type PollMinAggregateInputType = {
    id?: true
    clubBookId?: true
    city?: true
    userId?: true
    question?: true
    description?: true
    imageUrl?: true
    multiChoice?: true
    publicVotes?: true
    createdAt?: true
  }

  export type PollMaxAggregateInputType = {
    id?: true
    clubBookId?: true
    city?: true
    userId?: true
    question?: true
    description?: true
    imageUrl?: true
    multiChoice?: true
    publicVotes?: true
    createdAt?: true
  }

  export type PollCountAggregateInputType = {
    id?: true
    clubBookId?: true
    city?: true
    userId?: true
    question?: true
    description?: true
    imageUrl?: true
    multiChoice?: true
    publicVotes?: true
    createdAt?: true
    _all?: true
  }

  export type PollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Poll to aggregate.
     */
    where?: PollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Polls
    **/
    _count?: true | PollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollMaxAggregateInputType
  }

  export type GetPollAggregateType<T extends PollAggregateArgs> = {
        [P in keyof T & keyof AggregatePoll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoll[P]>
      : GetScalarType<T[P], AggregatePoll[P]>
  }




  export type PollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollWhereInput
    orderBy?: PollOrderByWithAggregationInput | PollOrderByWithAggregationInput[]
    by: PollScalarFieldEnum[] | PollScalarFieldEnum
    having?: PollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollCountAggregateInputType | true
    _min?: PollMinAggregateInputType
    _max?: PollMaxAggregateInputType
  }

  export type PollGroupByOutputType = {
    id: string
    clubBookId: string | null
    city: string
    userId: string
    question: string
    description: string | null
    imageUrl: string | null
    multiChoice: boolean
    publicVotes: boolean
    createdAt: Date
    _count: PollCountAggregateOutputType | null
    _min: PollMinAggregateOutputType | null
    _max: PollMaxAggregateOutputType | null
  }

  type GetPollGroupByPayload<T extends PollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollGroupByOutputType[P]>
            : GetScalarType<T[P], PollGroupByOutputType[P]>
        }
      >
    >


  export type PollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    city?: boolean
    userId?: boolean
    question?: boolean
    description?: boolean
    imageUrl?: boolean
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: boolean
    options?: boolean | Poll$optionsArgs<ExtArgs>
    votes?: boolean | Poll$votesArgs<ExtArgs>
    _count?: boolean | PollCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poll"]>

  export type PollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    city?: boolean
    userId?: boolean
    question?: boolean
    description?: boolean
    imageUrl?: boolean
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["poll"]>

  export type PollSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubBookId?: boolean
    city?: boolean
    userId?: boolean
    question?: boolean
    description?: boolean
    imageUrl?: boolean
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["poll"]>

  export type PollSelectScalar = {
    id?: boolean
    clubBookId?: boolean
    city?: boolean
    userId?: boolean
    question?: boolean
    description?: boolean
    imageUrl?: boolean
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: boolean
  }

  export type PollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clubBookId" | "city" | "userId" | "question" | "description" | "imageUrl" | "multiChoice" | "publicVotes" | "createdAt", ExtArgs["result"]["poll"]>
  export type PollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | Poll$optionsArgs<ExtArgs>
    votes?: boolean | Poll$votesArgs<ExtArgs>
    _count?: boolean | PollCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PollIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Poll"
    objects: {
      options: Prisma.$PollOptionPayload<ExtArgs>[]
      votes: Prisma.$PollVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clubBookId: string | null
      city: string
      userId: string
      question: string
      description: string | null
      imageUrl: string | null
      multiChoice: boolean
      publicVotes: boolean
      createdAt: Date
    }, ExtArgs["result"]["poll"]>
    composites: {}
  }

  type PollGetPayload<S extends boolean | null | undefined | PollDefaultArgs> = $Result.GetResult<Prisma.$PollPayload, S>

  type PollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PollCountAggregateInputType | true
    }

  export interface PollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Poll'], meta: { name: 'Poll' } }
    /**
     * Find zero or one Poll that matches the filter.
     * @param {PollFindUniqueArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollFindUniqueArgs>(args: SelectSubset<T, PollFindUniqueArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollFindUniqueOrThrowArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollFindUniqueOrThrowArgs>(args: SelectSubset<T, PollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollFindFirstArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollFindFirstArgs>(args?: SelectSubset<T, PollFindFirstArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollFindFirstOrThrowArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollFindFirstOrThrowArgs>(args?: SelectSubset<T, PollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Polls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Polls
     * const polls = await prisma.poll.findMany()
     * 
     * // Get first 10 Polls
     * const polls = await prisma.poll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pollWithIdOnly = await prisma.poll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PollFindManyArgs>(args?: SelectSubset<T, PollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poll.
     * @param {PollCreateArgs} args - Arguments to create a Poll.
     * @example
     * // Create one Poll
     * const Poll = await prisma.poll.create({
     *   data: {
     *     // ... data to create a Poll
     *   }
     * })
     * 
     */
    create<T extends PollCreateArgs>(args: SelectSubset<T, PollCreateArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Polls.
     * @param {PollCreateManyArgs} args - Arguments to create many Polls.
     * @example
     * // Create many Polls
     * const poll = await prisma.poll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollCreateManyArgs>(args?: SelectSubset<T, PollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Polls and returns the data saved in the database.
     * @param {PollCreateManyAndReturnArgs} args - Arguments to create many Polls.
     * @example
     * // Create many Polls
     * const poll = await prisma.poll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Polls and only return the `id`
     * const pollWithIdOnly = await prisma.poll.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PollCreateManyAndReturnArgs>(args?: SelectSubset<T, PollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Poll.
     * @param {PollDeleteArgs} args - Arguments to delete one Poll.
     * @example
     * // Delete one Poll
     * const Poll = await prisma.poll.delete({
     *   where: {
     *     // ... filter to delete one Poll
     *   }
     * })
     * 
     */
    delete<T extends PollDeleteArgs>(args: SelectSubset<T, PollDeleteArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poll.
     * @param {PollUpdateArgs} args - Arguments to update one Poll.
     * @example
     * // Update one Poll
     * const poll = await prisma.poll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollUpdateArgs>(args: SelectSubset<T, PollUpdateArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Polls.
     * @param {PollDeleteManyArgs} args - Arguments to filter Polls to delete.
     * @example
     * // Delete a few Polls
     * const { count } = await prisma.poll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollDeleteManyArgs>(args?: SelectSubset<T, PollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Polls
     * const poll = await prisma.poll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollUpdateManyArgs>(args: SelectSubset<T, PollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Polls and returns the data updated in the database.
     * @param {PollUpdateManyAndReturnArgs} args - Arguments to update many Polls.
     * @example
     * // Update many Polls
     * const poll = await prisma.poll.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Polls and only return the `id`
     * const pollWithIdOnly = await prisma.poll.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PollUpdateManyAndReturnArgs>(args: SelectSubset<T, PollUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Poll.
     * @param {PollUpsertArgs} args - Arguments to update or create a Poll.
     * @example
     * // Update or create a Poll
     * const poll = await prisma.poll.upsert({
     *   create: {
     *     // ... data to create a Poll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poll we want to update
     *   }
     * })
     */
    upsert<T extends PollUpsertArgs>(args: SelectSubset<T, PollUpsertArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollCountArgs} args - Arguments to filter Polls to count.
     * @example
     * // Count the number of Polls
     * const count = await prisma.poll.count({
     *   where: {
     *     // ... the filter for the Polls we want to count
     *   }
     * })
    **/
    count<T extends PollCountArgs>(
      args?: Subset<T, PollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollAggregateArgs>(args: Subset<T, PollAggregateArgs>): Prisma.PrismaPromise<GetPollAggregateType<T>>

    /**
     * Group by Poll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollGroupByArgs['orderBy'] }
        : { orderBy?: PollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Poll model
   */
  readonly fields: PollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Poll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    options<T extends Poll$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Poll$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends Poll$votesArgs<ExtArgs> = {}>(args?: Subset<T, Poll$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Poll model
   */
  interface PollFieldRefs {
    readonly id: FieldRef<"Poll", 'String'>
    readonly clubBookId: FieldRef<"Poll", 'String'>
    readonly city: FieldRef<"Poll", 'String'>
    readonly userId: FieldRef<"Poll", 'String'>
    readonly question: FieldRef<"Poll", 'String'>
    readonly description: FieldRef<"Poll", 'String'>
    readonly imageUrl: FieldRef<"Poll", 'String'>
    readonly multiChoice: FieldRef<"Poll", 'Boolean'>
    readonly publicVotes: FieldRef<"Poll", 'Boolean'>
    readonly createdAt: FieldRef<"Poll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Poll findUnique
   */
  export type PollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * Filter, which Poll to fetch.
     */
    where: PollWhereUniqueInput
  }

  /**
   * Poll findUniqueOrThrow
   */
  export type PollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * Filter, which Poll to fetch.
     */
    where: PollWhereUniqueInput
  }

  /**
   * Poll findFirst
   */
  export type PollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * Filter, which Poll to fetch.
     */
    where?: PollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Polls.
     */
    cursor?: PollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Polls.
     */
    distinct?: PollScalarFieldEnum | PollScalarFieldEnum[]
  }

  /**
   * Poll findFirstOrThrow
   */
  export type PollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * Filter, which Poll to fetch.
     */
    where?: PollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Polls.
     */
    cursor?: PollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Polls.
     */
    distinct?: PollScalarFieldEnum | PollScalarFieldEnum[]
  }

  /**
   * Poll findMany
   */
  export type PollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * Filter, which Polls to fetch.
     */
    where?: PollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Polls.
     */
    cursor?: PollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    distinct?: PollScalarFieldEnum | PollScalarFieldEnum[]
  }

  /**
   * Poll create
   */
  export type PollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * The data needed to create a Poll.
     */
    data: XOR<PollCreateInput, PollUncheckedCreateInput>
  }

  /**
   * Poll createMany
   */
  export type PollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Polls.
     */
    data: PollCreateManyInput | PollCreateManyInput[]
  }

  /**
   * Poll createManyAndReturn
   */
  export type PollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * The data used to create many Polls.
     */
    data: PollCreateManyInput | PollCreateManyInput[]
  }

  /**
   * Poll update
   */
  export type PollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * The data needed to update a Poll.
     */
    data: XOR<PollUpdateInput, PollUncheckedUpdateInput>
    /**
     * Choose, which Poll to update.
     */
    where: PollWhereUniqueInput
  }

  /**
   * Poll updateMany
   */
  export type PollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Polls.
     */
    data: XOR<PollUpdateManyMutationInput, PollUncheckedUpdateManyInput>
    /**
     * Filter which Polls to update
     */
    where?: PollWhereInput
    /**
     * Limit how many Polls to update.
     */
    limit?: number
  }

  /**
   * Poll updateManyAndReturn
   */
  export type PollUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * The data used to update Polls.
     */
    data: XOR<PollUpdateManyMutationInput, PollUncheckedUpdateManyInput>
    /**
     * Filter which Polls to update
     */
    where?: PollWhereInput
    /**
     * Limit how many Polls to update.
     */
    limit?: number
  }

  /**
   * Poll upsert
   */
  export type PollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * The filter to search for the Poll to update in case it exists.
     */
    where: PollWhereUniqueInput
    /**
     * In case the Poll found by the `where` argument doesn't exist, create a new Poll with this data.
     */
    create: XOR<PollCreateInput, PollUncheckedCreateInput>
    /**
     * In case the Poll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollUpdateInput, PollUncheckedUpdateInput>
  }

  /**
   * Poll delete
   */
  export type PollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
    /**
     * Filter which Poll to delete.
     */
    where: PollWhereUniqueInput
  }

  /**
   * Poll deleteMany
   */
  export type PollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Polls to delete
     */
    where?: PollWhereInput
    /**
     * Limit how many Polls to delete.
     */
    limit?: number
  }

  /**
   * Poll.options
   */
  export type Poll$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    where?: PollOptionWhereInput
    orderBy?: PollOptionOrderByWithRelationInput | PollOptionOrderByWithRelationInput[]
    cursor?: PollOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[]
  }

  /**
   * Poll.votes
   */
  export type Poll$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    cursor?: PollVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * Poll without action
   */
  export type PollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null
  }


  /**
   * Model PollOption
   */

  export type AggregatePollOption = {
    _count: PollOptionCountAggregateOutputType | null
    _avg: PollOptionAvgAggregateOutputType | null
    _sum: PollOptionSumAggregateOutputType | null
    _min: PollOptionMinAggregateOutputType | null
    _max: PollOptionMaxAggregateOutputType | null
  }

  export type PollOptionAvgAggregateOutputType = {
    index: number | null
  }

  export type PollOptionSumAggregateOutputType = {
    index: number | null
  }

  export type PollOptionMinAggregateOutputType = {
    id: string | null
    pollId: string | null
    type: string | null
    text: string | null
    imageUrl: string | null
    bookId: string | null
    index: number | null
  }

  export type PollOptionMaxAggregateOutputType = {
    id: string | null
    pollId: string | null
    type: string | null
    text: string | null
    imageUrl: string | null
    bookId: string | null
    index: number | null
  }

  export type PollOptionCountAggregateOutputType = {
    id: number
    pollId: number
    type: number
    text: number
    imageUrl: number
    bookId: number
    index: number
    _all: number
  }


  export type PollOptionAvgAggregateInputType = {
    index?: true
  }

  export type PollOptionSumAggregateInputType = {
    index?: true
  }

  export type PollOptionMinAggregateInputType = {
    id?: true
    pollId?: true
    type?: true
    text?: true
    imageUrl?: true
    bookId?: true
    index?: true
  }

  export type PollOptionMaxAggregateInputType = {
    id?: true
    pollId?: true
    type?: true
    text?: true
    imageUrl?: true
    bookId?: true
    index?: true
  }

  export type PollOptionCountAggregateInputType = {
    id?: true
    pollId?: true
    type?: true
    text?: true
    imageUrl?: true
    bookId?: true
    index?: true
    _all?: true
  }

  export type PollOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollOption to aggregate.
     */
    where?: PollOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollOptions to fetch.
     */
    orderBy?: PollOptionOrderByWithRelationInput | PollOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PollOptions
    **/
    _count?: true | PollOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PollOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PollOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollOptionMaxAggregateInputType
  }

  export type GetPollOptionAggregateType<T extends PollOptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePollOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollOption[P]>
      : GetScalarType<T[P], AggregatePollOption[P]>
  }




  export type PollOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollOptionWhereInput
    orderBy?: PollOptionOrderByWithAggregationInput | PollOptionOrderByWithAggregationInput[]
    by: PollOptionScalarFieldEnum[] | PollOptionScalarFieldEnum
    having?: PollOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollOptionCountAggregateInputType | true
    _avg?: PollOptionAvgAggregateInputType
    _sum?: PollOptionSumAggregateInputType
    _min?: PollOptionMinAggregateInputType
    _max?: PollOptionMaxAggregateInputType
  }

  export type PollOptionGroupByOutputType = {
    id: string
    pollId: string
    type: string
    text: string
    imageUrl: string | null
    bookId: string | null
    index: number
    _count: PollOptionCountAggregateOutputType | null
    _avg: PollOptionAvgAggregateOutputType | null
    _sum: PollOptionSumAggregateOutputType | null
    _min: PollOptionMinAggregateOutputType | null
    _max: PollOptionMaxAggregateOutputType | null
  }

  type GetPollOptionGroupByPayload<T extends PollOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollOptionGroupByOutputType[P]>
            : GetScalarType<T[P], PollOptionGroupByOutputType[P]>
        }
      >
    >


  export type PollOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    type?: boolean
    text?: boolean
    imageUrl?: boolean
    bookId?: boolean
    index?: boolean
    poll?: boolean | PollDefaultArgs<ExtArgs>
    book?: boolean | PollOption$bookArgs<ExtArgs>
    votes?: boolean | PollOption$votesArgs<ExtArgs>
    _count?: boolean | PollOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollOption"]>

  export type PollOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    type?: boolean
    text?: boolean
    imageUrl?: boolean
    bookId?: boolean
    index?: boolean
    poll?: boolean | PollDefaultArgs<ExtArgs>
    book?: boolean | PollOption$bookArgs<ExtArgs>
  }, ExtArgs["result"]["pollOption"]>

  export type PollOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    type?: boolean
    text?: boolean
    imageUrl?: boolean
    bookId?: boolean
    index?: boolean
    poll?: boolean | PollDefaultArgs<ExtArgs>
    book?: boolean | PollOption$bookArgs<ExtArgs>
  }, ExtArgs["result"]["pollOption"]>

  export type PollOptionSelectScalar = {
    id?: boolean
    pollId?: boolean
    type?: boolean
    text?: boolean
    imageUrl?: boolean
    bookId?: boolean
    index?: boolean
  }

  export type PollOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pollId" | "type" | "text" | "imageUrl" | "bookId" | "index", ExtArgs["result"]["pollOption"]>
  export type PollOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | PollDefaultArgs<ExtArgs>
    book?: boolean | PollOption$bookArgs<ExtArgs>
    votes?: boolean | PollOption$votesArgs<ExtArgs>
    _count?: boolean | PollOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PollOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | PollDefaultArgs<ExtArgs>
    book?: boolean | PollOption$bookArgs<ExtArgs>
  }
  export type PollOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | PollDefaultArgs<ExtArgs>
    book?: boolean | PollOption$bookArgs<ExtArgs>
  }

  export type $PollOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PollOption"
    objects: {
      poll: Prisma.$PollPayload<ExtArgs>
      book: Prisma.$BookPayload<ExtArgs> | null
      votes: Prisma.$PollVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pollId: string
      type: string
      text: string
      imageUrl: string | null
      bookId: string | null
      index: number
    }, ExtArgs["result"]["pollOption"]>
    composites: {}
  }

  type PollOptionGetPayload<S extends boolean | null | undefined | PollOptionDefaultArgs> = $Result.GetResult<Prisma.$PollOptionPayload, S>

  type PollOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PollOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PollOptionCountAggregateInputType | true
    }

  export interface PollOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PollOption'], meta: { name: 'PollOption' } }
    /**
     * Find zero or one PollOption that matches the filter.
     * @param {PollOptionFindUniqueArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollOptionFindUniqueArgs>(args: SelectSubset<T, PollOptionFindUniqueArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PollOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollOptionFindUniqueOrThrowArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PollOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PollOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionFindFirstArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollOptionFindFirstArgs>(args?: SelectSubset<T, PollOptionFindFirstArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PollOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionFindFirstOrThrowArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PollOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PollOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollOptions
     * const pollOptions = await prisma.pollOption.findMany()
     * 
     * // Get first 10 PollOptions
     * const pollOptions = await prisma.pollOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pollOptionWithIdOnly = await prisma.pollOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PollOptionFindManyArgs>(args?: SelectSubset<T, PollOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PollOption.
     * @param {PollOptionCreateArgs} args - Arguments to create a PollOption.
     * @example
     * // Create one PollOption
     * const PollOption = await prisma.pollOption.create({
     *   data: {
     *     // ... data to create a PollOption
     *   }
     * })
     * 
     */
    create<T extends PollOptionCreateArgs>(args: SelectSubset<T, PollOptionCreateArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PollOptions.
     * @param {PollOptionCreateManyArgs} args - Arguments to create many PollOptions.
     * @example
     * // Create many PollOptions
     * const pollOption = await prisma.pollOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollOptionCreateManyArgs>(args?: SelectSubset<T, PollOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PollOptions and returns the data saved in the database.
     * @param {PollOptionCreateManyAndReturnArgs} args - Arguments to create many PollOptions.
     * @example
     * // Create many PollOptions
     * const pollOption = await prisma.pollOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PollOptions and only return the `id`
     * const pollOptionWithIdOnly = await prisma.pollOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PollOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PollOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PollOption.
     * @param {PollOptionDeleteArgs} args - Arguments to delete one PollOption.
     * @example
     * // Delete one PollOption
     * const PollOption = await prisma.pollOption.delete({
     *   where: {
     *     // ... filter to delete one PollOption
     *   }
     * })
     * 
     */
    delete<T extends PollOptionDeleteArgs>(args: SelectSubset<T, PollOptionDeleteArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PollOption.
     * @param {PollOptionUpdateArgs} args - Arguments to update one PollOption.
     * @example
     * // Update one PollOption
     * const pollOption = await prisma.pollOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollOptionUpdateArgs>(args: SelectSubset<T, PollOptionUpdateArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PollOptions.
     * @param {PollOptionDeleteManyArgs} args - Arguments to filter PollOptions to delete.
     * @example
     * // Delete a few PollOptions
     * const { count } = await prisma.pollOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollOptionDeleteManyArgs>(args?: SelectSubset<T, PollOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollOptions
     * const pollOption = await prisma.pollOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollOptionUpdateManyArgs>(args: SelectSubset<T, PollOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollOptions and returns the data updated in the database.
     * @param {PollOptionUpdateManyAndReturnArgs} args - Arguments to update many PollOptions.
     * @example
     * // Update many PollOptions
     * const pollOption = await prisma.pollOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PollOptions and only return the `id`
     * const pollOptionWithIdOnly = await prisma.pollOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PollOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PollOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PollOption.
     * @param {PollOptionUpsertArgs} args - Arguments to update or create a PollOption.
     * @example
     * // Update or create a PollOption
     * const pollOption = await prisma.pollOption.upsert({
     *   create: {
     *     // ... data to create a PollOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollOption we want to update
     *   }
     * })
     */
    upsert<T extends PollOptionUpsertArgs>(args: SelectSubset<T, PollOptionUpsertArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionCountArgs} args - Arguments to filter PollOptions to count.
     * @example
     * // Count the number of PollOptions
     * const count = await prisma.pollOption.count({
     *   where: {
     *     // ... the filter for the PollOptions we want to count
     *   }
     * })
    **/
    count<T extends PollOptionCountArgs>(
      args?: Subset<T, PollOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PollOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollOptionAggregateArgs>(args: Subset<T, PollOptionAggregateArgs>): Prisma.PrismaPromise<GetPollOptionAggregateType<T>>

    /**
     * Group by PollOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollOptionGroupByArgs['orderBy'] }
        : { orderBy?: PollOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PollOption model
   */
  readonly fields: PollOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poll<T extends PollDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PollDefaultArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends PollOption$bookArgs<ExtArgs> = {}>(args?: Subset<T, PollOption$bookArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    votes<T extends PollOption$votesArgs<ExtArgs> = {}>(args?: Subset<T, PollOption$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PollOption model
   */
  interface PollOptionFieldRefs {
    readonly id: FieldRef<"PollOption", 'String'>
    readonly pollId: FieldRef<"PollOption", 'String'>
    readonly type: FieldRef<"PollOption", 'String'>
    readonly text: FieldRef<"PollOption", 'String'>
    readonly imageUrl: FieldRef<"PollOption", 'String'>
    readonly bookId: FieldRef<"PollOption", 'String'>
    readonly index: FieldRef<"PollOption", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PollOption findUnique
   */
  export type PollOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * Filter, which PollOption to fetch.
     */
    where: PollOptionWhereUniqueInput
  }

  /**
   * PollOption findUniqueOrThrow
   */
  export type PollOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * Filter, which PollOption to fetch.
     */
    where: PollOptionWhereUniqueInput
  }

  /**
   * PollOption findFirst
   */
  export type PollOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * Filter, which PollOption to fetch.
     */
    where?: PollOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollOptions to fetch.
     */
    orderBy?: PollOptionOrderByWithRelationInput | PollOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollOptions.
     */
    cursor?: PollOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollOptions.
     */
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[]
  }

  /**
   * PollOption findFirstOrThrow
   */
  export type PollOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * Filter, which PollOption to fetch.
     */
    where?: PollOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollOptions to fetch.
     */
    orderBy?: PollOptionOrderByWithRelationInput | PollOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollOptions.
     */
    cursor?: PollOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollOptions.
     */
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[]
  }

  /**
   * PollOption findMany
   */
  export type PollOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * Filter, which PollOptions to fetch.
     */
    where?: PollOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollOptions to fetch.
     */
    orderBy?: PollOptionOrderByWithRelationInput | PollOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PollOptions.
     */
    cursor?: PollOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollOptions.
     */
    skip?: number
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[]
  }

  /**
   * PollOption create
   */
  export type PollOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PollOption.
     */
    data: XOR<PollOptionCreateInput, PollOptionUncheckedCreateInput>
  }

  /**
   * PollOption createMany
   */
  export type PollOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PollOptions.
     */
    data: PollOptionCreateManyInput | PollOptionCreateManyInput[]
  }

  /**
   * PollOption createManyAndReturn
   */
  export type PollOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * The data used to create many PollOptions.
     */
    data: PollOptionCreateManyInput | PollOptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollOption update
   */
  export type PollOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PollOption.
     */
    data: XOR<PollOptionUpdateInput, PollOptionUncheckedUpdateInput>
    /**
     * Choose, which PollOption to update.
     */
    where: PollOptionWhereUniqueInput
  }

  /**
   * PollOption updateMany
   */
  export type PollOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PollOptions.
     */
    data: XOR<PollOptionUpdateManyMutationInput, PollOptionUncheckedUpdateManyInput>
    /**
     * Filter which PollOptions to update
     */
    where?: PollOptionWhereInput
    /**
     * Limit how many PollOptions to update.
     */
    limit?: number
  }

  /**
   * PollOption updateManyAndReturn
   */
  export type PollOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * The data used to update PollOptions.
     */
    data: XOR<PollOptionUpdateManyMutationInput, PollOptionUncheckedUpdateManyInput>
    /**
     * Filter which PollOptions to update
     */
    where?: PollOptionWhereInput
    /**
     * Limit how many PollOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollOption upsert
   */
  export type PollOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PollOption to update in case it exists.
     */
    where: PollOptionWhereUniqueInput
    /**
     * In case the PollOption found by the `where` argument doesn't exist, create a new PollOption with this data.
     */
    create: XOR<PollOptionCreateInput, PollOptionUncheckedCreateInput>
    /**
     * In case the PollOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollOptionUpdateInput, PollOptionUncheckedUpdateInput>
  }

  /**
   * PollOption delete
   */
  export type PollOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
    /**
     * Filter which PollOption to delete.
     */
    where: PollOptionWhereUniqueInput
  }

  /**
   * PollOption deleteMany
   */
  export type PollOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollOptions to delete
     */
    where?: PollOptionWhereInput
    /**
     * Limit how many PollOptions to delete.
     */
    limit?: number
  }

  /**
   * PollOption.book
   */
  export type PollOption$bookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
  }

  /**
   * PollOption.votes
   */
  export type PollOption$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    cursor?: PollVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollOption without action
   */
  export type PollOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null
  }


  /**
   * Model PollVote
   */

  export type AggregatePollVote = {
    _count: PollVoteCountAggregateOutputType | null
    _min: PollVoteMinAggregateOutputType | null
    _max: PollVoteMaxAggregateOutputType | null
  }

  export type PollVoteMinAggregateOutputType = {
    id: string | null
    pollId: string | null
    optionId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PollVoteMaxAggregateOutputType = {
    id: string | null
    pollId: string | null
    optionId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PollVoteCountAggregateOutputType = {
    id: number
    pollId: number
    optionId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PollVoteMinAggregateInputType = {
    id?: true
    pollId?: true
    optionId?: true
    userId?: true
    createdAt?: true
  }

  export type PollVoteMaxAggregateInputType = {
    id?: true
    pollId?: true
    optionId?: true
    userId?: true
    createdAt?: true
  }

  export type PollVoteCountAggregateInputType = {
    id?: true
    pollId?: true
    optionId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PollVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollVote to aggregate.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PollVotes
    **/
    _count?: true | PollVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollVoteMaxAggregateInputType
  }

  export type GetPollVoteAggregateType<T extends PollVoteAggregateArgs> = {
        [P in keyof T & keyof AggregatePollVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollVote[P]>
      : GetScalarType<T[P], AggregatePollVote[P]>
  }




  export type PollVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithAggregationInput | PollVoteOrderByWithAggregationInput[]
    by: PollVoteScalarFieldEnum[] | PollVoteScalarFieldEnum
    having?: PollVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollVoteCountAggregateInputType | true
    _min?: PollVoteMinAggregateInputType
    _max?: PollVoteMaxAggregateInputType
  }

  export type PollVoteGroupByOutputType = {
    id: string
    pollId: string
    optionId: string
    userId: string
    createdAt: Date
    _count: PollVoteCountAggregateOutputType | null
    _min: PollVoteMinAggregateOutputType | null
    _max: PollVoteMaxAggregateOutputType | null
  }

  type GetPollVoteGroupByPayload<T extends PollVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollVoteGroupByOutputType[P]>
            : GetScalarType<T[P], PollVoteGroupByOutputType[P]>
        }
      >
    >


  export type PollVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    optionId?: boolean
    userId?: boolean
    createdAt?: boolean
    poll?: boolean | PollDefaultArgs<ExtArgs>
    option?: boolean | PollOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    optionId?: boolean
    userId?: boolean
    createdAt?: boolean
    poll?: boolean | PollDefaultArgs<ExtArgs>
    option?: boolean | PollOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    optionId?: boolean
    userId?: boolean
    createdAt?: boolean
    poll?: boolean | PollDefaultArgs<ExtArgs>
    option?: boolean | PollOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectScalar = {
    id?: boolean
    pollId?: boolean
    optionId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PollVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pollId" | "optionId" | "userId" | "createdAt", ExtArgs["result"]["pollVote"]>
  export type PollVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | PollDefaultArgs<ExtArgs>
    option?: boolean | PollOptionDefaultArgs<ExtArgs>
  }
  export type PollVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | PollDefaultArgs<ExtArgs>
    option?: boolean | PollOptionDefaultArgs<ExtArgs>
  }
  export type PollVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | PollDefaultArgs<ExtArgs>
    option?: boolean | PollOptionDefaultArgs<ExtArgs>
  }

  export type $PollVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PollVote"
    objects: {
      poll: Prisma.$PollPayload<ExtArgs>
      option: Prisma.$PollOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pollId: string
      optionId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["pollVote"]>
    composites: {}
  }

  type PollVoteGetPayload<S extends boolean | null | undefined | PollVoteDefaultArgs> = $Result.GetResult<Prisma.$PollVotePayload, S>

  type PollVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PollVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PollVoteCountAggregateInputType | true
    }

  export interface PollVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PollVote'], meta: { name: 'PollVote' } }
    /**
     * Find zero or one PollVote that matches the filter.
     * @param {PollVoteFindUniqueArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollVoteFindUniqueArgs>(args: SelectSubset<T, PollVoteFindUniqueArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PollVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollVoteFindUniqueOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, PollVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PollVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollVoteFindFirstArgs>(args?: SelectSubset<T, PollVoteFindFirstArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PollVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, PollVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PollVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollVotes
     * const pollVotes = await prisma.pollVote.findMany()
     * 
     * // Get first 10 PollVotes
     * const pollVotes = await prisma.pollVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PollVoteFindManyArgs>(args?: SelectSubset<T, PollVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PollVote.
     * @param {PollVoteCreateArgs} args - Arguments to create a PollVote.
     * @example
     * // Create one PollVote
     * const PollVote = await prisma.pollVote.create({
     *   data: {
     *     // ... data to create a PollVote
     *   }
     * })
     * 
     */
    create<T extends PollVoteCreateArgs>(args: SelectSubset<T, PollVoteCreateArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PollVotes.
     * @param {PollVoteCreateManyArgs} args - Arguments to create many PollVotes.
     * @example
     * // Create many PollVotes
     * const pollVote = await prisma.pollVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollVoteCreateManyArgs>(args?: SelectSubset<T, PollVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PollVotes and returns the data saved in the database.
     * @param {PollVoteCreateManyAndReturnArgs} args - Arguments to create many PollVotes.
     * @example
     * // Create many PollVotes
     * const pollVote = await prisma.pollVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PollVotes and only return the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PollVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, PollVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PollVote.
     * @param {PollVoteDeleteArgs} args - Arguments to delete one PollVote.
     * @example
     * // Delete one PollVote
     * const PollVote = await prisma.pollVote.delete({
     *   where: {
     *     // ... filter to delete one PollVote
     *   }
     * })
     * 
     */
    delete<T extends PollVoteDeleteArgs>(args: SelectSubset<T, PollVoteDeleteArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PollVote.
     * @param {PollVoteUpdateArgs} args - Arguments to update one PollVote.
     * @example
     * // Update one PollVote
     * const pollVote = await prisma.pollVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollVoteUpdateArgs>(args: SelectSubset<T, PollVoteUpdateArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PollVotes.
     * @param {PollVoteDeleteManyArgs} args - Arguments to filter PollVotes to delete.
     * @example
     * // Delete a few PollVotes
     * const { count } = await prisma.pollVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollVoteDeleteManyArgs>(args?: SelectSubset<T, PollVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollVotes
     * const pollVote = await prisma.pollVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollVoteUpdateManyArgs>(args: SelectSubset<T, PollVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollVotes and returns the data updated in the database.
     * @param {PollVoteUpdateManyAndReturnArgs} args - Arguments to update many PollVotes.
     * @example
     * // Update many PollVotes
     * const pollVote = await prisma.pollVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PollVotes and only return the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PollVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, PollVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PollVote.
     * @param {PollVoteUpsertArgs} args - Arguments to update or create a PollVote.
     * @example
     * // Update or create a PollVote
     * const pollVote = await prisma.pollVote.upsert({
     *   create: {
     *     // ... data to create a PollVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollVote we want to update
     *   }
     * })
     */
    upsert<T extends PollVoteUpsertArgs>(args: SelectSubset<T, PollVoteUpsertArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteCountArgs} args - Arguments to filter PollVotes to count.
     * @example
     * // Count the number of PollVotes
     * const count = await prisma.pollVote.count({
     *   where: {
     *     // ... the filter for the PollVotes we want to count
     *   }
     * })
    **/
    count<T extends PollVoteCountArgs>(
      args?: Subset<T, PollVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollVoteAggregateArgs>(args: Subset<T, PollVoteAggregateArgs>): Prisma.PrismaPromise<GetPollVoteAggregateType<T>>

    /**
     * Group by PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollVoteGroupByArgs['orderBy'] }
        : { orderBy?: PollVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PollVote model
   */
  readonly fields: PollVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poll<T extends PollDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PollDefaultArgs<ExtArgs>>): Prisma__PollClient<$Result.GetResult<Prisma.$PollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends PollOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PollOptionDefaultArgs<ExtArgs>>): Prisma__PollOptionClient<$Result.GetResult<Prisma.$PollOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PollVote model
   */
  interface PollVoteFieldRefs {
    readonly id: FieldRef<"PollVote", 'String'>
    readonly pollId: FieldRef<"PollVote", 'String'>
    readonly optionId: FieldRef<"PollVote", 'String'>
    readonly userId: FieldRef<"PollVote", 'String'>
    readonly createdAt: FieldRef<"PollVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PollVote findUnique
   */
  export type PollVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote findUniqueOrThrow
   */
  export type PollVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote findFirst
   */
  export type PollVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote findFirstOrThrow
   */
  export type PollVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote findMany
   */
  export type PollVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVotes to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote create
   */
  export type PollVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a PollVote.
     */
    data: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>
  }

  /**
   * PollVote createMany
   */
  export type PollVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PollVotes.
     */
    data: PollVoteCreateManyInput | PollVoteCreateManyInput[]
  }

  /**
   * PollVote createManyAndReturn
   */
  export type PollVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * The data used to create many PollVotes.
     */
    data: PollVoteCreateManyInput | PollVoteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollVote update
   */
  export type PollVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a PollVote.
     */
    data: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>
    /**
     * Choose, which PollVote to update.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote updateMany
   */
  export type PollVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PollVotes.
     */
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyInput>
    /**
     * Filter which PollVotes to update
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to update.
     */
    limit?: number
  }

  /**
   * PollVote updateManyAndReturn
   */
  export type PollVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * The data used to update PollVotes.
     */
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyInput>
    /**
     * Filter which PollVotes to update
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollVote upsert
   */
  export type PollVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the PollVote to update in case it exists.
     */
    where: PollVoteWhereUniqueInput
    /**
     * In case the PollVote found by the `where` argument doesn't exist, create a new PollVote with this data.
     */
    create: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>
    /**
     * In case the PollVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>
  }

  /**
   * PollVote delete
   */
  export type PollVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter which PollVote to delete.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote deleteMany
   */
  export type PollVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollVotes to delete
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to delete.
     */
    limit?: number
  }

  /**
   * PollVote without action
   */
  export type PollVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
  }


  /**
   * Model ClubEvent
   */

  export type AggregateClubEvent = {
    _count: ClubEventCountAggregateOutputType | null
    _avg: ClubEventAvgAggregateOutputType | null
    _sum: ClubEventSumAggregateOutputType | null
    _min: ClubEventMinAggregateOutputType | null
    _max: ClubEventMaxAggregateOutputType | null
  }

  export type ClubEventAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type ClubEventSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type ClubEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    city: string | null
    location: string | null
    addressStreet: string | null
    addressNumber: string | null
    addressDistrict: string | null
    addressCity: string | null
    addressState: string | null
    addressZip: string | null
    latitude: number | null
    longitude: number | null
    startAt: Date | null
    endAt: Date | null
    clubBookId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ClubEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    city: string | null
    location: string | null
    addressStreet: string | null
    addressNumber: string | null
    addressDistrict: string | null
    addressCity: string | null
    addressState: string | null
    addressZip: string | null
    latitude: number | null
    longitude: number | null
    startAt: Date | null
    endAt: Date | null
    clubBookId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ClubEventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    city: number
    location: number
    addressStreet: number
    addressNumber: number
    addressDistrict: number
    addressCity: number
    addressState: number
    addressZip: number
    latitude: number
    longitude: number
    startAt: number
    endAt: number
    clubBookId: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type ClubEventAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type ClubEventSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type ClubEventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    city?: true
    location?: true
    addressStreet?: true
    addressNumber?: true
    addressDistrict?: true
    addressCity?: true
    addressState?: true
    addressZip?: true
    latitude?: true
    longitude?: true
    startAt?: true
    endAt?: true
    clubBookId?: true
    createdById?: true
    createdAt?: true
  }

  export type ClubEventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    city?: true
    location?: true
    addressStreet?: true
    addressNumber?: true
    addressDistrict?: true
    addressCity?: true
    addressState?: true
    addressZip?: true
    latitude?: true
    longitude?: true
    startAt?: true
    endAt?: true
    clubBookId?: true
    createdById?: true
    createdAt?: true
  }

  export type ClubEventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    city?: true
    location?: true
    addressStreet?: true
    addressNumber?: true
    addressDistrict?: true
    addressCity?: true
    addressState?: true
    addressZip?: true
    latitude?: true
    longitude?: true
    startAt?: true
    endAt?: true
    clubBookId?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type ClubEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubEvent to aggregate.
     */
    where?: ClubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEvents to fetch.
     */
    orderBy?: ClubEventOrderByWithRelationInput | ClubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubEvents
    **/
    _count?: true | ClubEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClubEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClubEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubEventMaxAggregateInputType
  }

  export type GetClubEventAggregateType<T extends ClubEventAggregateArgs> = {
        [P in keyof T & keyof AggregateClubEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubEvent[P]>
      : GetScalarType<T[P], AggregateClubEvent[P]>
  }




  export type ClubEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubEventWhereInput
    orderBy?: ClubEventOrderByWithAggregationInput | ClubEventOrderByWithAggregationInput[]
    by: ClubEventScalarFieldEnum[] | ClubEventScalarFieldEnum
    having?: ClubEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubEventCountAggregateInputType | true
    _avg?: ClubEventAvgAggregateInputType
    _sum?: ClubEventSumAggregateInputType
    _min?: ClubEventMinAggregateInputType
    _max?: ClubEventMaxAggregateInputType
  }

  export type ClubEventGroupByOutputType = {
    id: string
    title: string
    description: string
    city: string
    location: string
    addressStreet: string | null
    addressNumber: string | null
    addressDistrict: string | null
    addressCity: string | null
    addressState: string | null
    addressZip: string | null
    latitude: number | null
    longitude: number | null
    startAt: Date
    endAt: Date | null
    clubBookId: string | null
    createdById: string
    createdAt: Date
    _count: ClubEventCountAggregateOutputType | null
    _avg: ClubEventAvgAggregateOutputType | null
    _sum: ClubEventSumAggregateOutputType | null
    _min: ClubEventMinAggregateOutputType | null
    _max: ClubEventMaxAggregateOutputType | null
  }

  type GetClubEventGroupByPayload<T extends ClubEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubEventGroupByOutputType[P]>
            : GetScalarType<T[P], ClubEventGroupByOutputType[P]>
        }
      >
    >


  export type ClubEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    city?: boolean
    location?: boolean
    addressStreet?: boolean
    addressNumber?: boolean
    addressDistrict?: boolean
    addressCity?: boolean
    addressState?: boolean
    addressZip?: boolean
    latitude?: boolean
    longitude?: boolean
    startAt?: boolean
    endAt?: boolean
    clubBookId?: boolean
    createdById?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubEvent$clubBookArgs<ExtArgs>
    participants?: boolean | ClubEvent$participantsArgs<ExtArgs>
    photos?: boolean | ClubEvent$photosArgs<ExtArgs>
    _count?: boolean | ClubEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubEvent"]>

  export type ClubEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    city?: boolean
    location?: boolean
    addressStreet?: boolean
    addressNumber?: boolean
    addressDistrict?: boolean
    addressCity?: boolean
    addressState?: boolean
    addressZip?: boolean
    latitude?: boolean
    longitude?: boolean
    startAt?: boolean
    endAt?: boolean
    clubBookId?: boolean
    createdById?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubEvent$clubBookArgs<ExtArgs>
  }, ExtArgs["result"]["clubEvent"]>

  export type ClubEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    city?: boolean
    location?: boolean
    addressStreet?: boolean
    addressNumber?: boolean
    addressDistrict?: boolean
    addressCity?: boolean
    addressState?: boolean
    addressZip?: boolean
    latitude?: boolean
    longitude?: boolean
    startAt?: boolean
    endAt?: boolean
    clubBookId?: boolean
    createdById?: boolean
    createdAt?: boolean
    clubBook?: boolean | ClubEvent$clubBookArgs<ExtArgs>
  }, ExtArgs["result"]["clubEvent"]>

  export type ClubEventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    city?: boolean
    location?: boolean
    addressStreet?: boolean
    addressNumber?: boolean
    addressDistrict?: boolean
    addressCity?: boolean
    addressState?: boolean
    addressZip?: boolean
    latitude?: boolean
    longitude?: boolean
    startAt?: boolean
    endAt?: boolean
    clubBookId?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type ClubEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "city" | "location" | "addressStreet" | "addressNumber" | "addressDistrict" | "addressCity" | "addressState" | "addressZip" | "latitude" | "longitude" | "startAt" | "endAt" | "clubBookId" | "createdById" | "createdAt", ExtArgs["result"]["clubEvent"]>
  export type ClubEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubEvent$clubBookArgs<ExtArgs>
    participants?: boolean | ClubEvent$participantsArgs<ExtArgs>
    photos?: boolean | ClubEvent$photosArgs<ExtArgs>
    _count?: boolean | ClubEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClubEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubEvent$clubBookArgs<ExtArgs>
  }
  export type ClubEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubBook?: boolean | ClubEvent$clubBookArgs<ExtArgs>
  }

  export type $ClubEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubEvent"
    objects: {
      clubBook: Prisma.$ClubBookPayload<ExtArgs> | null
      participants: Prisma.$ClubEventParticipantPayload<ExtArgs>[]
      photos: Prisma.$ClubEventPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      city: string
      location: string
      addressStreet: string | null
      addressNumber: string | null
      addressDistrict: string | null
      addressCity: string | null
      addressState: string | null
      addressZip: string | null
      latitude: number | null
      longitude: number | null
      startAt: Date
      endAt: Date | null
      clubBookId: string | null
      createdById: string
      createdAt: Date
    }, ExtArgs["result"]["clubEvent"]>
    composites: {}
  }

  type ClubEventGetPayload<S extends boolean | null | undefined | ClubEventDefaultArgs> = $Result.GetResult<Prisma.$ClubEventPayload, S>

  type ClubEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubEventCountAggregateInputType | true
    }

  export interface ClubEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubEvent'], meta: { name: 'ClubEvent' } }
    /**
     * Find zero or one ClubEvent that matches the filter.
     * @param {ClubEventFindUniqueArgs} args - Arguments to find a ClubEvent
     * @example
     * // Get one ClubEvent
     * const clubEvent = await prisma.clubEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubEventFindUniqueArgs>(args: SelectSubset<T, ClubEventFindUniqueArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubEventFindUniqueOrThrowArgs} args - Arguments to find a ClubEvent
     * @example
     * // Get one ClubEvent
     * const clubEvent = await prisma.clubEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventFindFirstArgs} args - Arguments to find a ClubEvent
     * @example
     * // Get one ClubEvent
     * const clubEvent = await prisma.clubEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubEventFindFirstArgs>(args?: SelectSubset<T, ClubEventFindFirstArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventFindFirstOrThrowArgs} args - Arguments to find a ClubEvent
     * @example
     * // Get one ClubEvent
     * const clubEvent = await prisma.clubEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubEvents
     * const clubEvents = await prisma.clubEvent.findMany()
     * 
     * // Get first 10 ClubEvents
     * const clubEvents = await prisma.clubEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubEventWithIdOnly = await prisma.clubEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubEventFindManyArgs>(args?: SelectSubset<T, ClubEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubEvent.
     * @param {ClubEventCreateArgs} args - Arguments to create a ClubEvent.
     * @example
     * // Create one ClubEvent
     * const ClubEvent = await prisma.clubEvent.create({
     *   data: {
     *     // ... data to create a ClubEvent
     *   }
     * })
     * 
     */
    create<T extends ClubEventCreateArgs>(args: SelectSubset<T, ClubEventCreateArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubEvents.
     * @param {ClubEventCreateManyArgs} args - Arguments to create many ClubEvents.
     * @example
     * // Create many ClubEvents
     * const clubEvent = await prisma.clubEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubEventCreateManyArgs>(args?: SelectSubset<T, ClubEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubEvents and returns the data saved in the database.
     * @param {ClubEventCreateManyAndReturnArgs} args - Arguments to create many ClubEvents.
     * @example
     * // Create many ClubEvents
     * const clubEvent = await prisma.clubEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubEvents and only return the `id`
     * const clubEventWithIdOnly = await prisma.clubEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubEvent.
     * @param {ClubEventDeleteArgs} args - Arguments to delete one ClubEvent.
     * @example
     * // Delete one ClubEvent
     * const ClubEvent = await prisma.clubEvent.delete({
     *   where: {
     *     // ... filter to delete one ClubEvent
     *   }
     * })
     * 
     */
    delete<T extends ClubEventDeleteArgs>(args: SelectSubset<T, ClubEventDeleteArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubEvent.
     * @param {ClubEventUpdateArgs} args - Arguments to update one ClubEvent.
     * @example
     * // Update one ClubEvent
     * const clubEvent = await prisma.clubEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubEventUpdateArgs>(args: SelectSubset<T, ClubEventUpdateArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubEvents.
     * @param {ClubEventDeleteManyArgs} args - Arguments to filter ClubEvents to delete.
     * @example
     * // Delete a few ClubEvents
     * const { count } = await prisma.clubEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubEventDeleteManyArgs>(args?: SelectSubset<T, ClubEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubEvents
     * const clubEvent = await prisma.clubEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubEventUpdateManyArgs>(args: SelectSubset<T, ClubEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubEvents and returns the data updated in the database.
     * @param {ClubEventUpdateManyAndReturnArgs} args - Arguments to update many ClubEvents.
     * @example
     * // Update many ClubEvents
     * const clubEvent = await prisma.clubEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubEvents and only return the `id`
     * const clubEventWithIdOnly = await prisma.clubEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubEventUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubEvent.
     * @param {ClubEventUpsertArgs} args - Arguments to update or create a ClubEvent.
     * @example
     * // Update or create a ClubEvent
     * const clubEvent = await prisma.clubEvent.upsert({
     *   create: {
     *     // ... data to create a ClubEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubEvent we want to update
     *   }
     * })
     */
    upsert<T extends ClubEventUpsertArgs>(args: SelectSubset<T, ClubEventUpsertArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventCountArgs} args - Arguments to filter ClubEvents to count.
     * @example
     * // Count the number of ClubEvents
     * const count = await prisma.clubEvent.count({
     *   where: {
     *     // ... the filter for the ClubEvents we want to count
     *   }
     * })
    **/
    count<T extends ClubEventCountArgs>(
      args?: Subset<T, ClubEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubEventAggregateArgs>(args: Subset<T, ClubEventAggregateArgs>): Prisma.PrismaPromise<GetClubEventAggregateType<T>>

    /**
     * Group by ClubEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubEventGroupByArgs['orderBy'] }
        : { orderBy?: ClubEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubEvent model
   */
  readonly fields: ClubEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clubBook<T extends ClubEvent$clubBookArgs<ExtArgs> = {}>(args?: Subset<T, ClubEvent$clubBookArgs<ExtArgs>>): Prisma__ClubBookClient<$Result.GetResult<Prisma.$ClubBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends ClubEvent$participantsArgs<ExtArgs> = {}>(args?: Subset<T, ClubEvent$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends ClubEvent$photosArgs<ExtArgs> = {}>(args?: Subset<T, ClubEvent$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubEvent model
   */
  interface ClubEventFieldRefs {
    readonly id: FieldRef<"ClubEvent", 'String'>
    readonly title: FieldRef<"ClubEvent", 'String'>
    readonly description: FieldRef<"ClubEvent", 'String'>
    readonly city: FieldRef<"ClubEvent", 'String'>
    readonly location: FieldRef<"ClubEvent", 'String'>
    readonly addressStreet: FieldRef<"ClubEvent", 'String'>
    readonly addressNumber: FieldRef<"ClubEvent", 'String'>
    readonly addressDistrict: FieldRef<"ClubEvent", 'String'>
    readonly addressCity: FieldRef<"ClubEvent", 'String'>
    readonly addressState: FieldRef<"ClubEvent", 'String'>
    readonly addressZip: FieldRef<"ClubEvent", 'String'>
    readonly latitude: FieldRef<"ClubEvent", 'Float'>
    readonly longitude: FieldRef<"ClubEvent", 'Float'>
    readonly startAt: FieldRef<"ClubEvent", 'DateTime'>
    readonly endAt: FieldRef<"ClubEvent", 'DateTime'>
    readonly clubBookId: FieldRef<"ClubEvent", 'String'>
    readonly createdById: FieldRef<"ClubEvent", 'String'>
    readonly createdAt: FieldRef<"ClubEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubEvent findUnique
   */
  export type ClubEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * Filter, which ClubEvent to fetch.
     */
    where: ClubEventWhereUniqueInput
  }

  /**
   * ClubEvent findUniqueOrThrow
   */
  export type ClubEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * Filter, which ClubEvent to fetch.
     */
    where: ClubEventWhereUniqueInput
  }

  /**
   * ClubEvent findFirst
   */
  export type ClubEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * Filter, which ClubEvent to fetch.
     */
    where?: ClubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEvents to fetch.
     */
    orderBy?: ClubEventOrderByWithRelationInput | ClubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubEvents.
     */
    cursor?: ClubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubEvents.
     */
    distinct?: ClubEventScalarFieldEnum | ClubEventScalarFieldEnum[]
  }

  /**
   * ClubEvent findFirstOrThrow
   */
  export type ClubEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * Filter, which ClubEvent to fetch.
     */
    where?: ClubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEvents to fetch.
     */
    orderBy?: ClubEventOrderByWithRelationInput | ClubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubEvents.
     */
    cursor?: ClubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubEvents.
     */
    distinct?: ClubEventScalarFieldEnum | ClubEventScalarFieldEnum[]
  }

  /**
   * ClubEvent findMany
   */
  export type ClubEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * Filter, which ClubEvents to fetch.
     */
    where?: ClubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEvents to fetch.
     */
    orderBy?: ClubEventOrderByWithRelationInput | ClubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubEvents.
     */
    cursor?: ClubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEvents.
     */
    skip?: number
    distinct?: ClubEventScalarFieldEnum | ClubEventScalarFieldEnum[]
  }

  /**
   * ClubEvent create
   */
  export type ClubEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubEvent.
     */
    data: XOR<ClubEventCreateInput, ClubEventUncheckedCreateInput>
  }

  /**
   * ClubEvent createMany
   */
  export type ClubEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubEvents.
     */
    data: ClubEventCreateManyInput | ClubEventCreateManyInput[]
  }

  /**
   * ClubEvent createManyAndReturn
   */
  export type ClubEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * The data used to create many ClubEvents.
     */
    data: ClubEventCreateManyInput | ClubEventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubEvent update
   */
  export type ClubEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubEvent.
     */
    data: XOR<ClubEventUpdateInput, ClubEventUncheckedUpdateInput>
    /**
     * Choose, which ClubEvent to update.
     */
    where: ClubEventWhereUniqueInput
  }

  /**
   * ClubEvent updateMany
   */
  export type ClubEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubEvents.
     */
    data: XOR<ClubEventUpdateManyMutationInput, ClubEventUncheckedUpdateManyInput>
    /**
     * Filter which ClubEvents to update
     */
    where?: ClubEventWhereInput
    /**
     * Limit how many ClubEvents to update.
     */
    limit?: number
  }

  /**
   * ClubEvent updateManyAndReturn
   */
  export type ClubEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * The data used to update ClubEvents.
     */
    data: XOR<ClubEventUpdateManyMutationInput, ClubEventUncheckedUpdateManyInput>
    /**
     * Filter which ClubEvents to update
     */
    where?: ClubEventWhereInput
    /**
     * Limit how many ClubEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubEvent upsert
   */
  export type ClubEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubEvent to update in case it exists.
     */
    where: ClubEventWhereUniqueInput
    /**
     * In case the ClubEvent found by the `where` argument doesn't exist, create a new ClubEvent with this data.
     */
    create: XOR<ClubEventCreateInput, ClubEventUncheckedCreateInput>
    /**
     * In case the ClubEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubEventUpdateInput, ClubEventUncheckedUpdateInput>
  }

  /**
   * ClubEvent delete
   */
  export type ClubEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
    /**
     * Filter which ClubEvent to delete.
     */
    where: ClubEventWhereUniqueInput
  }

  /**
   * ClubEvent deleteMany
   */
  export type ClubEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubEvents to delete
     */
    where?: ClubEventWhereInput
    /**
     * Limit how many ClubEvents to delete.
     */
    limit?: number
  }

  /**
   * ClubEvent.clubBook
   */
  export type ClubEvent$clubBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubBook
     */
    select?: ClubBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubBook
     */
    omit?: ClubBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubBookInclude<ExtArgs> | null
    where?: ClubBookWhereInput
  }

  /**
   * ClubEvent.participants
   */
  export type ClubEvent$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    where?: ClubEventParticipantWhereInput
    orderBy?: ClubEventParticipantOrderByWithRelationInput | ClubEventParticipantOrderByWithRelationInput[]
    cursor?: ClubEventParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubEventParticipantScalarFieldEnum | ClubEventParticipantScalarFieldEnum[]
  }

  /**
   * ClubEvent.photos
   */
  export type ClubEvent$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    where?: ClubEventPhotoWhereInput
    orderBy?: ClubEventPhotoOrderByWithRelationInput | ClubEventPhotoOrderByWithRelationInput[]
    cursor?: ClubEventPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubEventPhotoScalarFieldEnum | ClubEventPhotoScalarFieldEnum[]
  }

  /**
   * ClubEvent without action
   */
  export type ClubEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEvent
     */
    select?: ClubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEvent
     */
    omit?: ClubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventInclude<ExtArgs> | null
  }


  /**
   * Model ClubEventParticipant
   */

  export type AggregateClubEventParticipant = {
    _count: ClubEventParticipantCountAggregateOutputType | null
    _min: ClubEventParticipantMinAggregateOutputType | null
    _max: ClubEventParticipantMaxAggregateOutputType | null
  }

  export type ClubEventParticipantMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClubEventParticipantMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClubEventParticipantCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    status: number
    createdAt: number
    _all: number
  }


  export type ClubEventParticipantMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type ClubEventParticipantMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type ClubEventParticipantCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ClubEventParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubEventParticipant to aggregate.
     */
    where?: ClubEventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventParticipants to fetch.
     */
    orderBy?: ClubEventParticipantOrderByWithRelationInput | ClubEventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubEventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubEventParticipants
    **/
    _count?: true | ClubEventParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubEventParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubEventParticipantMaxAggregateInputType
  }

  export type GetClubEventParticipantAggregateType<T extends ClubEventParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateClubEventParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubEventParticipant[P]>
      : GetScalarType<T[P], AggregateClubEventParticipant[P]>
  }




  export type ClubEventParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubEventParticipantWhereInput
    orderBy?: ClubEventParticipantOrderByWithAggregationInput | ClubEventParticipantOrderByWithAggregationInput[]
    by: ClubEventParticipantScalarFieldEnum[] | ClubEventParticipantScalarFieldEnum
    having?: ClubEventParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubEventParticipantCountAggregateInputType | true
    _min?: ClubEventParticipantMinAggregateInputType
    _max?: ClubEventParticipantMaxAggregateInputType
  }

  export type ClubEventParticipantGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    status: string
    createdAt: Date
    _count: ClubEventParticipantCountAggregateOutputType | null
    _min: ClubEventParticipantMinAggregateOutputType | null
    _max: ClubEventParticipantMaxAggregateOutputType | null
  }

  type GetClubEventParticipantGroupByPayload<T extends ClubEventParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubEventParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubEventParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubEventParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ClubEventParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ClubEventParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubEventParticipant"]>

  export type ClubEventParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubEventParticipant"]>

  export type ClubEventParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubEventParticipant"]>

  export type ClubEventParticipantSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ClubEventParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "status" | "createdAt", ExtArgs["result"]["clubEventParticipant"]>
  export type ClubEventParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
  }
  export type ClubEventParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
  }
  export type ClubEventParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
  }

  export type $ClubEventParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubEventParticipant"
    objects: {
      event: Prisma.$ClubEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["clubEventParticipant"]>
    composites: {}
  }

  type ClubEventParticipantGetPayload<S extends boolean | null | undefined | ClubEventParticipantDefaultArgs> = $Result.GetResult<Prisma.$ClubEventParticipantPayload, S>

  type ClubEventParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubEventParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubEventParticipantCountAggregateInputType | true
    }

  export interface ClubEventParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubEventParticipant'], meta: { name: 'ClubEventParticipant' } }
    /**
     * Find zero or one ClubEventParticipant that matches the filter.
     * @param {ClubEventParticipantFindUniqueArgs} args - Arguments to find a ClubEventParticipant
     * @example
     * // Get one ClubEventParticipant
     * const clubEventParticipant = await prisma.clubEventParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubEventParticipantFindUniqueArgs>(args: SelectSubset<T, ClubEventParticipantFindUniqueArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubEventParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubEventParticipantFindUniqueOrThrowArgs} args - Arguments to find a ClubEventParticipant
     * @example
     * // Get one ClubEventParticipant
     * const clubEventParticipant = await prisma.clubEventParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubEventParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubEventParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubEventParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventParticipantFindFirstArgs} args - Arguments to find a ClubEventParticipant
     * @example
     * // Get one ClubEventParticipant
     * const clubEventParticipant = await prisma.clubEventParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubEventParticipantFindFirstArgs>(args?: SelectSubset<T, ClubEventParticipantFindFirstArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubEventParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventParticipantFindFirstOrThrowArgs} args - Arguments to find a ClubEventParticipant
     * @example
     * // Get one ClubEventParticipant
     * const clubEventParticipant = await prisma.clubEventParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubEventParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubEventParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubEventParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubEventParticipants
     * const clubEventParticipants = await prisma.clubEventParticipant.findMany()
     * 
     * // Get first 10 ClubEventParticipants
     * const clubEventParticipants = await prisma.clubEventParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubEventParticipantWithIdOnly = await prisma.clubEventParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubEventParticipantFindManyArgs>(args?: SelectSubset<T, ClubEventParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubEventParticipant.
     * @param {ClubEventParticipantCreateArgs} args - Arguments to create a ClubEventParticipant.
     * @example
     * // Create one ClubEventParticipant
     * const ClubEventParticipant = await prisma.clubEventParticipant.create({
     *   data: {
     *     // ... data to create a ClubEventParticipant
     *   }
     * })
     * 
     */
    create<T extends ClubEventParticipantCreateArgs>(args: SelectSubset<T, ClubEventParticipantCreateArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubEventParticipants.
     * @param {ClubEventParticipantCreateManyArgs} args - Arguments to create many ClubEventParticipants.
     * @example
     * // Create many ClubEventParticipants
     * const clubEventParticipant = await prisma.clubEventParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubEventParticipantCreateManyArgs>(args?: SelectSubset<T, ClubEventParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubEventParticipants and returns the data saved in the database.
     * @param {ClubEventParticipantCreateManyAndReturnArgs} args - Arguments to create many ClubEventParticipants.
     * @example
     * // Create many ClubEventParticipants
     * const clubEventParticipant = await prisma.clubEventParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubEventParticipants and only return the `id`
     * const clubEventParticipantWithIdOnly = await prisma.clubEventParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubEventParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubEventParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubEventParticipant.
     * @param {ClubEventParticipantDeleteArgs} args - Arguments to delete one ClubEventParticipant.
     * @example
     * // Delete one ClubEventParticipant
     * const ClubEventParticipant = await prisma.clubEventParticipant.delete({
     *   where: {
     *     // ... filter to delete one ClubEventParticipant
     *   }
     * })
     * 
     */
    delete<T extends ClubEventParticipantDeleteArgs>(args: SelectSubset<T, ClubEventParticipantDeleteArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubEventParticipant.
     * @param {ClubEventParticipantUpdateArgs} args - Arguments to update one ClubEventParticipant.
     * @example
     * // Update one ClubEventParticipant
     * const clubEventParticipant = await prisma.clubEventParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubEventParticipantUpdateArgs>(args: SelectSubset<T, ClubEventParticipantUpdateArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubEventParticipants.
     * @param {ClubEventParticipantDeleteManyArgs} args - Arguments to filter ClubEventParticipants to delete.
     * @example
     * // Delete a few ClubEventParticipants
     * const { count } = await prisma.clubEventParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubEventParticipantDeleteManyArgs>(args?: SelectSubset<T, ClubEventParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubEventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubEventParticipants
     * const clubEventParticipant = await prisma.clubEventParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubEventParticipantUpdateManyArgs>(args: SelectSubset<T, ClubEventParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubEventParticipants and returns the data updated in the database.
     * @param {ClubEventParticipantUpdateManyAndReturnArgs} args - Arguments to update many ClubEventParticipants.
     * @example
     * // Update many ClubEventParticipants
     * const clubEventParticipant = await prisma.clubEventParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubEventParticipants and only return the `id`
     * const clubEventParticipantWithIdOnly = await prisma.clubEventParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubEventParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubEventParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubEventParticipant.
     * @param {ClubEventParticipantUpsertArgs} args - Arguments to update or create a ClubEventParticipant.
     * @example
     * // Update or create a ClubEventParticipant
     * const clubEventParticipant = await prisma.clubEventParticipant.upsert({
     *   create: {
     *     // ... data to create a ClubEventParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubEventParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ClubEventParticipantUpsertArgs>(args: SelectSubset<T, ClubEventParticipantUpsertArgs<ExtArgs>>): Prisma__ClubEventParticipantClient<$Result.GetResult<Prisma.$ClubEventParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubEventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventParticipantCountArgs} args - Arguments to filter ClubEventParticipants to count.
     * @example
     * // Count the number of ClubEventParticipants
     * const count = await prisma.clubEventParticipant.count({
     *   where: {
     *     // ... the filter for the ClubEventParticipants we want to count
     *   }
     * })
    **/
    count<T extends ClubEventParticipantCountArgs>(
      args?: Subset<T, ClubEventParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubEventParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubEventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubEventParticipantAggregateArgs>(args: Subset<T, ClubEventParticipantAggregateArgs>): Prisma.PrismaPromise<GetClubEventParticipantAggregateType<T>>

    /**
     * Group by ClubEventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubEventParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubEventParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ClubEventParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubEventParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubEventParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubEventParticipant model
   */
  readonly fields: ClubEventParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubEventParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubEventParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends ClubEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubEventDefaultArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubEventParticipant model
   */
  interface ClubEventParticipantFieldRefs {
    readonly id: FieldRef<"ClubEventParticipant", 'String'>
    readonly eventId: FieldRef<"ClubEventParticipant", 'String'>
    readonly userId: FieldRef<"ClubEventParticipant", 'String'>
    readonly status: FieldRef<"ClubEventParticipant", 'String'>
    readonly createdAt: FieldRef<"ClubEventParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubEventParticipant findUnique
   */
  export type ClubEventParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventParticipant to fetch.
     */
    where: ClubEventParticipantWhereUniqueInput
  }

  /**
   * ClubEventParticipant findUniqueOrThrow
   */
  export type ClubEventParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventParticipant to fetch.
     */
    where: ClubEventParticipantWhereUniqueInput
  }

  /**
   * ClubEventParticipant findFirst
   */
  export type ClubEventParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventParticipant to fetch.
     */
    where?: ClubEventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventParticipants to fetch.
     */
    orderBy?: ClubEventParticipantOrderByWithRelationInput | ClubEventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubEventParticipants.
     */
    cursor?: ClubEventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubEventParticipants.
     */
    distinct?: ClubEventParticipantScalarFieldEnum | ClubEventParticipantScalarFieldEnum[]
  }

  /**
   * ClubEventParticipant findFirstOrThrow
   */
  export type ClubEventParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventParticipant to fetch.
     */
    where?: ClubEventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventParticipants to fetch.
     */
    orderBy?: ClubEventParticipantOrderByWithRelationInput | ClubEventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubEventParticipants.
     */
    cursor?: ClubEventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubEventParticipants.
     */
    distinct?: ClubEventParticipantScalarFieldEnum | ClubEventParticipantScalarFieldEnum[]
  }

  /**
   * ClubEventParticipant findMany
   */
  export type ClubEventParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventParticipants to fetch.
     */
    where?: ClubEventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventParticipants to fetch.
     */
    orderBy?: ClubEventParticipantOrderByWithRelationInput | ClubEventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubEventParticipants.
     */
    cursor?: ClubEventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventParticipants.
     */
    skip?: number
    distinct?: ClubEventParticipantScalarFieldEnum | ClubEventParticipantScalarFieldEnum[]
  }

  /**
   * ClubEventParticipant create
   */
  export type ClubEventParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubEventParticipant.
     */
    data: XOR<ClubEventParticipantCreateInput, ClubEventParticipantUncheckedCreateInput>
  }

  /**
   * ClubEventParticipant createMany
   */
  export type ClubEventParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubEventParticipants.
     */
    data: ClubEventParticipantCreateManyInput | ClubEventParticipantCreateManyInput[]
  }

  /**
   * ClubEventParticipant createManyAndReturn
   */
  export type ClubEventParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ClubEventParticipants.
     */
    data: ClubEventParticipantCreateManyInput | ClubEventParticipantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubEventParticipant update
   */
  export type ClubEventParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubEventParticipant.
     */
    data: XOR<ClubEventParticipantUpdateInput, ClubEventParticipantUncheckedUpdateInput>
    /**
     * Choose, which ClubEventParticipant to update.
     */
    where: ClubEventParticipantWhereUniqueInput
  }

  /**
   * ClubEventParticipant updateMany
   */
  export type ClubEventParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubEventParticipants.
     */
    data: XOR<ClubEventParticipantUpdateManyMutationInput, ClubEventParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ClubEventParticipants to update
     */
    where?: ClubEventParticipantWhereInput
    /**
     * Limit how many ClubEventParticipants to update.
     */
    limit?: number
  }

  /**
   * ClubEventParticipant updateManyAndReturn
   */
  export type ClubEventParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ClubEventParticipants.
     */
    data: XOR<ClubEventParticipantUpdateManyMutationInput, ClubEventParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ClubEventParticipants to update
     */
    where?: ClubEventParticipantWhereInput
    /**
     * Limit how many ClubEventParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubEventParticipant upsert
   */
  export type ClubEventParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubEventParticipant to update in case it exists.
     */
    where: ClubEventParticipantWhereUniqueInput
    /**
     * In case the ClubEventParticipant found by the `where` argument doesn't exist, create a new ClubEventParticipant with this data.
     */
    create: XOR<ClubEventParticipantCreateInput, ClubEventParticipantUncheckedCreateInput>
    /**
     * In case the ClubEventParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubEventParticipantUpdateInput, ClubEventParticipantUncheckedUpdateInput>
  }

  /**
   * ClubEventParticipant delete
   */
  export type ClubEventParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
    /**
     * Filter which ClubEventParticipant to delete.
     */
    where: ClubEventParticipantWhereUniqueInput
  }

  /**
   * ClubEventParticipant deleteMany
   */
  export type ClubEventParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubEventParticipants to delete
     */
    where?: ClubEventParticipantWhereInput
    /**
     * Limit how many ClubEventParticipants to delete.
     */
    limit?: number
  }

  /**
   * ClubEventParticipant without action
   */
  export type ClubEventParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventParticipant
     */
    select?: ClubEventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventParticipant
     */
    omit?: ClubEventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventParticipantInclude<ExtArgs> | null
  }


  /**
   * Model ClubEventPhoto
   */

  export type AggregateClubEventPhoto = {
    _count: ClubEventPhotoCountAggregateOutputType | null
    _min: ClubEventPhotoMinAggregateOutputType | null
    _max: ClubEventPhotoMaxAggregateOutputType | null
  }

  export type ClubEventPhotoMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    url: string | null
    caption: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ClubEventPhotoMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    url: string | null
    caption: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ClubEventPhotoCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    url: number
    caption: number
    type: number
    createdAt: number
    _all: number
  }


  export type ClubEventPhotoMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    url?: true
    caption?: true
    type?: true
    createdAt?: true
  }

  export type ClubEventPhotoMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    url?: true
    caption?: true
    type?: true
    createdAt?: true
  }

  export type ClubEventPhotoCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    url?: true
    caption?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type ClubEventPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubEventPhoto to aggregate.
     */
    where?: ClubEventPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventPhotos to fetch.
     */
    orderBy?: ClubEventPhotoOrderByWithRelationInput | ClubEventPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubEventPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubEventPhotos
    **/
    _count?: true | ClubEventPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubEventPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubEventPhotoMaxAggregateInputType
  }

  export type GetClubEventPhotoAggregateType<T extends ClubEventPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateClubEventPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubEventPhoto[P]>
      : GetScalarType<T[P], AggregateClubEventPhoto[P]>
  }




  export type ClubEventPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubEventPhotoWhereInput
    orderBy?: ClubEventPhotoOrderByWithAggregationInput | ClubEventPhotoOrderByWithAggregationInput[]
    by: ClubEventPhotoScalarFieldEnum[] | ClubEventPhotoScalarFieldEnum
    having?: ClubEventPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubEventPhotoCountAggregateInputType | true
    _min?: ClubEventPhotoMinAggregateInputType
    _max?: ClubEventPhotoMaxAggregateInputType
  }

  export type ClubEventPhotoGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    url: string
    caption: string | null
    type: string
    createdAt: Date
    _count: ClubEventPhotoCountAggregateOutputType | null
    _min: ClubEventPhotoMinAggregateOutputType | null
    _max: ClubEventPhotoMaxAggregateOutputType | null
  }

  type GetClubEventPhotoGroupByPayload<T extends ClubEventPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubEventPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubEventPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubEventPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ClubEventPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ClubEventPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    url?: boolean
    caption?: boolean
    type?: boolean
    createdAt?: boolean
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubEventPhoto"]>

  export type ClubEventPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    url?: boolean
    caption?: boolean
    type?: boolean
    createdAt?: boolean
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubEventPhoto"]>

  export type ClubEventPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    url?: boolean
    caption?: boolean
    type?: boolean
    createdAt?: boolean
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubEventPhoto"]>

  export type ClubEventPhotoSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    url?: boolean
    caption?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type ClubEventPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "url" | "caption" | "type" | "createdAt", ExtArgs["result"]["clubEventPhoto"]>
  export type ClubEventPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClubEventPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClubEventPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | ClubEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClubEventPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubEventPhoto"
    objects: {
      event: Prisma.$ClubEventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      url: string
      caption: string | null
      type: string
      createdAt: Date
    }, ExtArgs["result"]["clubEventPhoto"]>
    composites: {}
  }

  type ClubEventPhotoGetPayload<S extends boolean | null | undefined | ClubEventPhotoDefaultArgs> = $Result.GetResult<Prisma.$ClubEventPhotoPayload, S>

  type ClubEventPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubEventPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubEventPhotoCountAggregateInputType | true
    }

  export interface ClubEventPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubEventPhoto'], meta: { name: 'ClubEventPhoto' } }
    /**
     * Find zero or one ClubEventPhoto that matches the filter.
     * @param {ClubEventPhotoFindUniqueArgs} args - Arguments to find a ClubEventPhoto
     * @example
     * // Get one ClubEventPhoto
     * const clubEventPhoto = await prisma.clubEventPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubEventPhotoFindUniqueArgs>(args: SelectSubset<T, ClubEventPhotoFindUniqueArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubEventPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubEventPhotoFindUniqueOrThrowArgs} args - Arguments to find a ClubEventPhoto
     * @example
     * // Get one ClubEventPhoto
     * const clubEventPhoto = await prisma.clubEventPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubEventPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubEventPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubEventPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventPhotoFindFirstArgs} args - Arguments to find a ClubEventPhoto
     * @example
     * // Get one ClubEventPhoto
     * const clubEventPhoto = await prisma.clubEventPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubEventPhotoFindFirstArgs>(args?: SelectSubset<T, ClubEventPhotoFindFirstArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubEventPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventPhotoFindFirstOrThrowArgs} args - Arguments to find a ClubEventPhoto
     * @example
     * // Get one ClubEventPhoto
     * const clubEventPhoto = await prisma.clubEventPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubEventPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubEventPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubEventPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubEventPhotos
     * const clubEventPhotos = await prisma.clubEventPhoto.findMany()
     * 
     * // Get first 10 ClubEventPhotos
     * const clubEventPhotos = await prisma.clubEventPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubEventPhotoWithIdOnly = await prisma.clubEventPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubEventPhotoFindManyArgs>(args?: SelectSubset<T, ClubEventPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubEventPhoto.
     * @param {ClubEventPhotoCreateArgs} args - Arguments to create a ClubEventPhoto.
     * @example
     * // Create one ClubEventPhoto
     * const ClubEventPhoto = await prisma.clubEventPhoto.create({
     *   data: {
     *     // ... data to create a ClubEventPhoto
     *   }
     * })
     * 
     */
    create<T extends ClubEventPhotoCreateArgs>(args: SelectSubset<T, ClubEventPhotoCreateArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubEventPhotos.
     * @param {ClubEventPhotoCreateManyArgs} args - Arguments to create many ClubEventPhotos.
     * @example
     * // Create many ClubEventPhotos
     * const clubEventPhoto = await prisma.clubEventPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubEventPhotoCreateManyArgs>(args?: SelectSubset<T, ClubEventPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubEventPhotos and returns the data saved in the database.
     * @param {ClubEventPhotoCreateManyAndReturnArgs} args - Arguments to create many ClubEventPhotos.
     * @example
     * // Create many ClubEventPhotos
     * const clubEventPhoto = await prisma.clubEventPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubEventPhotos and only return the `id`
     * const clubEventPhotoWithIdOnly = await prisma.clubEventPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubEventPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubEventPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubEventPhoto.
     * @param {ClubEventPhotoDeleteArgs} args - Arguments to delete one ClubEventPhoto.
     * @example
     * // Delete one ClubEventPhoto
     * const ClubEventPhoto = await prisma.clubEventPhoto.delete({
     *   where: {
     *     // ... filter to delete one ClubEventPhoto
     *   }
     * })
     * 
     */
    delete<T extends ClubEventPhotoDeleteArgs>(args: SelectSubset<T, ClubEventPhotoDeleteArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubEventPhoto.
     * @param {ClubEventPhotoUpdateArgs} args - Arguments to update one ClubEventPhoto.
     * @example
     * // Update one ClubEventPhoto
     * const clubEventPhoto = await prisma.clubEventPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubEventPhotoUpdateArgs>(args: SelectSubset<T, ClubEventPhotoUpdateArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubEventPhotos.
     * @param {ClubEventPhotoDeleteManyArgs} args - Arguments to filter ClubEventPhotos to delete.
     * @example
     * // Delete a few ClubEventPhotos
     * const { count } = await prisma.clubEventPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubEventPhotoDeleteManyArgs>(args?: SelectSubset<T, ClubEventPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubEventPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubEventPhotos
     * const clubEventPhoto = await prisma.clubEventPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubEventPhotoUpdateManyArgs>(args: SelectSubset<T, ClubEventPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubEventPhotos and returns the data updated in the database.
     * @param {ClubEventPhotoUpdateManyAndReturnArgs} args - Arguments to update many ClubEventPhotos.
     * @example
     * // Update many ClubEventPhotos
     * const clubEventPhoto = await prisma.clubEventPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubEventPhotos and only return the `id`
     * const clubEventPhotoWithIdOnly = await prisma.clubEventPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubEventPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubEventPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubEventPhoto.
     * @param {ClubEventPhotoUpsertArgs} args - Arguments to update or create a ClubEventPhoto.
     * @example
     * // Update or create a ClubEventPhoto
     * const clubEventPhoto = await prisma.clubEventPhoto.upsert({
     *   create: {
     *     // ... data to create a ClubEventPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubEventPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ClubEventPhotoUpsertArgs>(args: SelectSubset<T, ClubEventPhotoUpsertArgs<ExtArgs>>): Prisma__ClubEventPhotoClient<$Result.GetResult<Prisma.$ClubEventPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubEventPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventPhotoCountArgs} args - Arguments to filter ClubEventPhotos to count.
     * @example
     * // Count the number of ClubEventPhotos
     * const count = await prisma.clubEventPhoto.count({
     *   where: {
     *     // ... the filter for the ClubEventPhotos we want to count
     *   }
     * })
    **/
    count<T extends ClubEventPhotoCountArgs>(
      args?: Subset<T, ClubEventPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubEventPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubEventPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubEventPhotoAggregateArgs>(args: Subset<T, ClubEventPhotoAggregateArgs>): Prisma.PrismaPromise<GetClubEventPhotoAggregateType<T>>

    /**
     * Group by ClubEventPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubEventPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubEventPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubEventPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ClubEventPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubEventPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubEventPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubEventPhoto model
   */
  readonly fields: ClubEventPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubEventPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubEventPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends ClubEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubEventDefaultArgs<ExtArgs>>): Prisma__ClubEventClient<$Result.GetResult<Prisma.$ClubEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubEventPhoto model
   */
  interface ClubEventPhotoFieldRefs {
    readonly id: FieldRef<"ClubEventPhoto", 'String'>
    readonly eventId: FieldRef<"ClubEventPhoto", 'String'>
    readonly userId: FieldRef<"ClubEventPhoto", 'String'>
    readonly url: FieldRef<"ClubEventPhoto", 'String'>
    readonly caption: FieldRef<"ClubEventPhoto", 'String'>
    readonly type: FieldRef<"ClubEventPhoto", 'String'>
    readonly createdAt: FieldRef<"ClubEventPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubEventPhoto findUnique
   */
  export type ClubEventPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventPhoto to fetch.
     */
    where: ClubEventPhotoWhereUniqueInput
  }

  /**
   * ClubEventPhoto findUniqueOrThrow
   */
  export type ClubEventPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventPhoto to fetch.
     */
    where: ClubEventPhotoWhereUniqueInput
  }

  /**
   * ClubEventPhoto findFirst
   */
  export type ClubEventPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventPhoto to fetch.
     */
    where?: ClubEventPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventPhotos to fetch.
     */
    orderBy?: ClubEventPhotoOrderByWithRelationInput | ClubEventPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubEventPhotos.
     */
    cursor?: ClubEventPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubEventPhotos.
     */
    distinct?: ClubEventPhotoScalarFieldEnum | ClubEventPhotoScalarFieldEnum[]
  }

  /**
   * ClubEventPhoto findFirstOrThrow
   */
  export type ClubEventPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventPhoto to fetch.
     */
    where?: ClubEventPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventPhotos to fetch.
     */
    orderBy?: ClubEventPhotoOrderByWithRelationInput | ClubEventPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubEventPhotos.
     */
    cursor?: ClubEventPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubEventPhotos.
     */
    distinct?: ClubEventPhotoScalarFieldEnum | ClubEventPhotoScalarFieldEnum[]
  }

  /**
   * ClubEventPhoto findMany
   */
  export type ClubEventPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ClubEventPhotos to fetch.
     */
    where?: ClubEventPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubEventPhotos to fetch.
     */
    orderBy?: ClubEventPhotoOrderByWithRelationInput | ClubEventPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubEventPhotos.
     */
    cursor?: ClubEventPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubEventPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubEventPhotos.
     */
    skip?: number
    distinct?: ClubEventPhotoScalarFieldEnum | ClubEventPhotoScalarFieldEnum[]
  }

  /**
   * ClubEventPhoto create
   */
  export type ClubEventPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubEventPhoto.
     */
    data: XOR<ClubEventPhotoCreateInput, ClubEventPhotoUncheckedCreateInput>
  }

  /**
   * ClubEventPhoto createMany
   */
  export type ClubEventPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubEventPhotos.
     */
    data: ClubEventPhotoCreateManyInput | ClubEventPhotoCreateManyInput[]
  }

  /**
   * ClubEventPhoto createManyAndReturn
   */
  export type ClubEventPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many ClubEventPhotos.
     */
    data: ClubEventPhotoCreateManyInput | ClubEventPhotoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubEventPhoto update
   */
  export type ClubEventPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubEventPhoto.
     */
    data: XOR<ClubEventPhotoUpdateInput, ClubEventPhotoUncheckedUpdateInput>
    /**
     * Choose, which ClubEventPhoto to update.
     */
    where: ClubEventPhotoWhereUniqueInput
  }

  /**
   * ClubEventPhoto updateMany
   */
  export type ClubEventPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubEventPhotos.
     */
    data: XOR<ClubEventPhotoUpdateManyMutationInput, ClubEventPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ClubEventPhotos to update
     */
    where?: ClubEventPhotoWhereInput
    /**
     * Limit how many ClubEventPhotos to update.
     */
    limit?: number
  }

  /**
   * ClubEventPhoto updateManyAndReturn
   */
  export type ClubEventPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * The data used to update ClubEventPhotos.
     */
    data: XOR<ClubEventPhotoUpdateManyMutationInput, ClubEventPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ClubEventPhotos to update
     */
    where?: ClubEventPhotoWhereInput
    /**
     * Limit how many ClubEventPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubEventPhoto upsert
   */
  export type ClubEventPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubEventPhoto to update in case it exists.
     */
    where: ClubEventPhotoWhereUniqueInput
    /**
     * In case the ClubEventPhoto found by the `where` argument doesn't exist, create a new ClubEventPhoto with this data.
     */
    create: XOR<ClubEventPhotoCreateInput, ClubEventPhotoUncheckedCreateInput>
    /**
     * In case the ClubEventPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubEventPhotoUpdateInput, ClubEventPhotoUncheckedUpdateInput>
  }

  /**
   * ClubEventPhoto delete
   */
  export type ClubEventPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
    /**
     * Filter which ClubEventPhoto to delete.
     */
    where: ClubEventPhotoWhereUniqueInput
  }

  /**
   * ClubEventPhoto deleteMany
   */
  export type ClubEventPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubEventPhotos to delete
     */
    where?: ClubEventPhotoWhereInput
    /**
     * Limit how many ClubEventPhotos to delete.
     */
    limit?: number
  }

  /**
   * ClubEventPhoto without action
   */
  export type ClubEventPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubEventPhoto
     */
    select?: ClubEventPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubEventPhoto
     */
    omit?: ClubEventPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubEventPhotoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    coverUrl: 'coverUrl',
    isAdmin: 'isAdmin',
    passwordHash: 'passwordHash',
    passwordResetCode: 'passwordResetCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    city: 'city',
    createdBy: 'createdBy',
    isUsed: 'isUsed',
    usedBy: 'usedBy',
    createdAt: 'createdAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const UserCityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    city: 'city'
  };

  export type UserCityScalarFieldEnum = (typeof UserCityScalarFieldEnum)[keyof typeof UserCityScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    author: 'author',
    coverUrl: 'coverUrl',
    synopsis: 'synopsis',
    aiStyleDescription: 'aiStyleDescription',
    createdByUserId: 'createdByUserId',
    indicationComment: 'indicationComment',
    createdAt: 'createdAt'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const BookStyleImageScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    url: 'url'
  };

  export type BookStyleImageScalarFieldEnum = (typeof BookStyleImageScalarFieldEnum)[keyof typeof BookStyleImageScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    createdAt: 'createdAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    role: 'role'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const JoinRequestScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type JoinRequestScalarFieldEnum = (typeof JoinRequestScalarFieldEnum)[keyof typeof JoinRequestScalarFieldEnum]


  export const GroupInviteScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type GroupInviteScalarFieldEnum = (typeof GroupInviteScalarFieldEnum)[keyof typeof GroupInviteScalarFieldEnum]


  export const GroupBookOfMonthSelectionScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    bookId: 'bookId',
    setByUserId: 'setByUserId',
    setAt: 'setAt'
  };

  export type GroupBookOfMonthSelectionScalarFieldEnum = (typeof GroupBookOfMonthSelectionScalarFieldEnum)[keyof typeof GroupBookOfMonthSelectionScalarFieldEnum]


  export const ClubBookScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    title: 'title',
    author: 'author',
    coverUrl: 'coverUrl',
    colorKey: 'colorKey',
    city: 'city',
    month: 'month',
    year: 'year',
    isActive: 'isActive',
    createdByUserId: 'createdByUserId',
    indicationComment: 'indicationComment',
    createdAt: 'createdAt',
    activatedAt: 'activatedAt'
  };

  export type ClubBookScalarFieldEnum = (typeof ClubBookScalarFieldEnum)[keyof typeof ClubBookScalarFieldEnum]


  export const ClubBookMessageScalarFieldEnum: {
    id: 'id',
    clubBookId: 'clubBookId',
    userId: 'userId',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type ClubBookMessageScalarFieldEnum = (typeof ClubBookMessageScalarFieldEnum)[keyof typeof ClubBookMessageScalarFieldEnum]


  export const ClubBookArtifactScalarFieldEnum: {
    id: 'id',
    clubBookId: 'clubBookId',
    fileName: 'fileName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    uploadedByUserId: 'uploadedByUserId',
    createdAt: 'createdAt'
  };

  export type ClubBookArtifactScalarFieldEnum = (typeof ClubBookArtifactScalarFieldEnum)[keyof typeof ClubBookArtifactScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    cityCode: 'cityCode',
    createdAt: 'createdAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const ChannelMessageScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    userId: 'userId',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type ChannelMessageScalarFieldEnum = (typeof ChannelMessageScalarFieldEnum)[keyof typeof ChannelMessageScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    text: 'text',
    imageUrl: 'imageUrl',
    clubBookId: 'clubBookId',
    createdAt: 'createdAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PostImageScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    url: 'url',
    index: 'index'
  };

  export type PostImageScalarFieldEnum = (typeof PostImageScalarFieldEnum)[keyof typeof PostImageScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PollScalarFieldEnum: {
    id: 'id',
    clubBookId: 'clubBookId',
    city: 'city',
    userId: 'userId',
    question: 'question',
    description: 'description',
    imageUrl: 'imageUrl',
    multiChoice: 'multiChoice',
    publicVotes: 'publicVotes',
    createdAt: 'createdAt'
  };

  export type PollScalarFieldEnum = (typeof PollScalarFieldEnum)[keyof typeof PollScalarFieldEnum]


  export const PollOptionScalarFieldEnum: {
    id: 'id',
    pollId: 'pollId',
    type: 'type',
    text: 'text',
    imageUrl: 'imageUrl',
    bookId: 'bookId',
    index: 'index'
  };

  export type PollOptionScalarFieldEnum = (typeof PollOptionScalarFieldEnum)[keyof typeof PollOptionScalarFieldEnum]


  export const PollVoteScalarFieldEnum: {
    id: 'id',
    pollId: 'pollId',
    optionId: 'optionId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PollVoteScalarFieldEnum = (typeof PollVoteScalarFieldEnum)[keyof typeof PollVoteScalarFieldEnum]


  export const ClubEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    city: 'city',
    location: 'location',
    addressStreet: 'addressStreet',
    addressNumber: 'addressNumber',
    addressDistrict: 'addressDistrict',
    addressCity: 'addressCity',
    addressState: 'addressState',
    addressZip: 'addressZip',
    latitude: 'latitude',
    longitude: 'longitude',
    startAt: 'startAt',
    endAt: 'endAt',
    clubBookId: 'clubBookId',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type ClubEventScalarFieldEnum = (typeof ClubEventScalarFieldEnum)[keyof typeof ClubEventScalarFieldEnum]


  export const ClubEventParticipantScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ClubEventParticipantScalarFieldEnum = (typeof ClubEventParticipantScalarFieldEnum)[keyof typeof ClubEventParticipantScalarFieldEnum]


  export const ClubEventPhotoScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    url: 'url',
    caption: 'caption',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type ClubEventPhotoScalarFieldEnum = (typeof ClubEventPhotoScalarFieldEnum)[keyof typeof ClubEventPhotoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    coverUrl?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    passwordHash?: StringFilter<"User"> | string
    passwordResetCode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cities?: UserCityListRelationFilter
    createdBooks?: BookListRelationFilter
    createdClubBooks?: ClubBookListRelationFilter
    clubEventPhotos?: ClubEventPhotoListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    isAdmin?: SortOrder
    passwordHash?: SortOrder
    passwordResetCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cities?: UserCityOrderByRelationAggregateInput
    createdBooks?: BookOrderByRelationAggregateInput
    createdClubBooks?: ClubBookOrderByRelationAggregateInput
    clubEventPhotos?: ClubEventPhotoOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    coverUrl?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    passwordHash?: StringFilter<"User"> | string
    passwordResetCode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cities?: UserCityListRelationFilter
    createdBooks?: BookListRelationFilter
    createdClubBooks?: ClubBookListRelationFilter
    clubEventPhotos?: ClubEventPhotoListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    isAdmin?: SortOrder
    passwordHash?: SortOrder
    passwordResetCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    bio?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringWithAggregatesFilter<"User"> | string
    coverUrl?: StringWithAggregatesFilter<"User"> | string
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    passwordResetCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    city?: StringFilter<"Invitation"> | string
    createdBy?: StringFilter<"Invitation"> | string
    isUsed?: BoolFilter<"Invitation"> | boolean
    usedBy?: StringNullableFilter<"Invitation"> | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    city?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    city?: StringFilter<"Invitation"> | string
    createdBy?: StringFilter<"Invitation"> | string
    isUsed?: BoolFilter<"Invitation"> | boolean
    usedBy?: StringNullableFilter<"Invitation"> | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
  }, "id">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    city?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    city?: StringWithAggregatesFilter<"Invitation"> | string
    createdBy?: StringWithAggregatesFilter<"Invitation"> | string
    isUsed?: BoolWithAggregatesFilter<"Invitation"> | boolean
    usedBy?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
  }

  export type UserCityWhereInput = {
    AND?: UserCityWhereInput | UserCityWhereInput[]
    OR?: UserCityWhereInput[]
    NOT?: UserCityWhereInput | UserCityWhereInput[]
    id?: StringFilter<"UserCity"> | string
    userId?: StringFilter<"UserCity"> | string
    city?: StringFilter<"UserCity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserCityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    city?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserCityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_city?: UserCityUserIdCityCompoundUniqueInput
    AND?: UserCityWhereInput | UserCityWhereInput[]
    OR?: UserCityWhereInput[]
    NOT?: UserCityWhereInput | UserCityWhereInput[]
    userId?: StringFilter<"UserCity"> | string
    city?: StringFilter<"UserCity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_city">

  export type UserCityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    city?: SortOrder
    _count?: UserCityCountOrderByAggregateInput
    _max?: UserCityMaxOrderByAggregateInput
    _min?: UserCityMinOrderByAggregateInput
  }

  export type UserCityScalarWhereWithAggregatesInput = {
    AND?: UserCityScalarWhereWithAggregatesInput | UserCityScalarWhereWithAggregatesInput[]
    OR?: UserCityScalarWhereWithAggregatesInput[]
    NOT?: UserCityScalarWhereWithAggregatesInput | UserCityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserCity"> | string
    userId?: StringWithAggregatesFilter<"UserCity"> | string
    city?: StringWithAggregatesFilter<"UserCity"> | string
  }

  export type BookWhereInput = {
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    id?: StringFilter<"Book"> | string
    title?: StringFilter<"Book"> | string
    author?: StringFilter<"Book"> | string
    coverUrl?: StringFilter<"Book"> | string
    synopsis?: StringFilter<"Book"> | string
    aiStyleDescription?: StringFilter<"Book"> | string
    createdByUserId?: StringNullableFilter<"Book"> | string | null
    indicationComment?: StringFilter<"Book"> | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    categories?: CategoryListRelationFilter
    styleImages?: BookStyleImageListRelationFilter
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clubBooks?: ClubBookListRelationFilter
    pollOptions?: PollOptionListRelationFilter
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    synopsis?: SortOrder
    aiStyleDescription?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    styleImages?: BookStyleImageOrderByRelationAggregateInput
    createdByUser?: UserOrderByWithRelationInput
    clubBooks?: ClubBookOrderByRelationAggregateInput
    pollOptions?: PollOptionOrderByRelationAggregateInput
  }

  export type BookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title_author?: BookTitleAuthorCompoundUniqueInput
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    title?: StringFilter<"Book"> | string
    author?: StringFilter<"Book"> | string
    coverUrl?: StringFilter<"Book"> | string
    synopsis?: StringFilter<"Book"> | string
    aiStyleDescription?: StringFilter<"Book"> | string
    createdByUserId?: StringNullableFilter<"Book"> | string | null
    indicationComment?: StringFilter<"Book"> | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    categories?: CategoryListRelationFilter
    styleImages?: BookStyleImageListRelationFilter
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clubBooks?: ClubBookListRelationFilter
    pollOptions?: PollOptionListRelationFilter
  }, "id" | "title_author">

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    synopsis?: SortOrder
    aiStyleDescription?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
    _count?: BookCountOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    OR?: BookScalarWhereWithAggregatesInput[]
    NOT?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Book"> | string
    title?: StringWithAggregatesFilter<"Book"> | string
    author?: StringWithAggregatesFilter<"Book"> | string
    coverUrl?: StringWithAggregatesFilter<"Book"> | string
    synopsis?: StringWithAggregatesFilter<"Book"> | string
    aiStyleDescription?: StringWithAggregatesFilter<"Book"> | string
    createdByUserId?: StringNullableWithAggregatesFilter<"Book"> | string | null
    indicationComment?: StringWithAggregatesFilter<"Book"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
  }

  export type BookStyleImageWhereInput = {
    AND?: BookStyleImageWhereInput | BookStyleImageWhereInput[]
    OR?: BookStyleImageWhereInput[]
    NOT?: BookStyleImageWhereInput | BookStyleImageWhereInput[]
    id?: StringFilter<"BookStyleImage"> | string
    bookId?: StringFilter<"BookStyleImage"> | string
    url?: StringFilter<"BookStyleImage"> | string
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
  }

  export type BookStyleImageOrderByWithRelationInput = {
    id?: SortOrder
    bookId?: SortOrder
    url?: SortOrder
    book?: BookOrderByWithRelationInput
  }

  export type BookStyleImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookStyleImageWhereInput | BookStyleImageWhereInput[]
    OR?: BookStyleImageWhereInput[]
    NOT?: BookStyleImageWhereInput | BookStyleImageWhereInput[]
    bookId?: StringFilter<"BookStyleImage"> | string
    url?: StringFilter<"BookStyleImage"> | string
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
  }, "id">

  export type BookStyleImageOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    url?: SortOrder
    _count?: BookStyleImageCountOrderByAggregateInput
    _max?: BookStyleImageMaxOrderByAggregateInput
    _min?: BookStyleImageMinOrderByAggregateInput
  }

  export type BookStyleImageScalarWhereWithAggregatesInput = {
    AND?: BookStyleImageScalarWhereWithAggregatesInput | BookStyleImageScalarWhereWithAggregatesInput[]
    OR?: BookStyleImageScalarWhereWithAggregatesInput[]
    NOT?: BookStyleImageScalarWhereWithAggregatesInput | BookStyleImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookStyleImage"> | string
    bookId?: StringWithAggregatesFilter<"BookStyleImage"> | string
    url?: StringWithAggregatesFilter<"BookStyleImage"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    books?: BookListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    books?: BookOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    books?: BookListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringFilter<"Group"> | string
    ownerId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    memberships?: MembershipListRelationFilter
    invites?: GroupInviteListRelationFilter
    joinRequests?: JoinRequestListRelationFilter
    bookOfMonthSelections?: GroupBookOfMonthSelectionListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    memberships?: MembershipOrderByRelationAggregateInput
    invites?: GroupInviteOrderByRelationAggregateInput
    joinRequests?: JoinRequestOrderByRelationAggregateInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    description?: StringFilter<"Group"> | string
    ownerId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    memberships?: MembershipListRelationFilter
    invites?: GroupInviteListRelationFilter
    joinRequests?: JoinRequestListRelationFilter
    bookOfMonthSelections?: GroupBookOfMonthSelectionListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringWithAggregatesFilter<"Group"> | string
    ownerId?: StringWithAggregatesFilter<"Group"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    id?: StringFilter<"Membership"> | string
    groupId?: StringFilter<"Membership"> | string
    userId?: StringFilter<"Membership"> | string
    role?: StringFilter<"Membership"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    group?: GroupOrderByWithRelationInput
  }

  export type MembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: MembershipGroupIdUserIdCompoundUniqueInput
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    groupId?: StringFilter<"Membership"> | string
    userId?: StringFilter<"Membership"> | string
    role?: StringFilter<"Membership"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id" | "groupId_userId">

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    _count?: MembershipCountOrderByAggregateInput
    _max?: MembershipMaxOrderByAggregateInput
    _min?: MembershipMinOrderByAggregateInput
  }

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    OR?: MembershipScalarWhereWithAggregatesInput[]
    NOT?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Membership"> | string
    groupId?: StringWithAggregatesFilter<"Membership"> | string
    userId?: StringWithAggregatesFilter<"Membership"> | string
    role?: StringWithAggregatesFilter<"Membership"> | string
  }

  export type JoinRequestWhereInput = {
    AND?: JoinRequestWhereInput | JoinRequestWhereInput[]
    OR?: JoinRequestWhereInput[]
    NOT?: JoinRequestWhereInput | JoinRequestWhereInput[]
    id?: StringFilter<"JoinRequest"> | string
    groupId?: StringFilter<"JoinRequest"> | string
    userId?: StringFilter<"JoinRequest"> | string
    status?: StringFilter<"JoinRequest"> | string
    createdAt?: DateTimeFilter<"JoinRequest"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type JoinRequestOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    group?: GroupOrderByWithRelationInput
  }

  export type JoinRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId_status?: JoinRequestGroupIdUserIdStatusCompoundUniqueInput
    AND?: JoinRequestWhereInput | JoinRequestWhereInput[]
    OR?: JoinRequestWhereInput[]
    NOT?: JoinRequestWhereInput | JoinRequestWhereInput[]
    groupId?: StringFilter<"JoinRequest"> | string
    userId?: StringFilter<"JoinRequest"> | string
    status?: StringFilter<"JoinRequest"> | string
    createdAt?: DateTimeFilter<"JoinRequest"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id" | "groupId_userId_status">

  export type JoinRequestOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: JoinRequestCountOrderByAggregateInput
    _max?: JoinRequestMaxOrderByAggregateInput
    _min?: JoinRequestMinOrderByAggregateInput
  }

  export type JoinRequestScalarWhereWithAggregatesInput = {
    AND?: JoinRequestScalarWhereWithAggregatesInput | JoinRequestScalarWhereWithAggregatesInput[]
    OR?: JoinRequestScalarWhereWithAggregatesInput[]
    NOT?: JoinRequestScalarWhereWithAggregatesInput | JoinRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JoinRequest"> | string
    groupId?: StringWithAggregatesFilter<"JoinRequest"> | string
    userId?: StringWithAggregatesFilter<"JoinRequest"> | string
    status?: StringWithAggregatesFilter<"JoinRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JoinRequest"> | Date | string
  }

  export type GroupInviteWhereInput = {
    AND?: GroupInviteWhereInput | GroupInviteWhereInput[]
    OR?: GroupInviteWhereInput[]
    NOT?: GroupInviteWhereInput | GroupInviteWhereInput[]
    id?: StringFilter<"GroupInvite"> | string
    groupId?: StringFilter<"GroupInvite"> | string
    createdByUserId?: StringFilter<"GroupInvite"> | string
    createdAt?: DateTimeFilter<"GroupInvite"> | Date | string
    revokedAt?: DateTimeNullableFilter<"GroupInvite"> | Date | string | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type GroupInviteOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    group?: GroupOrderByWithRelationInput
  }

  export type GroupInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupInviteWhereInput | GroupInviteWhereInput[]
    OR?: GroupInviteWhereInput[]
    NOT?: GroupInviteWhereInput | GroupInviteWhereInput[]
    groupId?: StringFilter<"GroupInvite"> | string
    createdByUserId?: StringFilter<"GroupInvite"> | string
    createdAt?: DateTimeFilter<"GroupInvite"> | Date | string
    revokedAt?: DateTimeNullableFilter<"GroupInvite"> | Date | string | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id">

  export type GroupInviteOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: GroupInviteCountOrderByAggregateInput
    _max?: GroupInviteMaxOrderByAggregateInput
    _min?: GroupInviteMinOrderByAggregateInput
  }

  export type GroupInviteScalarWhereWithAggregatesInput = {
    AND?: GroupInviteScalarWhereWithAggregatesInput | GroupInviteScalarWhereWithAggregatesInput[]
    OR?: GroupInviteScalarWhereWithAggregatesInput[]
    NOT?: GroupInviteScalarWhereWithAggregatesInput | GroupInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupInvite"> | string
    groupId?: StringWithAggregatesFilter<"GroupInvite"> | string
    createdByUserId?: StringWithAggregatesFilter<"GroupInvite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupInvite"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"GroupInvite"> | Date | string | null
  }

  export type GroupBookOfMonthSelectionWhereInput = {
    AND?: GroupBookOfMonthSelectionWhereInput | GroupBookOfMonthSelectionWhereInput[]
    OR?: GroupBookOfMonthSelectionWhereInput[]
    NOT?: GroupBookOfMonthSelectionWhereInput | GroupBookOfMonthSelectionWhereInput[]
    id?: StringFilter<"GroupBookOfMonthSelection"> | string
    groupId?: StringFilter<"GroupBookOfMonthSelection"> | string
    bookId?: StringFilter<"GroupBookOfMonthSelection"> | string
    setByUserId?: StringFilter<"GroupBookOfMonthSelection"> | string
    setAt?: DateTimeFilter<"GroupBookOfMonthSelection"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type GroupBookOfMonthSelectionOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    bookId?: SortOrder
    setByUserId?: SortOrder
    setAt?: SortOrder
    group?: GroupOrderByWithRelationInput
  }

  export type GroupBookOfMonthSelectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupBookOfMonthSelectionWhereInput | GroupBookOfMonthSelectionWhereInput[]
    OR?: GroupBookOfMonthSelectionWhereInput[]
    NOT?: GroupBookOfMonthSelectionWhereInput | GroupBookOfMonthSelectionWhereInput[]
    groupId?: StringFilter<"GroupBookOfMonthSelection"> | string
    bookId?: StringFilter<"GroupBookOfMonthSelection"> | string
    setByUserId?: StringFilter<"GroupBookOfMonthSelection"> | string
    setAt?: DateTimeFilter<"GroupBookOfMonthSelection"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id">

  export type GroupBookOfMonthSelectionOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    bookId?: SortOrder
    setByUserId?: SortOrder
    setAt?: SortOrder
    _count?: GroupBookOfMonthSelectionCountOrderByAggregateInput
    _max?: GroupBookOfMonthSelectionMaxOrderByAggregateInput
    _min?: GroupBookOfMonthSelectionMinOrderByAggregateInput
  }

  export type GroupBookOfMonthSelectionScalarWhereWithAggregatesInput = {
    AND?: GroupBookOfMonthSelectionScalarWhereWithAggregatesInput | GroupBookOfMonthSelectionScalarWhereWithAggregatesInput[]
    OR?: GroupBookOfMonthSelectionScalarWhereWithAggregatesInput[]
    NOT?: GroupBookOfMonthSelectionScalarWhereWithAggregatesInput | GroupBookOfMonthSelectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupBookOfMonthSelection"> | string
    groupId?: StringWithAggregatesFilter<"GroupBookOfMonthSelection"> | string
    bookId?: StringWithAggregatesFilter<"GroupBookOfMonthSelection"> | string
    setByUserId?: StringWithAggregatesFilter<"GroupBookOfMonthSelection"> | string
    setAt?: DateTimeWithAggregatesFilter<"GroupBookOfMonthSelection"> | Date | string
  }

  export type ClubBookWhereInput = {
    AND?: ClubBookWhereInput | ClubBookWhereInput[]
    OR?: ClubBookWhereInput[]
    NOT?: ClubBookWhereInput | ClubBookWhereInput[]
    id?: StringFilter<"ClubBook"> | string
    bookId?: StringFilter<"ClubBook"> | string
    title?: StringFilter<"ClubBook"> | string
    author?: StringFilter<"ClubBook"> | string
    coverUrl?: StringFilter<"ClubBook"> | string
    colorKey?: StringFilter<"ClubBook"> | string
    city?: StringFilter<"ClubBook"> | string
    month?: IntFilter<"ClubBook"> | number
    year?: IntFilter<"ClubBook"> | number
    isActive?: BoolFilter<"ClubBook"> | boolean
    createdByUserId?: StringFilter<"ClubBook"> | string
    indicationComment?: StringFilter<"ClubBook"> | string
    createdAt?: DateTimeFilter<"ClubBook"> | Date | string
    activatedAt?: DateTimeNullableFilter<"ClubBook"> | Date | string | null
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    messages?: ClubBookMessageListRelationFilter
    artifacts?: ClubBookArtifactListRelationFilter
    events?: ClubEventListRelationFilter
  }

  export type ClubBookOrderByWithRelationInput = {
    id?: SortOrder
    bookId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    colorKey?: SortOrder
    city?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    createdByUser?: UserOrderByWithRelationInput
    book?: BookOrderByWithRelationInput
    messages?: ClubBookMessageOrderByRelationAggregateInput
    artifacts?: ClubBookArtifactOrderByRelationAggregateInput
    events?: ClubEventOrderByRelationAggregateInput
  }

  export type ClubBookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClubBookWhereInput | ClubBookWhereInput[]
    OR?: ClubBookWhereInput[]
    NOT?: ClubBookWhereInput | ClubBookWhereInput[]
    bookId?: StringFilter<"ClubBook"> | string
    title?: StringFilter<"ClubBook"> | string
    author?: StringFilter<"ClubBook"> | string
    coverUrl?: StringFilter<"ClubBook"> | string
    colorKey?: StringFilter<"ClubBook"> | string
    city?: StringFilter<"ClubBook"> | string
    month?: IntFilter<"ClubBook"> | number
    year?: IntFilter<"ClubBook"> | number
    isActive?: BoolFilter<"ClubBook"> | boolean
    createdByUserId?: StringFilter<"ClubBook"> | string
    indicationComment?: StringFilter<"ClubBook"> | string
    createdAt?: DateTimeFilter<"ClubBook"> | Date | string
    activatedAt?: DateTimeNullableFilter<"ClubBook"> | Date | string | null
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    messages?: ClubBookMessageListRelationFilter
    artifacts?: ClubBookArtifactListRelationFilter
    events?: ClubEventListRelationFilter
  }, "id">

  export type ClubBookOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    colorKey?: SortOrder
    city?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    _count?: ClubBookCountOrderByAggregateInput
    _avg?: ClubBookAvgOrderByAggregateInput
    _max?: ClubBookMaxOrderByAggregateInput
    _min?: ClubBookMinOrderByAggregateInput
    _sum?: ClubBookSumOrderByAggregateInput
  }

  export type ClubBookScalarWhereWithAggregatesInput = {
    AND?: ClubBookScalarWhereWithAggregatesInput | ClubBookScalarWhereWithAggregatesInput[]
    OR?: ClubBookScalarWhereWithAggregatesInput[]
    NOT?: ClubBookScalarWhereWithAggregatesInput | ClubBookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubBook"> | string
    bookId?: StringWithAggregatesFilter<"ClubBook"> | string
    title?: StringWithAggregatesFilter<"ClubBook"> | string
    author?: StringWithAggregatesFilter<"ClubBook"> | string
    coverUrl?: StringWithAggregatesFilter<"ClubBook"> | string
    colorKey?: StringWithAggregatesFilter<"ClubBook"> | string
    city?: StringWithAggregatesFilter<"ClubBook"> | string
    month?: IntWithAggregatesFilter<"ClubBook"> | number
    year?: IntWithAggregatesFilter<"ClubBook"> | number
    isActive?: BoolWithAggregatesFilter<"ClubBook"> | boolean
    createdByUserId?: StringWithAggregatesFilter<"ClubBook"> | string
    indicationComment?: StringWithAggregatesFilter<"ClubBook"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClubBook"> | Date | string
    activatedAt?: DateTimeNullableWithAggregatesFilter<"ClubBook"> | Date | string | null
  }

  export type ClubBookMessageWhereInput = {
    AND?: ClubBookMessageWhereInput | ClubBookMessageWhereInput[]
    OR?: ClubBookMessageWhereInput[]
    NOT?: ClubBookMessageWhereInput | ClubBookMessageWhereInput[]
    id?: StringFilter<"ClubBookMessage"> | string
    clubBookId?: StringFilter<"ClubBookMessage"> | string
    userId?: StringFilter<"ClubBookMessage"> | string
    text?: StringFilter<"ClubBookMessage"> | string
    createdAt?: DateTimeFilter<"ClubBookMessage"> | Date | string
    clubBook?: XOR<ClubBookScalarRelationFilter, ClubBookWhereInput>
  }

  export type ClubBookMessageOrderByWithRelationInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    clubBook?: ClubBookOrderByWithRelationInput
  }

  export type ClubBookMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClubBookMessageWhereInput | ClubBookMessageWhereInput[]
    OR?: ClubBookMessageWhereInput[]
    NOT?: ClubBookMessageWhereInput | ClubBookMessageWhereInput[]
    clubBookId?: StringFilter<"ClubBookMessage"> | string
    userId?: StringFilter<"ClubBookMessage"> | string
    text?: StringFilter<"ClubBookMessage"> | string
    createdAt?: DateTimeFilter<"ClubBookMessage"> | Date | string
    clubBook?: XOR<ClubBookScalarRelationFilter, ClubBookWhereInput>
  }, "id">

  export type ClubBookMessageOrderByWithAggregationInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: ClubBookMessageCountOrderByAggregateInput
    _max?: ClubBookMessageMaxOrderByAggregateInput
    _min?: ClubBookMessageMinOrderByAggregateInput
  }

  export type ClubBookMessageScalarWhereWithAggregatesInput = {
    AND?: ClubBookMessageScalarWhereWithAggregatesInput | ClubBookMessageScalarWhereWithAggregatesInput[]
    OR?: ClubBookMessageScalarWhereWithAggregatesInput[]
    NOT?: ClubBookMessageScalarWhereWithAggregatesInput | ClubBookMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubBookMessage"> | string
    clubBookId?: StringWithAggregatesFilter<"ClubBookMessage"> | string
    userId?: StringWithAggregatesFilter<"ClubBookMessage"> | string
    text?: StringWithAggregatesFilter<"ClubBookMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClubBookMessage"> | Date | string
  }

  export type ClubBookArtifactWhereInput = {
    AND?: ClubBookArtifactWhereInput | ClubBookArtifactWhereInput[]
    OR?: ClubBookArtifactWhereInput[]
    NOT?: ClubBookArtifactWhereInput | ClubBookArtifactWhereInput[]
    id?: StringFilter<"ClubBookArtifact"> | string
    clubBookId?: StringFilter<"ClubBookArtifact"> | string
    fileName?: StringFilter<"ClubBookArtifact"> | string
    mimeType?: StringFilter<"ClubBookArtifact"> | string
    size?: IntFilter<"ClubBookArtifact"> | number
    url?: StringFilter<"ClubBookArtifact"> | string
    uploadedByUserId?: StringFilter<"ClubBookArtifact"> | string
    createdAt?: DateTimeFilter<"ClubBookArtifact"> | Date | string
    clubBook?: XOR<ClubBookScalarRelationFilter, ClubBookWhereInput>
  }

  export type ClubBookArtifactOrderByWithRelationInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedByUserId?: SortOrder
    createdAt?: SortOrder
    clubBook?: ClubBookOrderByWithRelationInput
  }

  export type ClubBookArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClubBookArtifactWhereInput | ClubBookArtifactWhereInput[]
    OR?: ClubBookArtifactWhereInput[]
    NOT?: ClubBookArtifactWhereInput | ClubBookArtifactWhereInput[]
    clubBookId?: StringFilter<"ClubBookArtifact"> | string
    fileName?: StringFilter<"ClubBookArtifact"> | string
    mimeType?: StringFilter<"ClubBookArtifact"> | string
    size?: IntFilter<"ClubBookArtifact"> | number
    url?: StringFilter<"ClubBookArtifact"> | string
    uploadedByUserId?: StringFilter<"ClubBookArtifact"> | string
    createdAt?: DateTimeFilter<"ClubBookArtifact"> | Date | string
    clubBook?: XOR<ClubBookScalarRelationFilter, ClubBookWhereInput>
  }, "id">

  export type ClubBookArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedByUserId?: SortOrder
    createdAt?: SortOrder
    _count?: ClubBookArtifactCountOrderByAggregateInput
    _avg?: ClubBookArtifactAvgOrderByAggregateInput
    _max?: ClubBookArtifactMaxOrderByAggregateInput
    _min?: ClubBookArtifactMinOrderByAggregateInput
    _sum?: ClubBookArtifactSumOrderByAggregateInput
  }

  export type ClubBookArtifactScalarWhereWithAggregatesInput = {
    AND?: ClubBookArtifactScalarWhereWithAggregatesInput | ClubBookArtifactScalarWhereWithAggregatesInput[]
    OR?: ClubBookArtifactScalarWhereWithAggregatesInput[]
    NOT?: ClubBookArtifactScalarWhereWithAggregatesInput | ClubBookArtifactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubBookArtifact"> | string
    clubBookId?: StringWithAggregatesFilter<"ClubBookArtifact"> | string
    fileName?: StringWithAggregatesFilter<"ClubBookArtifact"> | string
    mimeType?: StringWithAggregatesFilter<"ClubBookArtifact"> | string
    size?: IntWithAggregatesFilter<"ClubBookArtifact"> | number
    url?: StringWithAggregatesFilter<"ClubBookArtifact"> | string
    uploadedByUserId?: StringWithAggregatesFilter<"ClubBookArtifact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClubBookArtifact"> | Date | string
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    type?: StringFilter<"Channel"> | string
    cityCode?: StringNullableFilter<"Channel"> | string | null
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    messages?: ChannelMessageListRelationFilter
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cityCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    messages?: ChannelMessageOrderByRelationAggregateInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    name?: StringFilter<"Channel"> | string
    type?: StringFilter<"Channel"> | string
    cityCode?: StringNullableFilter<"Channel"> | string | null
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    messages?: ChannelMessageListRelationFilter
  }, "id">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cityCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    name?: StringWithAggregatesFilter<"Channel"> | string
    type?: StringWithAggregatesFilter<"Channel"> | string
    cityCode?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
  }

  export type ChannelMessageWhereInput = {
    AND?: ChannelMessageWhereInput | ChannelMessageWhereInput[]
    OR?: ChannelMessageWhereInput[]
    NOT?: ChannelMessageWhereInput | ChannelMessageWhereInput[]
    id?: StringFilter<"ChannelMessage"> | string
    channelId?: StringFilter<"ChannelMessage"> | string
    userId?: StringFilter<"ChannelMessage"> | string
    text?: StringFilter<"ChannelMessage"> | string
    createdAt?: DateTimeFilter<"ChannelMessage"> | Date | string
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
  }

  export type ChannelMessageOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
  }

  export type ChannelMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelMessageWhereInput | ChannelMessageWhereInput[]
    OR?: ChannelMessageWhereInput[]
    NOT?: ChannelMessageWhereInput | ChannelMessageWhereInput[]
    channelId?: StringFilter<"ChannelMessage"> | string
    userId?: StringFilter<"ChannelMessage"> | string
    text?: StringFilter<"ChannelMessage"> | string
    createdAt?: DateTimeFilter<"ChannelMessage"> | Date | string
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
  }, "id">

  export type ChannelMessageOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: ChannelMessageCountOrderByAggregateInput
    _max?: ChannelMessageMaxOrderByAggregateInput
    _min?: ChannelMessageMinOrderByAggregateInput
  }

  export type ChannelMessageScalarWhereWithAggregatesInput = {
    AND?: ChannelMessageScalarWhereWithAggregatesInput | ChannelMessageScalarWhereWithAggregatesInput[]
    OR?: ChannelMessageScalarWhereWithAggregatesInput[]
    NOT?: ChannelMessageScalarWhereWithAggregatesInput | ChannelMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelMessage"> | string
    channelId?: StringWithAggregatesFilter<"ChannelMessage"> | string
    userId?: StringWithAggregatesFilter<"ChannelMessage"> | string
    text?: StringWithAggregatesFilter<"ChannelMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChannelMessage"> | Date | string
  }

  export type DirectMessageWhereInput = {
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    id?: StringFilter<"DirectMessage"> | string
    fromUserId?: StringFilter<"DirectMessage"> | string
    toUserId?: StringFilter<"DirectMessage"> | string
    text?: StringFilter<"DirectMessage"> | string
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    fromUserId?: StringFilter<"DirectMessage"> | string
    toUserId?: StringFilter<"DirectMessage"> | string
    text?: StringFilter<"DirectMessage"> | string
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
  }, "id">

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    OR?: DirectMessageScalarWhereWithAggregatesInput[]
    NOT?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DirectMessage"> | string
    fromUserId?: StringWithAggregatesFilter<"DirectMessage"> | string
    toUserId?: StringWithAggregatesFilter<"DirectMessage"> | string
    text?: StringWithAggregatesFilter<"DirectMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DirectMessage"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    text?: StringFilter<"Post"> | string
    imageUrl?: StringNullableFilter<"Post"> | string | null
    clubBookId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    images?: PostImageListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    clubBookId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    likes?: LikeOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    images?: PostImageOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    userId?: StringFilter<"Post"> | string
    text?: StringFilter<"Post"> | string
    imageUrl?: StringNullableFilter<"Post"> | string | null
    clubBookId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    images?: PostImageListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    clubBookId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    userId?: StringWithAggregatesFilter<"Post"> | string
    text?: StringWithAggregatesFilter<"Post"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    clubBookId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type PostImageWhereInput = {
    AND?: PostImageWhereInput | PostImageWhereInput[]
    OR?: PostImageWhereInput[]
    NOT?: PostImageWhereInput | PostImageWhereInput[]
    id?: StringFilter<"PostImage"> | string
    postId?: StringFilter<"PostImage"> | string
    url?: StringFilter<"PostImage"> | string
    index?: IntFilter<"PostImage"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type PostImageOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    index?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type PostImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostImageWhereInput | PostImageWhereInput[]
    OR?: PostImageWhereInput[]
    NOT?: PostImageWhereInput | PostImageWhereInput[]
    postId?: StringFilter<"PostImage"> | string
    url?: StringFilter<"PostImage"> | string
    index?: IntFilter<"PostImage"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type PostImageOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    index?: SortOrder
    _count?: PostImageCountOrderByAggregateInput
    _avg?: PostImageAvgOrderByAggregateInput
    _max?: PostImageMaxOrderByAggregateInput
    _min?: PostImageMinOrderByAggregateInput
    _sum?: PostImageSumOrderByAggregateInput
  }

  export type PostImageScalarWhereWithAggregatesInput = {
    AND?: PostImageScalarWhereWithAggregatesInput | PostImageScalarWhereWithAggregatesInput[]
    OR?: PostImageScalarWhereWithAggregatesInput[]
    NOT?: PostImageScalarWhereWithAggregatesInput | PostImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostImage"> | string
    postId?: StringWithAggregatesFilter<"PostImage"> | string
    url?: StringWithAggregatesFilter<"PostImage"> | string
    index?: IntWithAggregatesFilter<"PostImage"> | number
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    type?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: LikePostIdUserIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    type?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id" | "postId_userId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    postId?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
    type?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    text?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type PollWhereInput = {
    AND?: PollWhereInput | PollWhereInput[]
    OR?: PollWhereInput[]
    NOT?: PollWhereInput | PollWhereInput[]
    id?: StringFilter<"Poll"> | string
    clubBookId?: StringNullableFilter<"Poll"> | string | null
    city?: StringFilter<"Poll"> | string
    userId?: StringFilter<"Poll"> | string
    question?: StringFilter<"Poll"> | string
    description?: StringNullableFilter<"Poll"> | string | null
    imageUrl?: StringNullableFilter<"Poll"> | string | null
    multiChoice?: BoolFilter<"Poll"> | boolean
    publicVotes?: BoolFilter<"Poll"> | boolean
    createdAt?: DateTimeFilter<"Poll"> | Date | string
    options?: PollOptionListRelationFilter
    votes?: PollVoteListRelationFilter
  }

  export type PollOrderByWithRelationInput = {
    id?: SortOrder
    clubBookId?: SortOrderInput | SortOrder
    city?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    multiChoice?: SortOrder
    publicVotes?: SortOrder
    createdAt?: SortOrder
    options?: PollOptionOrderByRelationAggregateInput
    votes?: PollVoteOrderByRelationAggregateInput
  }

  export type PollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PollWhereInput | PollWhereInput[]
    OR?: PollWhereInput[]
    NOT?: PollWhereInput | PollWhereInput[]
    clubBookId?: StringNullableFilter<"Poll"> | string | null
    city?: StringFilter<"Poll"> | string
    userId?: StringFilter<"Poll"> | string
    question?: StringFilter<"Poll"> | string
    description?: StringNullableFilter<"Poll"> | string | null
    imageUrl?: StringNullableFilter<"Poll"> | string | null
    multiChoice?: BoolFilter<"Poll"> | boolean
    publicVotes?: BoolFilter<"Poll"> | boolean
    createdAt?: DateTimeFilter<"Poll"> | Date | string
    options?: PollOptionListRelationFilter
    votes?: PollVoteListRelationFilter
  }, "id">

  export type PollOrderByWithAggregationInput = {
    id?: SortOrder
    clubBookId?: SortOrderInput | SortOrder
    city?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    multiChoice?: SortOrder
    publicVotes?: SortOrder
    createdAt?: SortOrder
    _count?: PollCountOrderByAggregateInput
    _max?: PollMaxOrderByAggregateInput
    _min?: PollMinOrderByAggregateInput
  }

  export type PollScalarWhereWithAggregatesInput = {
    AND?: PollScalarWhereWithAggregatesInput | PollScalarWhereWithAggregatesInput[]
    OR?: PollScalarWhereWithAggregatesInput[]
    NOT?: PollScalarWhereWithAggregatesInput | PollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Poll"> | string
    clubBookId?: StringNullableWithAggregatesFilter<"Poll"> | string | null
    city?: StringWithAggregatesFilter<"Poll"> | string
    userId?: StringWithAggregatesFilter<"Poll"> | string
    question?: StringWithAggregatesFilter<"Poll"> | string
    description?: StringNullableWithAggregatesFilter<"Poll"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Poll"> | string | null
    multiChoice?: BoolWithAggregatesFilter<"Poll"> | boolean
    publicVotes?: BoolWithAggregatesFilter<"Poll"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Poll"> | Date | string
  }

  export type PollOptionWhereInput = {
    AND?: PollOptionWhereInput | PollOptionWhereInput[]
    OR?: PollOptionWhereInput[]
    NOT?: PollOptionWhereInput | PollOptionWhereInput[]
    id?: StringFilter<"PollOption"> | string
    pollId?: StringFilter<"PollOption"> | string
    type?: StringFilter<"PollOption"> | string
    text?: StringFilter<"PollOption"> | string
    imageUrl?: StringNullableFilter<"PollOption"> | string | null
    bookId?: StringNullableFilter<"PollOption"> | string | null
    index?: IntFilter<"PollOption"> | number
    poll?: XOR<PollScalarRelationFilter, PollWhereInput>
    book?: XOR<BookNullableScalarRelationFilter, BookWhereInput> | null
    votes?: PollVoteListRelationFilter
  }

  export type PollOptionOrderByWithRelationInput = {
    id?: SortOrder
    pollId?: SortOrder
    type?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    bookId?: SortOrderInput | SortOrder
    index?: SortOrder
    poll?: PollOrderByWithRelationInput
    book?: BookOrderByWithRelationInput
    votes?: PollVoteOrderByRelationAggregateInput
  }

  export type PollOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PollOptionWhereInput | PollOptionWhereInput[]
    OR?: PollOptionWhereInput[]
    NOT?: PollOptionWhereInput | PollOptionWhereInput[]
    pollId?: StringFilter<"PollOption"> | string
    type?: StringFilter<"PollOption"> | string
    text?: StringFilter<"PollOption"> | string
    imageUrl?: StringNullableFilter<"PollOption"> | string | null
    bookId?: StringNullableFilter<"PollOption"> | string | null
    index?: IntFilter<"PollOption"> | number
    poll?: XOR<PollScalarRelationFilter, PollWhereInput>
    book?: XOR<BookNullableScalarRelationFilter, BookWhereInput> | null
    votes?: PollVoteListRelationFilter
  }, "id">

  export type PollOptionOrderByWithAggregationInput = {
    id?: SortOrder
    pollId?: SortOrder
    type?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    bookId?: SortOrderInput | SortOrder
    index?: SortOrder
    _count?: PollOptionCountOrderByAggregateInput
    _avg?: PollOptionAvgOrderByAggregateInput
    _max?: PollOptionMaxOrderByAggregateInput
    _min?: PollOptionMinOrderByAggregateInput
    _sum?: PollOptionSumOrderByAggregateInput
  }

  export type PollOptionScalarWhereWithAggregatesInput = {
    AND?: PollOptionScalarWhereWithAggregatesInput | PollOptionScalarWhereWithAggregatesInput[]
    OR?: PollOptionScalarWhereWithAggregatesInput[]
    NOT?: PollOptionScalarWhereWithAggregatesInput | PollOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PollOption"> | string
    pollId?: StringWithAggregatesFilter<"PollOption"> | string
    type?: StringWithAggregatesFilter<"PollOption"> | string
    text?: StringWithAggregatesFilter<"PollOption"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"PollOption"> | string | null
    bookId?: StringNullableWithAggregatesFilter<"PollOption"> | string | null
    index?: IntWithAggregatesFilter<"PollOption"> | number
  }

  export type PollVoteWhereInput = {
    AND?: PollVoteWhereInput | PollVoteWhereInput[]
    OR?: PollVoteWhereInput[]
    NOT?: PollVoteWhereInput | PollVoteWhereInput[]
    id?: StringFilter<"PollVote"> | string
    pollId?: StringFilter<"PollVote"> | string
    optionId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
    poll?: XOR<PollScalarRelationFilter, PollWhereInput>
    option?: XOR<PollOptionScalarRelationFilter, PollOptionWhereInput>
  }

  export type PollVoteOrderByWithRelationInput = {
    id?: SortOrder
    pollId?: SortOrder
    optionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    poll?: PollOrderByWithRelationInput
    option?: PollOptionOrderByWithRelationInput
  }

  export type PollVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pollId_userId_optionId?: PollVotePollIdUserIdOptionIdCompoundUniqueInput
    AND?: PollVoteWhereInput | PollVoteWhereInput[]
    OR?: PollVoteWhereInput[]
    NOT?: PollVoteWhereInput | PollVoteWhereInput[]
    pollId?: StringFilter<"PollVote"> | string
    optionId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
    poll?: XOR<PollScalarRelationFilter, PollWhereInput>
    option?: XOR<PollOptionScalarRelationFilter, PollOptionWhereInput>
  }, "id" | "pollId_userId_optionId">

  export type PollVoteOrderByWithAggregationInput = {
    id?: SortOrder
    pollId?: SortOrder
    optionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: PollVoteCountOrderByAggregateInput
    _max?: PollVoteMaxOrderByAggregateInput
    _min?: PollVoteMinOrderByAggregateInput
  }

  export type PollVoteScalarWhereWithAggregatesInput = {
    AND?: PollVoteScalarWhereWithAggregatesInput | PollVoteScalarWhereWithAggregatesInput[]
    OR?: PollVoteScalarWhereWithAggregatesInput[]
    NOT?: PollVoteScalarWhereWithAggregatesInput | PollVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PollVote"> | string
    pollId?: StringWithAggregatesFilter<"PollVote"> | string
    optionId?: StringWithAggregatesFilter<"PollVote"> | string
    userId?: StringWithAggregatesFilter<"PollVote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PollVote"> | Date | string
  }

  export type ClubEventWhereInput = {
    AND?: ClubEventWhereInput | ClubEventWhereInput[]
    OR?: ClubEventWhereInput[]
    NOT?: ClubEventWhereInput | ClubEventWhereInput[]
    id?: StringFilter<"ClubEvent"> | string
    title?: StringFilter<"ClubEvent"> | string
    description?: StringFilter<"ClubEvent"> | string
    city?: StringFilter<"ClubEvent"> | string
    location?: StringFilter<"ClubEvent"> | string
    addressStreet?: StringNullableFilter<"ClubEvent"> | string | null
    addressNumber?: StringNullableFilter<"ClubEvent"> | string | null
    addressDistrict?: StringNullableFilter<"ClubEvent"> | string | null
    addressCity?: StringNullableFilter<"ClubEvent"> | string | null
    addressState?: StringNullableFilter<"ClubEvent"> | string | null
    addressZip?: StringNullableFilter<"ClubEvent"> | string | null
    latitude?: FloatNullableFilter<"ClubEvent"> | number | null
    longitude?: FloatNullableFilter<"ClubEvent"> | number | null
    startAt?: DateTimeFilter<"ClubEvent"> | Date | string
    endAt?: DateTimeNullableFilter<"ClubEvent"> | Date | string | null
    clubBookId?: StringNullableFilter<"ClubEvent"> | string | null
    createdById?: StringFilter<"ClubEvent"> | string
    createdAt?: DateTimeFilter<"ClubEvent"> | Date | string
    clubBook?: XOR<ClubBookNullableScalarRelationFilter, ClubBookWhereInput> | null
    participants?: ClubEventParticipantListRelationFilter
    photos?: ClubEventPhotoListRelationFilter
  }

  export type ClubEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    location?: SortOrder
    addressStreet?: SortOrderInput | SortOrder
    addressNumber?: SortOrderInput | SortOrder
    addressDistrict?: SortOrderInput | SortOrder
    addressCity?: SortOrderInput | SortOrder
    addressState?: SortOrderInput | SortOrder
    addressZip?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    clubBookId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    clubBook?: ClubBookOrderByWithRelationInput
    participants?: ClubEventParticipantOrderByRelationAggregateInput
    photos?: ClubEventPhotoOrderByRelationAggregateInput
  }

  export type ClubEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClubEventWhereInput | ClubEventWhereInput[]
    OR?: ClubEventWhereInput[]
    NOT?: ClubEventWhereInput | ClubEventWhereInput[]
    title?: StringFilter<"ClubEvent"> | string
    description?: StringFilter<"ClubEvent"> | string
    city?: StringFilter<"ClubEvent"> | string
    location?: StringFilter<"ClubEvent"> | string
    addressStreet?: StringNullableFilter<"ClubEvent"> | string | null
    addressNumber?: StringNullableFilter<"ClubEvent"> | string | null
    addressDistrict?: StringNullableFilter<"ClubEvent"> | string | null
    addressCity?: StringNullableFilter<"ClubEvent"> | string | null
    addressState?: StringNullableFilter<"ClubEvent"> | string | null
    addressZip?: StringNullableFilter<"ClubEvent"> | string | null
    latitude?: FloatNullableFilter<"ClubEvent"> | number | null
    longitude?: FloatNullableFilter<"ClubEvent"> | number | null
    startAt?: DateTimeFilter<"ClubEvent"> | Date | string
    endAt?: DateTimeNullableFilter<"ClubEvent"> | Date | string | null
    clubBookId?: StringNullableFilter<"ClubEvent"> | string | null
    createdById?: StringFilter<"ClubEvent"> | string
    createdAt?: DateTimeFilter<"ClubEvent"> | Date | string
    clubBook?: XOR<ClubBookNullableScalarRelationFilter, ClubBookWhereInput> | null
    participants?: ClubEventParticipantListRelationFilter
    photos?: ClubEventPhotoListRelationFilter
  }, "id">

  export type ClubEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    location?: SortOrder
    addressStreet?: SortOrderInput | SortOrder
    addressNumber?: SortOrderInput | SortOrder
    addressDistrict?: SortOrderInput | SortOrder
    addressCity?: SortOrderInput | SortOrder
    addressState?: SortOrderInput | SortOrder
    addressZip?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    clubBookId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: ClubEventCountOrderByAggregateInput
    _avg?: ClubEventAvgOrderByAggregateInput
    _max?: ClubEventMaxOrderByAggregateInput
    _min?: ClubEventMinOrderByAggregateInput
    _sum?: ClubEventSumOrderByAggregateInput
  }

  export type ClubEventScalarWhereWithAggregatesInput = {
    AND?: ClubEventScalarWhereWithAggregatesInput | ClubEventScalarWhereWithAggregatesInput[]
    OR?: ClubEventScalarWhereWithAggregatesInput[]
    NOT?: ClubEventScalarWhereWithAggregatesInput | ClubEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubEvent"> | string
    title?: StringWithAggregatesFilter<"ClubEvent"> | string
    description?: StringWithAggregatesFilter<"ClubEvent"> | string
    city?: StringWithAggregatesFilter<"ClubEvent"> | string
    location?: StringWithAggregatesFilter<"ClubEvent"> | string
    addressStreet?: StringNullableWithAggregatesFilter<"ClubEvent"> | string | null
    addressNumber?: StringNullableWithAggregatesFilter<"ClubEvent"> | string | null
    addressDistrict?: StringNullableWithAggregatesFilter<"ClubEvent"> | string | null
    addressCity?: StringNullableWithAggregatesFilter<"ClubEvent"> | string | null
    addressState?: StringNullableWithAggregatesFilter<"ClubEvent"> | string | null
    addressZip?: StringNullableWithAggregatesFilter<"ClubEvent"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"ClubEvent"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"ClubEvent"> | number | null
    startAt?: DateTimeWithAggregatesFilter<"ClubEvent"> | Date | string
    endAt?: DateTimeNullableWithAggregatesFilter<"ClubEvent"> | Date | string | null
    clubBookId?: StringNullableWithAggregatesFilter<"ClubEvent"> | string | null
    createdById?: StringWithAggregatesFilter<"ClubEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClubEvent"> | Date | string
  }

  export type ClubEventParticipantWhereInput = {
    AND?: ClubEventParticipantWhereInput | ClubEventParticipantWhereInput[]
    OR?: ClubEventParticipantWhereInput[]
    NOT?: ClubEventParticipantWhereInput | ClubEventParticipantWhereInput[]
    id?: StringFilter<"ClubEventParticipant"> | string
    eventId?: StringFilter<"ClubEventParticipant"> | string
    userId?: StringFilter<"ClubEventParticipant"> | string
    status?: StringFilter<"ClubEventParticipant"> | string
    createdAt?: DateTimeFilter<"ClubEventParticipant"> | Date | string
    event?: XOR<ClubEventScalarRelationFilter, ClubEventWhereInput>
  }

  export type ClubEventParticipantOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    event?: ClubEventOrderByWithRelationInput
  }

  export type ClubEventParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: ClubEventParticipantEventIdUserIdCompoundUniqueInput
    AND?: ClubEventParticipantWhereInput | ClubEventParticipantWhereInput[]
    OR?: ClubEventParticipantWhereInput[]
    NOT?: ClubEventParticipantWhereInput | ClubEventParticipantWhereInput[]
    eventId?: StringFilter<"ClubEventParticipant"> | string
    userId?: StringFilter<"ClubEventParticipant"> | string
    status?: StringFilter<"ClubEventParticipant"> | string
    createdAt?: DateTimeFilter<"ClubEventParticipant"> | Date | string
    event?: XOR<ClubEventScalarRelationFilter, ClubEventWhereInput>
  }, "id" | "eventId_userId">

  export type ClubEventParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ClubEventParticipantCountOrderByAggregateInput
    _max?: ClubEventParticipantMaxOrderByAggregateInput
    _min?: ClubEventParticipantMinOrderByAggregateInput
  }

  export type ClubEventParticipantScalarWhereWithAggregatesInput = {
    AND?: ClubEventParticipantScalarWhereWithAggregatesInput | ClubEventParticipantScalarWhereWithAggregatesInput[]
    OR?: ClubEventParticipantScalarWhereWithAggregatesInput[]
    NOT?: ClubEventParticipantScalarWhereWithAggregatesInput | ClubEventParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubEventParticipant"> | string
    eventId?: StringWithAggregatesFilter<"ClubEventParticipant"> | string
    userId?: StringWithAggregatesFilter<"ClubEventParticipant"> | string
    status?: StringWithAggregatesFilter<"ClubEventParticipant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClubEventParticipant"> | Date | string
  }

  export type ClubEventPhotoWhereInput = {
    AND?: ClubEventPhotoWhereInput | ClubEventPhotoWhereInput[]
    OR?: ClubEventPhotoWhereInput[]
    NOT?: ClubEventPhotoWhereInput | ClubEventPhotoWhereInput[]
    id?: StringFilter<"ClubEventPhoto"> | string
    eventId?: StringFilter<"ClubEventPhoto"> | string
    userId?: StringFilter<"ClubEventPhoto"> | string
    url?: StringFilter<"ClubEventPhoto"> | string
    caption?: StringNullableFilter<"ClubEventPhoto"> | string | null
    type?: StringFilter<"ClubEventPhoto"> | string
    createdAt?: DateTimeFilter<"ClubEventPhoto"> | Date | string
    event?: XOR<ClubEventScalarRelationFilter, ClubEventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClubEventPhotoOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    event?: ClubEventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ClubEventPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClubEventPhotoWhereInput | ClubEventPhotoWhereInput[]
    OR?: ClubEventPhotoWhereInput[]
    NOT?: ClubEventPhotoWhereInput | ClubEventPhotoWhereInput[]
    eventId?: StringFilter<"ClubEventPhoto"> | string
    userId?: StringFilter<"ClubEventPhoto"> | string
    url?: StringFilter<"ClubEventPhoto"> | string
    caption?: StringNullableFilter<"ClubEventPhoto"> | string | null
    type?: StringFilter<"ClubEventPhoto"> | string
    createdAt?: DateTimeFilter<"ClubEventPhoto"> | Date | string
    event?: XOR<ClubEventScalarRelationFilter, ClubEventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClubEventPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: ClubEventPhotoCountOrderByAggregateInput
    _max?: ClubEventPhotoMaxOrderByAggregateInput
    _min?: ClubEventPhotoMinOrderByAggregateInput
  }

  export type ClubEventPhotoScalarWhereWithAggregatesInput = {
    AND?: ClubEventPhotoScalarWhereWithAggregatesInput | ClubEventPhotoScalarWhereWithAggregatesInput[]
    OR?: ClubEventPhotoScalarWhereWithAggregatesInput[]
    NOT?: ClubEventPhotoScalarWhereWithAggregatesInput | ClubEventPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubEventPhoto"> | string
    eventId?: StringWithAggregatesFilter<"ClubEventPhoto"> | string
    userId?: StringWithAggregatesFilter<"ClubEventPhoto"> | string
    url?: StringWithAggregatesFilter<"ClubEventPhoto"> | string
    caption?: StringNullableWithAggregatesFilter<"ClubEventPhoto"> | string | null
    type?: StringWithAggregatesFilter<"ClubEventPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClubEventPhoto"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityCreateNestedManyWithoutUserInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByUserInput
    createdClubBooks?: ClubBookCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityUncheckedCreateNestedManyWithoutUserInput
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdClubBooks?: ClubBookUncheckedCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUpdateManyWithoutUserNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByUserNestedInput
    createdClubBooks?: ClubBookUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUncheckedUpdateManyWithoutUserNestedInput
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdClubBooks?: ClubBookUncheckedUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id: string
    city: string
    createdBy: string
    isUsed?: boolean
    usedBy?: string | null
    createdAt?: Date | string
  }

  export type InvitationUncheckedCreateInput = {
    id: string
    city: string
    createdBy: string
    isUsed?: boolean
    usedBy?: string | null
    createdAt?: Date | string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInput = {
    id: string
    city: string
    createdBy: string
    isUsed?: boolean
    usedBy?: string | null
    createdAt?: Date | string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCityCreateInput = {
    id?: string
    city: string
    user: UserCreateNestedOneWithoutCitiesInput
  }

  export type UserCityUncheckedCreateInput = {
    id?: string
    userId: string
    city: string
  }

  export type UserCityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCitiesNestedInput
  }

  export type UserCityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type UserCityCreateManyInput = {
    id?: string
    userId: string
    city: string
  }

  export type UserCityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type UserCityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type BookCreateInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageCreateNestedManyWithoutBookInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBooksInput
    clubBooks?: ClubBookCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    createdByUserId?: string | null
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageUncheckedCreateNestedManyWithoutBookInput
    clubBooks?: ClubBookUncheckedCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUpdateManyWithoutBookNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBooksNestedInput
    clubBooks?: ClubBookUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUncheckedUpdateManyWithoutBookNestedInput
    clubBooks?: ClubBookUncheckedUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookCreateManyInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    createdByUserId?: string | null
    indicationComment?: string
    createdAt?: Date | string
  }

  export type BookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookStyleImageCreateInput = {
    id?: string
    url: string
    book: BookCreateNestedOneWithoutStyleImagesInput
  }

  export type BookStyleImageUncheckedCreateInput = {
    id?: string
    bookId: string
    url: string
  }

  export type BookStyleImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    book?: BookUpdateOneRequiredWithoutStyleImagesNestedInput
  }

  export type BookStyleImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BookStyleImageCreateManyInput = {
    id?: string
    bookId: string
    url: string
  }

  export type BookStyleImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BookStyleImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    books?: BookCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    books?: BookUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    books?: BookUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    books?: BookUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutGroupInput
    invites?: GroupInviteCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutGroupInput
    invites?: GroupInviteUncheckedCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutGroupNestedInput
    invites?: GroupInviteUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutGroupNestedInput
    invites?: GroupInviteUncheckedUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateInput = {
    id?: string
    userId: string
    role: string
    group: GroupCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    role: string
  }

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    group?: GroupUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type MembershipCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    role: string
  }

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type JoinRequestCreateInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
    group: GroupCreateNestedOneWithoutJoinRequestsInput
  }

  export type JoinRequestUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type JoinRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutJoinRequestsNestedInput
  }

  export type JoinRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JoinRequestCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type JoinRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JoinRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupInviteCreateInput = {
    id?: string
    createdByUserId: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutInvitesInput
  }

  export type GroupInviteUncheckedCreateInput = {
    id?: string
    groupId: string
    createdByUserId: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type GroupInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type GroupInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupInviteCreateManyInput = {
    id?: string
    groupId: string
    createdByUserId: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type GroupInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupBookOfMonthSelectionCreateInput = {
    id?: string
    bookId: string
    setByUserId: string
    setAt?: Date | string
    group: GroupCreateNestedOneWithoutBookOfMonthSelectionsInput
  }

  export type GroupBookOfMonthSelectionUncheckedCreateInput = {
    id?: string
    groupId: string
    bookId: string
    setByUserId: string
    setAt?: Date | string
  }

  export type GroupBookOfMonthSelectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    setByUserId?: StringFieldUpdateOperationsInput | string
    setAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutBookOfMonthSelectionsNestedInput
  }

  export type GroupBookOfMonthSelectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    setByUserId?: StringFieldUpdateOperationsInput | string
    setAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupBookOfMonthSelectionCreateManyInput = {
    id?: string
    groupId: string
    bookId: string
    setByUserId: string
    setAt?: Date | string
  }

  export type GroupBookOfMonthSelectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    setByUserId?: StringFieldUpdateOperationsInput | string
    setAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupBookOfMonthSelectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    setByUserId?: StringFieldUpdateOperationsInput | string
    setAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookCreateInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    createdByUser: UserCreateNestedOneWithoutCreatedClubBooksInput
    book: BookCreateNestedOneWithoutClubBooksInput
    messages?: ClubBookMessageCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactCreateNestedManyWithoutClubBookInput
    events?: ClubEventCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookUncheckedCreateInput = {
    id?: string
    bookId: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    createdByUserId: string
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    messages?: ClubBookMessageUncheckedCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactUncheckedCreateNestedManyWithoutClubBookInput
    events?: ClubEventUncheckedCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneRequiredWithoutCreatedClubBooksNestedInput
    book?: BookUpdateOneRequiredWithoutClubBooksNestedInput
    messages?: ClubBookMessageUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ClubBookMessageUncheckedUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUncheckedUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUncheckedUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookCreateManyInput = {
    id?: string
    bookId: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    createdByUserId: string
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
  }

  export type ClubBookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubBookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubBookMessageCreateInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
    clubBook: ClubBookCreateNestedOneWithoutMessagesInput
  }

  export type ClubBookMessageUncheckedCreateInput = {
    id?: string
    clubBookId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ClubBookMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubBook?: ClubBookUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ClubBookMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookMessageCreateManyInput = {
    id?: string
    clubBookId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ClubBookMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookArtifactCreateInput = {
    id?: string
    fileName: string
    mimeType: string
    size: number
    url: string
    uploadedByUserId: string
    createdAt?: Date | string
    clubBook: ClubBookCreateNestedOneWithoutArtifactsInput
  }

  export type ClubBookArtifactUncheckedCreateInput = {
    id?: string
    clubBookId: string
    fileName: string
    mimeType: string
    size: number
    url: string
    uploadedByUserId: string
    createdAt?: Date | string
  }

  export type ClubBookArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubBook?: ClubBookUpdateOneRequiredWithoutArtifactsNestedInput
  }

  export type ClubBookArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookArtifactCreateManyInput = {
    id?: string
    clubBookId: string
    fileName: string
    mimeType: string
    size: number
    url: string
    uploadedByUserId: string
    createdAt?: Date | string
  }

  export type ClubBookArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    id: string
    name: string
    type: string
    cityCode?: string | null
    createdAt?: Date | string
    messages?: ChannelMessageCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateInput = {
    id: string
    name: string
    type: string
    cityCode?: string | null
    createdAt?: Date | string
    messages?: ChannelMessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChannelMessageUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChannelMessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id: string
    name: string
    type: string
    cityCode?: string | null
    createdAt?: Date | string
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelMessageCreateInput = {
    id: string
    userId: string
    text: string
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
  }

  export type ChannelMessageUncheckedCreateInput = {
    id: string
    channelId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ChannelMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChannelMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelMessageCreateManyInput = {
    id: string
    channelId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ChannelMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateInput = {
    id: string
    fromUserId: string
    toUserId: string
    text: string
    createdAt?: Date | string
  }

  export type DirectMessageUncheckedCreateInput = {
    id: string
    fromUserId: string
    toUserId: string
    text: string
    createdAt?: Date | string
  }

  export type DirectMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyInput = {
    id: string
    fromUserId: string
    toUserId: string
    text: string
    createdAt?: Date | string
  }

  export type DirectMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    likes?: LikeCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageCreateInput = {
    id?: string
    url: string
    index?: number
    post: PostCreateNestedOneWithoutImagesInput
  }

  export type PostImageUncheckedCreateInput = {
    id?: string
    postId: string
    url: string
    index?: number
  }

  export type PostImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutImagesNestedInput
  }

  export type PostImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PostImageCreateManyInput = {
    id?: string
    postId: string
    url: string
    index?: number
  }

  export type PostImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PostImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
  }

  export type LikeCreateInput = {
    id?: string
    userId: string
    type?: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    type?: string
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    postId: string
    userId: string
    type?: string
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollCreateInput = {
    id?: string
    clubBookId?: string | null
    city?: string
    userId: string
    question: string
    description?: string | null
    imageUrl?: string | null
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: Date | string
    options?: PollOptionCreateNestedManyWithoutPollInput
    votes?: PollVoteCreateNestedManyWithoutPollInput
  }

  export type PollUncheckedCreateInput = {
    id?: string
    clubBookId?: string | null
    city?: string
    userId: string
    question: string
    description?: string | null
    imageUrl?: string | null
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: Date | string
    options?: PollOptionUncheckedCreateNestedManyWithoutPollInput
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput
  }

  export type PollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: PollOptionUpdateManyWithoutPollNestedInput
    votes?: PollVoteUpdateManyWithoutPollNestedInput
  }

  export type PollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: PollOptionUncheckedUpdateManyWithoutPollNestedInput
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput
  }

  export type PollCreateManyInput = {
    id?: string
    clubBookId?: string | null
    city?: string
    userId: string
    question: string
    description?: string | null
    imageUrl?: string | null
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: Date | string
  }

  export type PollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollOptionCreateInput = {
    id?: string
    type?: string
    text: string
    imageUrl?: string | null
    index: number
    poll: PollCreateNestedOneWithoutOptionsInput
    book?: BookCreateNestedOneWithoutPollOptionsInput
    votes?: PollVoteCreateNestedManyWithoutOptionInput
  }

  export type PollOptionUncheckedCreateInput = {
    id?: string
    pollId: string
    type?: string
    text: string
    imageUrl?: string | null
    bookId?: string | null
    index: number
    votes?: PollVoteUncheckedCreateNestedManyWithoutOptionInput
  }

  export type PollOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
    poll?: PollUpdateOneRequiredWithoutOptionsNestedInput
    book?: BookUpdateOneWithoutPollOptionsNestedInput
    votes?: PollVoteUpdateManyWithoutOptionNestedInput
  }

  export type PollOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bookId?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
    votes?: PollVoteUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type PollOptionCreateManyInput = {
    id?: string
    pollId: string
    type?: string
    text: string
    imageUrl?: string | null
    bookId?: string | null
    index: number
  }

  export type PollOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PollOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bookId?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PollVoteCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    poll: PollCreateNestedOneWithoutVotesInput
    option: PollOptionCreateNestedOneWithoutVotesInput
  }

  export type PollVoteUncheckedCreateInput = {
    id?: string
    pollId: string
    optionId: string
    userId: string
    createdAt?: Date | string
  }

  export type PollVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poll?: PollUpdateOneRequiredWithoutVotesNestedInput
    option?: PollOptionUpdateOneRequiredWithoutVotesNestedInput
  }

  export type PollVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteCreateManyInput = {
    id?: string
    pollId: string
    optionId: string
    userId: string
    createdAt?: Date | string
  }

  export type PollVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventCreateInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    clubBook?: ClubBookCreateNestedOneWithoutEventsInput
    participants?: ClubEventParticipantCreateNestedManyWithoutEventInput
    photos?: ClubEventPhotoCreateNestedManyWithoutEventInput
  }

  export type ClubEventUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    clubBookId?: string | null
    createdById: string
    createdAt?: Date | string
    participants?: ClubEventParticipantUncheckedCreateNestedManyWithoutEventInput
    photos?: ClubEventPhotoUncheckedCreateNestedManyWithoutEventInput
  }

  export type ClubEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubBook?: ClubBookUpdateOneWithoutEventsNestedInput
    participants?: ClubEventParticipantUpdateManyWithoutEventNestedInput
    photos?: ClubEventPhotoUpdateManyWithoutEventNestedInput
  }

  export type ClubEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ClubEventParticipantUncheckedUpdateManyWithoutEventNestedInput
    photos?: ClubEventPhotoUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ClubEventCreateManyInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    clubBookId?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type ClubEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventParticipantCreateInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
    event: ClubEventCreateNestedOneWithoutParticipantsInput
  }

  export type ClubEventParticipantUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type ClubEventParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: ClubEventUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ClubEventParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventParticipantCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type ClubEventParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventPhotoCreateInput = {
    id?: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
    event: ClubEventCreateNestedOneWithoutPhotosInput
    user: UserCreateNestedOneWithoutClubEventPhotosInput
  }

  export type ClubEventPhotoUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type ClubEventPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: ClubEventUpdateOneRequiredWithoutPhotosNestedInput
    user?: UserUpdateOneRequiredWithoutClubEventPhotosNestedInput
  }

  export type ClubEventPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventPhotoCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type ClubEventPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCityListRelationFilter = {
    every?: UserCityWhereInput
    some?: UserCityWhereInput
    none?: UserCityWhereInput
  }

  export type BookListRelationFilter = {
    every?: BookWhereInput
    some?: BookWhereInput
    none?: BookWhereInput
  }

  export type ClubBookListRelationFilter = {
    every?: ClubBookWhereInput
    some?: ClubBookWhereInput
    none?: ClubBookWhereInput
  }

  export type ClubEventPhotoListRelationFilter = {
    every?: ClubEventPhotoWhereInput
    some?: ClubEventPhotoWhereInput
    none?: ClubEventPhotoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubEventPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    isAdmin?: SortOrder
    passwordHash?: SortOrder
    passwordResetCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    isAdmin?: SortOrder
    passwordHash?: SortOrder
    passwordResetCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    isAdmin?: SortOrder
    passwordHash?: SortOrder
    passwordResetCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserCityUserIdCityCompoundUniqueInput = {
    userId: string
    city: string
  }

  export type UserCityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    city?: SortOrder
  }

  export type UserCityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    city?: SortOrder
  }

  export type UserCityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    city?: SortOrder
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type BookStyleImageListRelationFilter = {
    every?: BookStyleImageWhereInput
    some?: BookStyleImageWhereInput
    none?: BookStyleImageWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PollOptionListRelationFilter = {
    every?: PollOptionWhereInput
    some?: PollOptionWhereInput
    none?: PollOptionWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookStyleImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PollOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookTitleAuthorCompoundUniqueInput = {
    title: string
    author: string
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    synopsis?: SortOrder
    aiStyleDescription?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    synopsis?: SortOrder
    aiStyleDescription?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    synopsis?: SortOrder
    aiStyleDescription?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
  }

  export type BookScalarRelationFilter = {
    is?: BookWhereInput
    isNot?: BookWhereInput
  }

  export type BookStyleImageCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    url?: SortOrder
  }

  export type BookStyleImageMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    url?: SortOrder
  }

  export type BookStyleImageMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    url?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MembershipListRelationFilter = {
    every?: MembershipWhereInput
    some?: MembershipWhereInput
    none?: MembershipWhereInput
  }

  export type GroupInviteListRelationFilter = {
    every?: GroupInviteWhereInput
    some?: GroupInviteWhereInput
    none?: GroupInviteWhereInput
  }

  export type JoinRequestListRelationFilter = {
    every?: JoinRequestWhereInput
    some?: JoinRequestWhereInput
    none?: JoinRequestWhereInput
  }

  export type GroupBookOfMonthSelectionListRelationFilter = {
    every?: GroupBookOfMonthSelectionWhereInput
    some?: GroupBookOfMonthSelectionWhereInput
    none?: GroupBookOfMonthSelectionWhereInput
  }

  export type MembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JoinRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupBookOfMonthSelectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type MembershipGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type JoinRequestGroupIdUserIdStatusCompoundUniqueInput = {
    groupId: string
    userId: string
    status: string
  }

  export type JoinRequestCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type JoinRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type JoinRequestMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type GroupInviteCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type GroupInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type GroupInviteMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type GroupBookOfMonthSelectionCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    bookId?: SortOrder
    setByUserId?: SortOrder
    setAt?: SortOrder
  }

  export type GroupBookOfMonthSelectionMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    bookId?: SortOrder
    setByUserId?: SortOrder
    setAt?: SortOrder
  }

  export type GroupBookOfMonthSelectionMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    bookId?: SortOrder
    setByUserId?: SortOrder
    setAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClubBookMessageListRelationFilter = {
    every?: ClubBookMessageWhereInput
    some?: ClubBookMessageWhereInput
    none?: ClubBookMessageWhereInput
  }

  export type ClubBookArtifactListRelationFilter = {
    every?: ClubBookArtifactWhereInput
    some?: ClubBookArtifactWhereInput
    none?: ClubBookArtifactWhereInput
  }

  export type ClubEventListRelationFilter = {
    every?: ClubEventWhereInput
    some?: ClubEventWhereInput
    none?: ClubEventWhereInput
  }

  export type ClubBookMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubBookArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubBookCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    colorKey?: SortOrder
    city?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
    activatedAt?: SortOrder
  }

  export type ClubBookAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type ClubBookMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    colorKey?: SortOrder
    city?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
    activatedAt?: SortOrder
  }

  export type ClubBookMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    colorKey?: SortOrder
    city?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdByUserId?: SortOrder
    indicationComment?: SortOrder
    createdAt?: SortOrder
    activatedAt?: SortOrder
  }

  export type ClubBookSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ClubBookScalarRelationFilter = {
    is?: ClubBookWhereInput
    isNot?: ClubBookWhereInput
  }

  export type ClubBookMessageCountOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubBookMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubBookMessageMinOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubBookArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubBookArtifactAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type ClubBookArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubBookArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubBookArtifactSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type ChannelMessageListRelationFilter = {
    every?: ChannelMessageWhereInput
    some?: ChannelMessageWhereInput
    none?: ChannelMessageWhereInput
  }

  export type ChannelMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cityCode?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cityCode?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cityCode?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelScalarRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type ChannelMessageCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelMessageMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type PostImageListRelationFilter = {
    every?: PostImageWhereInput
    some?: PostImageWhereInput
    none?: PostImageWhereInput
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    clubBookId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    clubBookId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    clubBookId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type PostImageCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    index?: SortOrder
  }

  export type PostImageAvgOrderByAggregateInput = {
    index?: SortOrder
  }

  export type PostImageMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    index?: SortOrder
  }

  export type PostImageMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    index?: SortOrder
  }

  export type PostImageSumOrderByAggregateInput = {
    index?: SortOrder
  }

  export type LikePostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteListRelationFilter = {
    every?: PollVoteWhereInput
    some?: PollVoteWhereInput
    none?: PollVoteWhereInput
  }

  export type PollVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PollCountOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    city?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    multiChoice?: SortOrder
    publicVotes?: SortOrder
    createdAt?: SortOrder
  }

  export type PollMaxOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    city?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    multiChoice?: SortOrder
    publicVotes?: SortOrder
    createdAt?: SortOrder
  }

  export type PollMinOrderByAggregateInput = {
    id?: SortOrder
    clubBookId?: SortOrder
    city?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    multiChoice?: SortOrder
    publicVotes?: SortOrder
    createdAt?: SortOrder
  }

  export type PollScalarRelationFilter = {
    is?: PollWhereInput
    isNot?: PollWhereInput
  }

  export type BookNullableScalarRelationFilter = {
    is?: BookWhereInput | null
    isNot?: BookWhereInput | null
  }

  export type PollOptionCountOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    type?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    bookId?: SortOrder
    index?: SortOrder
  }

  export type PollOptionAvgOrderByAggregateInput = {
    index?: SortOrder
  }

  export type PollOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    type?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    bookId?: SortOrder
    index?: SortOrder
  }

  export type PollOptionMinOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    type?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    bookId?: SortOrder
    index?: SortOrder
  }

  export type PollOptionSumOrderByAggregateInput = {
    index?: SortOrder
  }

  export type PollOptionScalarRelationFilter = {
    is?: PollOptionWhereInput
    isNot?: PollOptionWhereInput
  }

  export type PollVotePollIdUserIdOptionIdCompoundUniqueInput = {
    pollId: string
    userId: string
    optionId: string
  }

  export type PollVoteCountOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    optionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    optionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteMinOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    optionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ClubBookNullableScalarRelationFilter = {
    is?: ClubBookWhereInput | null
    isNot?: ClubBookWhereInput | null
  }

  export type ClubEventParticipantListRelationFilter = {
    every?: ClubEventParticipantWhereInput
    some?: ClubEventParticipantWhereInput
    none?: ClubEventParticipantWhereInput
  }

  export type ClubEventParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    location?: SortOrder
    addressStreet?: SortOrder
    addressNumber?: SortOrder
    addressDistrict?: SortOrder
    addressCity?: SortOrder
    addressState?: SortOrder
    addressZip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    clubBookId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ClubEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    location?: SortOrder
    addressStreet?: SortOrder
    addressNumber?: SortOrder
    addressDistrict?: SortOrder
    addressCity?: SortOrder
    addressState?: SortOrder
    addressZip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    clubBookId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    location?: SortOrder
    addressStreet?: SortOrder
    addressNumber?: SortOrder
    addressDistrict?: SortOrder
    addressCity?: SortOrder
    addressState?: SortOrder
    addressZip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    clubBookId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ClubEventScalarRelationFilter = {
    is?: ClubEventWhereInput
    isNot?: ClubEventWhereInput
  }

  export type ClubEventParticipantEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type ClubEventParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ClubEventPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCityCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCityCreateWithoutUserInput, UserCityUncheckedCreateWithoutUserInput> | UserCityCreateWithoutUserInput[] | UserCityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCityCreateOrConnectWithoutUserInput | UserCityCreateOrConnectWithoutUserInput[]
    createMany?: UserCityCreateManyUserInputEnvelope
    connect?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
  }

  export type BookCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<BookCreateWithoutCreatedByUserInput, BookUncheckedCreateWithoutCreatedByUserInput> | BookCreateWithoutCreatedByUserInput[] | BookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByUserInput | BookCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: BookCreateManyCreatedByUserInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type ClubBookCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ClubBookCreateWithoutCreatedByUserInput, ClubBookUncheckedCreateWithoutCreatedByUserInput> | ClubBookCreateWithoutCreatedByUserInput[] | ClubBookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutCreatedByUserInput | ClubBookCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ClubBookCreateManyCreatedByUserInputEnvelope
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
  }

  export type ClubEventPhotoCreateNestedManyWithoutUserInput = {
    create?: XOR<ClubEventPhotoCreateWithoutUserInput, ClubEventPhotoUncheckedCreateWithoutUserInput> | ClubEventPhotoCreateWithoutUserInput[] | ClubEventPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutUserInput | ClubEventPhotoCreateOrConnectWithoutUserInput[]
    createMany?: ClubEventPhotoCreateManyUserInputEnvelope
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
  }

  export type UserCityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCityCreateWithoutUserInput, UserCityUncheckedCreateWithoutUserInput> | UserCityCreateWithoutUserInput[] | UserCityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCityCreateOrConnectWithoutUserInput | UserCityCreateOrConnectWithoutUserInput[]
    createMany?: UserCityCreateManyUserInputEnvelope
    connect?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<BookCreateWithoutCreatedByUserInput, BookUncheckedCreateWithoutCreatedByUserInput> | BookCreateWithoutCreatedByUserInput[] | BookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByUserInput | BookCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: BookCreateManyCreatedByUserInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type ClubBookUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ClubBookCreateWithoutCreatedByUserInput, ClubBookUncheckedCreateWithoutCreatedByUserInput> | ClubBookCreateWithoutCreatedByUserInput[] | ClubBookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutCreatedByUserInput | ClubBookCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ClubBookCreateManyCreatedByUserInputEnvelope
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
  }

  export type ClubEventPhotoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClubEventPhotoCreateWithoutUserInput, ClubEventPhotoUncheckedCreateWithoutUserInput> | ClubEventPhotoCreateWithoutUserInput[] | ClubEventPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutUserInput | ClubEventPhotoCreateOrConnectWithoutUserInput[]
    createMany?: ClubEventPhotoCreateManyUserInputEnvelope
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCityUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCityCreateWithoutUserInput, UserCityUncheckedCreateWithoutUserInput> | UserCityCreateWithoutUserInput[] | UserCityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCityCreateOrConnectWithoutUserInput | UserCityCreateOrConnectWithoutUserInput[]
    upsert?: UserCityUpsertWithWhereUniqueWithoutUserInput | UserCityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCityCreateManyUserInputEnvelope
    set?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    disconnect?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    delete?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    connect?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    update?: UserCityUpdateWithWhereUniqueWithoutUserInput | UserCityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCityUpdateManyWithWhereWithoutUserInput | UserCityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCityScalarWhereInput | UserCityScalarWhereInput[]
  }

  export type BookUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<BookCreateWithoutCreatedByUserInput, BookUncheckedCreateWithoutCreatedByUserInput> | BookCreateWithoutCreatedByUserInput[] | BookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByUserInput | BookCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCreatedByUserInput | BookUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: BookCreateManyCreatedByUserInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCreatedByUserInput | BookUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCreatedByUserInput | BookUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type ClubBookUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ClubBookCreateWithoutCreatedByUserInput, ClubBookUncheckedCreateWithoutCreatedByUserInput> | ClubBookCreateWithoutCreatedByUserInput[] | ClubBookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutCreatedByUserInput | ClubBookCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ClubBookUpsertWithWhereUniqueWithoutCreatedByUserInput | ClubBookUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ClubBookCreateManyCreatedByUserInputEnvelope
    set?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    disconnect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    delete?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    update?: ClubBookUpdateWithWhereUniqueWithoutCreatedByUserInput | ClubBookUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ClubBookUpdateManyWithWhereWithoutCreatedByUserInput | ClubBookUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ClubBookScalarWhereInput | ClubBookScalarWhereInput[]
  }

  export type ClubEventPhotoUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClubEventPhotoCreateWithoutUserInput, ClubEventPhotoUncheckedCreateWithoutUserInput> | ClubEventPhotoCreateWithoutUserInput[] | ClubEventPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutUserInput | ClubEventPhotoCreateOrConnectWithoutUserInput[]
    upsert?: ClubEventPhotoUpsertWithWhereUniqueWithoutUserInput | ClubEventPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClubEventPhotoCreateManyUserInputEnvelope
    set?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    disconnect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    delete?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    update?: ClubEventPhotoUpdateWithWhereUniqueWithoutUserInput | ClubEventPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClubEventPhotoUpdateManyWithWhereWithoutUserInput | ClubEventPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClubEventPhotoScalarWhereInput | ClubEventPhotoScalarWhereInput[]
  }

  export type UserCityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCityCreateWithoutUserInput, UserCityUncheckedCreateWithoutUserInput> | UserCityCreateWithoutUserInput[] | UserCityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCityCreateOrConnectWithoutUserInput | UserCityCreateOrConnectWithoutUserInput[]
    upsert?: UserCityUpsertWithWhereUniqueWithoutUserInput | UserCityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCityCreateManyUserInputEnvelope
    set?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    disconnect?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    delete?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    connect?: UserCityWhereUniqueInput | UserCityWhereUniqueInput[]
    update?: UserCityUpdateWithWhereUniqueWithoutUserInput | UserCityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCityUpdateManyWithWhereWithoutUserInput | UserCityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCityScalarWhereInput | UserCityScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<BookCreateWithoutCreatedByUserInput, BookUncheckedCreateWithoutCreatedByUserInput> | BookCreateWithoutCreatedByUserInput[] | BookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByUserInput | BookCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCreatedByUserInput | BookUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: BookCreateManyCreatedByUserInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCreatedByUserInput | BookUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCreatedByUserInput | BookUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type ClubBookUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ClubBookCreateWithoutCreatedByUserInput, ClubBookUncheckedCreateWithoutCreatedByUserInput> | ClubBookCreateWithoutCreatedByUserInput[] | ClubBookUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutCreatedByUserInput | ClubBookCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ClubBookUpsertWithWhereUniqueWithoutCreatedByUserInput | ClubBookUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ClubBookCreateManyCreatedByUserInputEnvelope
    set?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    disconnect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    delete?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    update?: ClubBookUpdateWithWhereUniqueWithoutCreatedByUserInput | ClubBookUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ClubBookUpdateManyWithWhereWithoutCreatedByUserInput | ClubBookUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ClubBookScalarWhereInput | ClubBookScalarWhereInput[]
  }

  export type ClubEventPhotoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClubEventPhotoCreateWithoutUserInput, ClubEventPhotoUncheckedCreateWithoutUserInput> | ClubEventPhotoCreateWithoutUserInput[] | ClubEventPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutUserInput | ClubEventPhotoCreateOrConnectWithoutUserInput[]
    upsert?: ClubEventPhotoUpsertWithWhereUniqueWithoutUserInput | ClubEventPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClubEventPhotoCreateManyUserInputEnvelope
    set?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    disconnect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    delete?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    update?: ClubEventPhotoUpdateWithWhereUniqueWithoutUserInput | ClubEventPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClubEventPhotoUpdateManyWithWhereWithoutUserInput | ClubEventPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClubEventPhotoScalarWhereInput | ClubEventPhotoScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCitiesInput = {
    create?: XOR<UserCreateWithoutCitiesInput, UserUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<UserCreateWithoutCitiesInput, UserUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCitiesInput
    upsert?: UserUpsertWithoutCitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCitiesInput, UserUpdateWithoutCitiesInput>, UserUncheckedUpdateWithoutCitiesInput>
  }

  export type CategoryCreateNestedManyWithoutBooksInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput> | CategoryCreateWithoutBooksInput[] | CategoryUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput | CategoryCreateOrConnectWithoutBooksInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type BookStyleImageCreateNestedManyWithoutBookInput = {
    create?: XOR<BookStyleImageCreateWithoutBookInput, BookStyleImageUncheckedCreateWithoutBookInput> | BookStyleImageCreateWithoutBookInput[] | BookStyleImageUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookStyleImageCreateOrConnectWithoutBookInput | BookStyleImageCreateOrConnectWithoutBookInput[]
    createMany?: BookStyleImageCreateManyBookInputEnvelope
    connect?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedBooksInput = {
    create?: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBooksInput
    connect?: UserWhereUniqueInput
  }

  export type ClubBookCreateNestedManyWithoutBookInput = {
    create?: XOR<ClubBookCreateWithoutBookInput, ClubBookUncheckedCreateWithoutBookInput> | ClubBookCreateWithoutBookInput[] | ClubBookUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutBookInput | ClubBookCreateOrConnectWithoutBookInput[]
    createMany?: ClubBookCreateManyBookInputEnvelope
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
  }

  export type PollOptionCreateNestedManyWithoutBookInput = {
    create?: XOR<PollOptionCreateWithoutBookInput, PollOptionUncheckedCreateWithoutBookInput> | PollOptionCreateWithoutBookInput[] | PollOptionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutBookInput | PollOptionCreateOrConnectWithoutBookInput[]
    createMany?: PollOptionCreateManyBookInputEnvelope
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutBooksInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput> | CategoryCreateWithoutBooksInput[] | CategoryUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput | CategoryCreateOrConnectWithoutBooksInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type BookStyleImageUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<BookStyleImageCreateWithoutBookInput, BookStyleImageUncheckedCreateWithoutBookInput> | BookStyleImageCreateWithoutBookInput[] | BookStyleImageUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookStyleImageCreateOrConnectWithoutBookInput | BookStyleImageCreateOrConnectWithoutBookInput[]
    createMany?: BookStyleImageCreateManyBookInputEnvelope
    connect?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
  }

  export type ClubBookUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<ClubBookCreateWithoutBookInput, ClubBookUncheckedCreateWithoutBookInput> | ClubBookCreateWithoutBookInput[] | ClubBookUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutBookInput | ClubBookCreateOrConnectWithoutBookInput[]
    createMany?: ClubBookCreateManyBookInputEnvelope
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
  }

  export type PollOptionUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<PollOptionCreateWithoutBookInput, PollOptionUncheckedCreateWithoutBookInput> | PollOptionCreateWithoutBookInput[] | PollOptionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutBookInput | PollOptionCreateOrConnectWithoutBookInput[]
    createMany?: PollOptionCreateManyBookInputEnvelope
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
  }

  export type CategoryUpdateManyWithoutBooksNestedInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput> | CategoryCreateWithoutBooksInput[] | CategoryUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput | CategoryCreateOrConnectWithoutBooksInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBooksInput | CategoryUpsertWithWhereUniqueWithoutBooksInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBooksInput | CategoryUpdateWithWhereUniqueWithoutBooksInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBooksInput | CategoryUpdateManyWithWhereWithoutBooksInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type BookStyleImageUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookStyleImageCreateWithoutBookInput, BookStyleImageUncheckedCreateWithoutBookInput> | BookStyleImageCreateWithoutBookInput[] | BookStyleImageUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookStyleImageCreateOrConnectWithoutBookInput | BookStyleImageCreateOrConnectWithoutBookInput[]
    upsert?: BookStyleImageUpsertWithWhereUniqueWithoutBookInput | BookStyleImageUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookStyleImageCreateManyBookInputEnvelope
    set?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    disconnect?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    delete?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    connect?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    update?: BookStyleImageUpdateWithWhereUniqueWithoutBookInput | BookStyleImageUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookStyleImageUpdateManyWithWhereWithoutBookInput | BookStyleImageUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookStyleImageScalarWhereInput | BookStyleImageScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedBooksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBooksInput
    upsert?: UserUpsertWithoutCreatedBooksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBooksInput, UserUpdateWithoutCreatedBooksInput>, UserUncheckedUpdateWithoutCreatedBooksInput>
  }

  export type ClubBookUpdateManyWithoutBookNestedInput = {
    create?: XOR<ClubBookCreateWithoutBookInput, ClubBookUncheckedCreateWithoutBookInput> | ClubBookCreateWithoutBookInput[] | ClubBookUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutBookInput | ClubBookCreateOrConnectWithoutBookInput[]
    upsert?: ClubBookUpsertWithWhereUniqueWithoutBookInput | ClubBookUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: ClubBookCreateManyBookInputEnvelope
    set?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    disconnect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    delete?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    update?: ClubBookUpdateWithWhereUniqueWithoutBookInput | ClubBookUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: ClubBookUpdateManyWithWhereWithoutBookInput | ClubBookUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: ClubBookScalarWhereInput | ClubBookScalarWhereInput[]
  }

  export type PollOptionUpdateManyWithoutBookNestedInput = {
    create?: XOR<PollOptionCreateWithoutBookInput, PollOptionUncheckedCreateWithoutBookInput> | PollOptionCreateWithoutBookInput[] | PollOptionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutBookInput | PollOptionCreateOrConnectWithoutBookInput[]
    upsert?: PollOptionUpsertWithWhereUniqueWithoutBookInput | PollOptionUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: PollOptionCreateManyBookInputEnvelope
    set?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    disconnect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    delete?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    update?: PollOptionUpdateWithWhereUniqueWithoutBookInput | PollOptionUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: PollOptionUpdateManyWithWhereWithoutBookInput | PollOptionUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutBooksNestedInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput> | CategoryCreateWithoutBooksInput[] | CategoryUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput | CategoryCreateOrConnectWithoutBooksInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBooksInput | CategoryUpsertWithWhereUniqueWithoutBooksInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBooksInput | CategoryUpdateWithWhereUniqueWithoutBooksInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBooksInput | CategoryUpdateManyWithWhereWithoutBooksInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type BookStyleImageUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookStyleImageCreateWithoutBookInput, BookStyleImageUncheckedCreateWithoutBookInput> | BookStyleImageCreateWithoutBookInput[] | BookStyleImageUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookStyleImageCreateOrConnectWithoutBookInput | BookStyleImageCreateOrConnectWithoutBookInput[]
    upsert?: BookStyleImageUpsertWithWhereUniqueWithoutBookInput | BookStyleImageUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookStyleImageCreateManyBookInputEnvelope
    set?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    disconnect?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    delete?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    connect?: BookStyleImageWhereUniqueInput | BookStyleImageWhereUniqueInput[]
    update?: BookStyleImageUpdateWithWhereUniqueWithoutBookInput | BookStyleImageUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookStyleImageUpdateManyWithWhereWithoutBookInput | BookStyleImageUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookStyleImageScalarWhereInput | BookStyleImageScalarWhereInput[]
  }

  export type ClubBookUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<ClubBookCreateWithoutBookInput, ClubBookUncheckedCreateWithoutBookInput> | ClubBookCreateWithoutBookInput[] | ClubBookUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ClubBookCreateOrConnectWithoutBookInput | ClubBookCreateOrConnectWithoutBookInput[]
    upsert?: ClubBookUpsertWithWhereUniqueWithoutBookInput | ClubBookUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: ClubBookCreateManyBookInputEnvelope
    set?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    disconnect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    delete?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    connect?: ClubBookWhereUniqueInput | ClubBookWhereUniqueInput[]
    update?: ClubBookUpdateWithWhereUniqueWithoutBookInput | ClubBookUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: ClubBookUpdateManyWithWhereWithoutBookInput | ClubBookUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: ClubBookScalarWhereInput | ClubBookScalarWhereInput[]
  }

  export type PollOptionUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<PollOptionCreateWithoutBookInput, PollOptionUncheckedCreateWithoutBookInput> | PollOptionCreateWithoutBookInput[] | PollOptionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutBookInput | PollOptionCreateOrConnectWithoutBookInput[]
    upsert?: PollOptionUpsertWithWhereUniqueWithoutBookInput | PollOptionUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: PollOptionCreateManyBookInputEnvelope
    set?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    disconnect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    delete?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    update?: PollOptionUpdateWithWhereUniqueWithoutBookInput | PollOptionUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: PollOptionUpdateManyWithWhereWithoutBookInput | PollOptionUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[]
  }

  export type BookCreateNestedOneWithoutStyleImagesInput = {
    create?: XOR<BookCreateWithoutStyleImagesInput, BookUncheckedCreateWithoutStyleImagesInput>
    connectOrCreate?: BookCreateOrConnectWithoutStyleImagesInput
    connect?: BookWhereUniqueInput
  }

  export type BookUpdateOneRequiredWithoutStyleImagesNestedInput = {
    create?: XOR<BookCreateWithoutStyleImagesInput, BookUncheckedCreateWithoutStyleImagesInput>
    connectOrCreate?: BookCreateOrConnectWithoutStyleImagesInput
    upsert?: BookUpsertWithoutStyleImagesInput
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutStyleImagesInput, BookUpdateWithoutStyleImagesInput>, BookUncheckedUpdateWithoutStyleImagesInput>
  }

  export type BookCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<BookCreateWithoutCategoriesInput, BookUncheckedCreateWithoutCategoriesInput> | BookCreateWithoutCategoriesInput[] | BookUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoriesInput | BookCreateOrConnectWithoutCategoriesInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<BookCreateWithoutCategoriesInput, BookUncheckedCreateWithoutCategoriesInput> | BookCreateWithoutCategoriesInput[] | BookUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoriesInput | BookCreateOrConnectWithoutCategoriesInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<BookCreateWithoutCategoriesInput, BookUncheckedCreateWithoutCategoriesInput> | BookCreateWithoutCategoriesInput[] | BookUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoriesInput | BookCreateOrConnectWithoutCategoriesInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCategoriesInput | BookUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCategoriesInput | BookUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCategoriesInput | BookUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<BookCreateWithoutCategoriesInput, BookUncheckedCreateWithoutCategoriesInput> | BookCreateWithoutCategoriesInput[] | BookUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoriesInput | BookCreateOrConnectWithoutCategoriesInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCategoriesInput | BookUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCategoriesInput | BookUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCategoriesInput | BookUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type MembershipCreateNestedManyWithoutGroupInput = {
    create?: XOR<MembershipCreateWithoutGroupInput, MembershipUncheckedCreateWithoutGroupInput> | MembershipCreateWithoutGroupInput[] | MembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutGroupInput | MembershipCreateOrConnectWithoutGroupInput[]
    createMany?: MembershipCreateManyGroupInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type GroupInviteCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupInviteCreateWithoutGroupInput, GroupInviteUncheckedCreateWithoutGroupInput> | GroupInviteCreateWithoutGroupInput[] | GroupInviteUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupInviteCreateOrConnectWithoutGroupInput | GroupInviteCreateOrConnectWithoutGroupInput[]
    createMany?: GroupInviteCreateManyGroupInputEnvelope
    connect?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
  }

  export type JoinRequestCreateNestedManyWithoutGroupInput = {
    create?: XOR<JoinRequestCreateWithoutGroupInput, JoinRequestUncheckedCreateWithoutGroupInput> | JoinRequestCreateWithoutGroupInput[] | JoinRequestUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutGroupInput | JoinRequestCreateOrConnectWithoutGroupInput[]
    createMany?: JoinRequestCreateManyGroupInputEnvelope
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
  }

  export type GroupBookOfMonthSelectionCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupBookOfMonthSelectionCreateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput> | GroupBookOfMonthSelectionCreateWithoutGroupInput[] | GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput | GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput[]
    createMany?: GroupBookOfMonthSelectionCreateManyGroupInputEnvelope
    connect?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
  }

  export type MembershipUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<MembershipCreateWithoutGroupInput, MembershipUncheckedCreateWithoutGroupInput> | MembershipCreateWithoutGroupInput[] | MembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutGroupInput | MembershipCreateOrConnectWithoutGroupInput[]
    createMany?: MembershipCreateManyGroupInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type GroupInviteUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupInviteCreateWithoutGroupInput, GroupInviteUncheckedCreateWithoutGroupInput> | GroupInviteCreateWithoutGroupInput[] | GroupInviteUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupInviteCreateOrConnectWithoutGroupInput | GroupInviteCreateOrConnectWithoutGroupInput[]
    createMany?: GroupInviteCreateManyGroupInputEnvelope
    connect?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
  }

  export type JoinRequestUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<JoinRequestCreateWithoutGroupInput, JoinRequestUncheckedCreateWithoutGroupInput> | JoinRequestCreateWithoutGroupInput[] | JoinRequestUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutGroupInput | JoinRequestCreateOrConnectWithoutGroupInput[]
    createMany?: JoinRequestCreateManyGroupInputEnvelope
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
  }

  export type GroupBookOfMonthSelectionUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupBookOfMonthSelectionCreateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput> | GroupBookOfMonthSelectionCreateWithoutGroupInput[] | GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput | GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput[]
    createMany?: GroupBookOfMonthSelectionCreateManyGroupInputEnvelope
    connect?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
  }

  export type MembershipUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MembershipCreateWithoutGroupInput, MembershipUncheckedCreateWithoutGroupInput> | MembershipCreateWithoutGroupInput[] | MembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutGroupInput | MembershipCreateOrConnectWithoutGroupInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutGroupInput | MembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MembershipCreateManyGroupInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutGroupInput | MembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutGroupInput | MembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type GroupInviteUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupInviteCreateWithoutGroupInput, GroupInviteUncheckedCreateWithoutGroupInput> | GroupInviteCreateWithoutGroupInput[] | GroupInviteUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupInviteCreateOrConnectWithoutGroupInput | GroupInviteCreateOrConnectWithoutGroupInput[]
    upsert?: GroupInviteUpsertWithWhereUniqueWithoutGroupInput | GroupInviteUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupInviteCreateManyGroupInputEnvelope
    set?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    disconnect?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    delete?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    connect?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    update?: GroupInviteUpdateWithWhereUniqueWithoutGroupInput | GroupInviteUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupInviteUpdateManyWithWhereWithoutGroupInput | GroupInviteUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupInviteScalarWhereInput | GroupInviteScalarWhereInput[]
  }

  export type JoinRequestUpdateManyWithoutGroupNestedInput = {
    create?: XOR<JoinRequestCreateWithoutGroupInput, JoinRequestUncheckedCreateWithoutGroupInput> | JoinRequestCreateWithoutGroupInput[] | JoinRequestUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutGroupInput | JoinRequestCreateOrConnectWithoutGroupInput[]
    upsert?: JoinRequestUpsertWithWhereUniqueWithoutGroupInput | JoinRequestUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: JoinRequestCreateManyGroupInputEnvelope
    set?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    disconnect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    delete?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    update?: JoinRequestUpdateWithWhereUniqueWithoutGroupInput | JoinRequestUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: JoinRequestUpdateManyWithWhereWithoutGroupInput | JoinRequestUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
  }

  export type GroupBookOfMonthSelectionUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupBookOfMonthSelectionCreateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput> | GroupBookOfMonthSelectionCreateWithoutGroupInput[] | GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput | GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput[]
    upsert?: GroupBookOfMonthSelectionUpsertWithWhereUniqueWithoutGroupInput | GroupBookOfMonthSelectionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupBookOfMonthSelectionCreateManyGroupInputEnvelope
    set?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    disconnect?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    delete?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    connect?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    update?: GroupBookOfMonthSelectionUpdateWithWhereUniqueWithoutGroupInput | GroupBookOfMonthSelectionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupBookOfMonthSelectionUpdateManyWithWhereWithoutGroupInput | GroupBookOfMonthSelectionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupBookOfMonthSelectionScalarWhereInput | GroupBookOfMonthSelectionScalarWhereInput[]
  }

  export type MembershipUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MembershipCreateWithoutGroupInput, MembershipUncheckedCreateWithoutGroupInput> | MembershipCreateWithoutGroupInput[] | MembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutGroupInput | MembershipCreateOrConnectWithoutGroupInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutGroupInput | MembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MembershipCreateManyGroupInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutGroupInput | MembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutGroupInput | MembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type GroupInviteUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupInviteCreateWithoutGroupInput, GroupInviteUncheckedCreateWithoutGroupInput> | GroupInviteCreateWithoutGroupInput[] | GroupInviteUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupInviteCreateOrConnectWithoutGroupInput | GroupInviteCreateOrConnectWithoutGroupInput[]
    upsert?: GroupInviteUpsertWithWhereUniqueWithoutGroupInput | GroupInviteUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupInviteCreateManyGroupInputEnvelope
    set?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    disconnect?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    delete?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    connect?: GroupInviteWhereUniqueInput | GroupInviteWhereUniqueInput[]
    update?: GroupInviteUpdateWithWhereUniqueWithoutGroupInput | GroupInviteUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupInviteUpdateManyWithWhereWithoutGroupInput | GroupInviteUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupInviteScalarWhereInput | GroupInviteScalarWhereInput[]
  }

  export type JoinRequestUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<JoinRequestCreateWithoutGroupInput, JoinRequestUncheckedCreateWithoutGroupInput> | JoinRequestCreateWithoutGroupInput[] | JoinRequestUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutGroupInput | JoinRequestCreateOrConnectWithoutGroupInput[]
    upsert?: JoinRequestUpsertWithWhereUniqueWithoutGroupInput | JoinRequestUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: JoinRequestCreateManyGroupInputEnvelope
    set?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    disconnect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    delete?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    update?: JoinRequestUpdateWithWhereUniqueWithoutGroupInput | JoinRequestUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: JoinRequestUpdateManyWithWhereWithoutGroupInput | JoinRequestUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
  }

  export type GroupBookOfMonthSelectionUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupBookOfMonthSelectionCreateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput> | GroupBookOfMonthSelectionCreateWithoutGroupInput[] | GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput | GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput[]
    upsert?: GroupBookOfMonthSelectionUpsertWithWhereUniqueWithoutGroupInput | GroupBookOfMonthSelectionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupBookOfMonthSelectionCreateManyGroupInputEnvelope
    set?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    disconnect?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    delete?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    connect?: GroupBookOfMonthSelectionWhereUniqueInput | GroupBookOfMonthSelectionWhereUniqueInput[]
    update?: GroupBookOfMonthSelectionUpdateWithWhereUniqueWithoutGroupInput | GroupBookOfMonthSelectionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupBookOfMonthSelectionUpdateManyWithWhereWithoutGroupInput | GroupBookOfMonthSelectionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupBookOfMonthSelectionScalarWhereInput | GroupBookOfMonthSelectionScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<GroupCreateWithoutMembershipsInput, GroupUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembershipsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<GroupCreateWithoutMembershipsInput, GroupUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembershipsInput
    upsert?: GroupUpsertWithoutMembershipsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembershipsInput, GroupUpdateWithoutMembershipsInput>, GroupUncheckedUpdateWithoutMembershipsInput>
  }

  export type GroupCreateNestedOneWithoutJoinRequestsInput = {
    create?: XOR<GroupCreateWithoutJoinRequestsInput, GroupUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutJoinRequestsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutJoinRequestsNestedInput = {
    create?: XOR<GroupCreateWithoutJoinRequestsInput, GroupUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutJoinRequestsInput
    upsert?: GroupUpsertWithoutJoinRequestsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutJoinRequestsInput, GroupUpdateWithoutJoinRequestsInput>, GroupUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type GroupCreateNestedOneWithoutInvitesInput = {
    create?: XOR<GroupCreateWithoutInvitesInput, GroupUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutInvitesInput
    connect?: GroupWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type GroupUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<GroupCreateWithoutInvitesInput, GroupUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutInvitesInput
    upsert?: GroupUpsertWithoutInvitesInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutInvitesInput, GroupUpdateWithoutInvitesInput>, GroupUncheckedUpdateWithoutInvitesInput>
  }

  export type GroupCreateNestedOneWithoutBookOfMonthSelectionsInput = {
    create?: XOR<GroupCreateWithoutBookOfMonthSelectionsInput, GroupUncheckedCreateWithoutBookOfMonthSelectionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutBookOfMonthSelectionsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutBookOfMonthSelectionsNestedInput = {
    create?: XOR<GroupCreateWithoutBookOfMonthSelectionsInput, GroupUncheckedCreateWithoutBookOfMonthSelectionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutBookOfMonthSelectionsInput
    upsert?: GroupUpsertWithoutBookOfMonthSelectionsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutBookOfMonthSelectionsInput, GroupUpdateWithoutBookOfMonthSelectionsInput>, GroupUncheckedUpdateWithoutBookOfMonthSelectionsInput>
  }

  export type UserCreateNestedOneWithoutCreatedClubBooksInput = {
    create?: XOR<UserCreateWithoutCreatedClubBooksInput, UserUncheckedCreateWithoutCreatedClubBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClubBooksInput
    connect?: UserWhereUniqueInput
  }

  export type BookCreateNestedOneWithoutClubBooksInput = {
    create?: XOR<BookCreateWithoutClubBooksInput, BookUncheckedCreateWithoutClubBooksInput>
    connectOrCreate?: BookCreateOrConnectWithoutClubBooksInput
    connect?: BookWhereUniqueInput
  }

  export type ClubBookMessageCreateNestedManyWithoutClubBookInput = {
    create?: XOR<ClubBookMessageCreateWithoutClubBookInput, ClubBookMessageUncheckedCreateWithoutClubBookInput> | ClubBookMessageCreateWithoutClubBookInput[] | ClubBookMessageUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookMessageCreateOrConnectWithoutClubBookInput | ClubBookMessageCreateOrConnectWithoutClubBookInput[]
    createMany?: ClubBookMessageCreateManyClubBookInputEnvelope
    connect?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
  }

  export type ClubBookArtifactCreateNestedManyWithoutClubBookInput = {
    create?: XOR<ClubBookArtifactCreateWithoutClubBookInput, ClubBookArtifactUncheckedCreateWithoutClubBookInput> | ClubBookArtifactCreateWithoutClubBookInput[] | ClubBookArtifactUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookArtifactCreateOrConnectWithoutClubBookInput | ClubBookArtifactCreateOrConnectWithoutClubBookInput[]
    createMany?: ClubBookArtifactCreateManyClubBookInputEnvelope
    connect?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
  }

  export type ClubEventCreateNestedManyWithoutClubBookInput = {
    create?: XOR<ClubEventCreateWithoutClubBookInput, ClubEventUncheckedCreateWithoutClubBookInput> | ClubEventCreateWithoutClubBookInput[] | ClubEventUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubEventCreateOrConnectWithoutClubBookInput | ClubEventCreateOrConnectWithoutClubBookInput[]
    createMany?: ClubEventCreateManyClubBookInputEnvelope
    connect?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
  }

  export type ClubBookMessageUncheckedCreateNestedManyWithoutClubBookInput = {
    create?: XOR<ClubBookMessageCreateWithoutClubBookInput, ClubBookMessageUncheckedCreateWithoutClubBookInput> | ClubBookMessageCreateWithoutClubBookInput[] | ClubBookMessageUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookMessageCreateOrConnectWithoutClubBookInput | ClubBookMessageCreateOrConnectWithoutClubBookInput[]
    createMany?: ClubBookMessageCreateManyClubBookInputEnvelope
    connect?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
  }

  export type ClubBookArtifactUncheckedCreateNestedManyWithoutClubBookInput = {
    create?: XOR<ClubBookArtifactCreateWithoutClubBookInput, ClubBookArtifactUncheckedCreateWithoutClubBookInput> | ClubBookArtifactCreateWithoutClubBookInput[] | ClubBookArtifactUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookArtifactCreateOrConnectWithoutClubBookInput | ClubBookArtifactCreateOrConnectWithoutClubBookInput[]
    createMany?: ClubBookArtifactCreateManyClubBookInputEnvelope
    connect?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
  }

  export type ClubEventUncheckedCreateNestedManyWithoutClubBookInput = {
    create?: XOR<ClubEventCreateWithoutClubBookInput, ClubEventUncheckedCreateWithoutClubBookInput> | ClubEventCreateWithoutClubBookInput[] | ClubEventUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubEventCreateOrConnectWithoutClubBookInput | ClubEventCreateOrConnectWithoutClubBookInput[]
    createMany?: ClubEventCreateManyClubBookInputEnvelope
    connect?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreatedClubBooksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedClubBooksInput, UserUncheckedCreateWithoutCreatedClubBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClubBooksInput
    upsert?: UserUpsertWithoutCreatedClubBooksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedClubBooksInput, UserUpdateWithoutCreatedClubBooksInput>, UserUncheckedUpdateWithoutCreatedClubBooksInput>
  }

  export type BookUpdateOneRequiredWithoutClubBooksNestedInput = {
    create?: XOR<BookCreateWithoutClubBooksInput, BookUncheckedCreateWithoutClubBooksInput>
    connectOrCreate?: BookCreateOrConnectWithoutClubBooksInput
    upsert?: BookUpsertWithoutClubBooksInput
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutClubBooksInput, BookUpdateWithoutClubBooksInput>, BookUncheckedUpdateWithoutClubBooksInput>
  }

  export type ClubBookMessageUpdateManyWithoutClubBookNestedInput = {
    create?: XOR<ClubBookMessageCreateWithoutClubBookInput, ClubBookMessageUncheckedCreateWithoutClubBookInput> | ClubBookMessageCreateWithoutClubBookInput[] | ClubBookMessageUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookMessageCreateOrConnectWithoutClubBookInput | ClubBookMessageCreateOrConnectWithoutClubBookInput[]
    upsert?: ClubBookMessageUpsertWithWhereUniqueWithoutClubBookInput | ClubBookMessageUpsertWithWhereUniqueWithoutClubBookInput[]
    createMany?: ClubBookMessageCreateManyClubBookInputEnvelope
    set?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    disconnect?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    delete?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    connect?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    update?: ClubBookMessageUpdateWithWhereUniqueWithoutClubBookInput | ClubBookMessageUpdateWithWhereUniqueWithoutClubBookInput[]
    updateMany?: ClubBookMessageUpdateManyWithWhereWithoutClubBookInput | ClubBookMessageUpdateManyWithWhereWithoutClubBookInput[]
    deleteMany?: ClubBookMessageScalarWhereInput | ClubBookMessageScalarWhereInput[]
  }

  export type ClubBookArtifactUpdateManyWithoutClubBookNestedInput = {
    create?: XOR<ClubBookArtifactCreateWithoutClubBookInput, ClubBookArtifactUncheckedCreateWithoutClubBookInput> | ClubBookArtifactCreateWithoutClubBookInput[] | ClubBookArtifactUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookArtifactCreateOrConnectWithoutClubBookInput | ClubBookArtifactCreateOrConnectWithoutClubBookInput[]
    upsert?: ClubBookArtifactUpsertWithWhereUniqueWithoutClubBookInput | ClubBookArtifactUpsertWithWhereUniqueWithoutClubBookInput[]
    createMany?: ClubBookArtifactCreateManyClubBookInputEnvelope
    set?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    disconnect?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    delete?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    connect?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    update?: ClubBookArtifactUpdateWithWhereUniqueWithoutClubBookInput | ClubBookArtifactUpdateWithWhereUniqueWithoutClubBookInput[]
    updateMany?: ClubBookArtifactUpdateManyWithWhereWithoutClubBookInput | ClubBookArtifactUpdateManyWithWhereWithoutClubBookInput[]
    deleteMany?: ClubBookArtifactScalarWhereInput | ClubBookArtifactScalarWhereInput[]
  }

  export type ClubEventUpdateManyWithoutClubBookNestedInput = {
    create?: XOR<ClubEventCreateWithoutClubBookInput, ClubEventUncheckedCreateWithoutClubBookInput> | ClubEventCreateWithoutClubBookInput[] | ClubEventUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubEventCreateOrConnectWithoutClubBookInput | ClubEventCreateOrConnectWithoutClubBookInput[]
    upsert?: ClubEventUpsertWithWhereUniqueWithoutClubBookInput | ClubEventUpsertWithWhereUniqueWithoutClubBookInput[]
    createMany?: ClubEventCreateManyClubBookInputEnvelope
    set?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    disconnect?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    delete?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    connect?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    update?: ClubEventUpdateWithWhereUniqueWithoutClubBookInput | ClubEventUpdateWithWhereUniqueWithoutClubBookInput[]
    updateMany?: ClubEventUpdateManyWithWhereWithoutClubBookInput | ClubEventUpdateManyWithWhereWithoutClubBookInput[]
    deleteMany?: ClubEventScalarWhereInput | ClubEventScalarWhereInput[]
  }

  export type ClubBookMessageUncheckedUpdateManyWithoutClubBookNestedInput = {
    create?: XOR<ClubBookMessageCreateWithoutClubBookInput, ClubBookMessageUncheckedCreateWithoutClubBookInput> | ClubBookMessageCreateWithoutClubBookInput[] | ClubBookMessageUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookMessageCreateOrConnectWithoutClubBookInput | ClubBookMessageCreateOrConnectWithoutClubBookInput[]
    upsert?: ClubBookMessageUpsertWithWhereUniqueWithoutClubBookInput | ClubBookMessageUpsertWithWhereUniqueWithoutClubBookInput[]
    createMany?: ClubBookMessageCreateManyClubBookInputEnvelope
    set?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    disconnect?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    delete?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    connect?: ClubBookMessageWhereUniqueInput | ClubBookMessageWhereUniqueInput[]
    update?: ClubBookMessageUpdateWithWhereUniqueWithoutClubBookInput | ClubBookMessageUpdateWithWhereUniqueWithoutClubBookInput[]
    updateMany?: ClubBookMessageUpdateManyWithWhereWithoutClubBookInput | ClubBookMessageUpdateManyWithWhereWithoutClubBookInput[]
    deleteMany?: ClubBookMessageScalarWhereInput | ClubBookMessageScalarWhereInput[]
  }

  export type ClubBookArtifactUncheckedUpdateManyWithoutClubBookNestedInput = {
    create?: XOR<ClubBookArtifactCreateWithoutClubBookInput, ClubBookArtifactUncheckedCreateWithoutClubBookInput> | ClubBookArtifactCreateWithoutClubBookInput[] | ClubBookArtifactUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubBookArtifactCreateOrConnectWithoutClubBookInput | ClubBookArtifactCreateOrConnectWithoutClubBookInput[]
    upsert?: ClubBookArtifactUpsertWithWhereUniqueWithoutClubBookInput | ClubBookArtifactUpsertWithWhereUniqueWithoutClubBookInput[]
    createMany?: ClubBookArtifactCreateManyClubBookInputEnvelope
    set?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    disconnect?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    delete?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    connect?: ClubBookArtifactWhereUniqueInput | ClubBookArtifactWhereUniqueInput[]
    update?: ClubBookArtifactUpdateWithWhereUniqueWithoutClubBookInput | ClubBookArtifactUpdateWithWhereUniqueWithoutClubBookInput[]
    updateMany?: ClubBookArtifactUpdateManyWithWhereWithoutClubBookInput | ClubBookArtifactUpdateManyWithWhereWithoutClubBookInput[]
    deleteMany?: ClubBookArtifactScalarWhereInput | ClubBookArtifactScalarWhereInput[]
  }

  export type ClubEventUncheckedUpdateManyWithoutClubBookNestedInput = {
    create?: XOR<ClubEventCreateWithoutClubBookInput, ClubEventUncheckedCreateWithoutClubBookInput> | ClubEventCreateWithoutClubBookInput[] | ClubEventUncheckedCreateWithoutClubBookInput[]
    connectOrCreate?: ClubEventCreateOrConnectWithoutClubBookInput | ClubEventCreateOrConnectWithoutClubBookInput[]
    upsert?: ClubEventUpsertWithWhereUniqueWithoutClubBookInput | ClubEventUpsertWithWhereUniqueWithoutClubBookInput[]
    createMany?: ClubEventCreateManyClubBookInputEnvelope
    set?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    disconnect?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    delete?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    connect?: ClubEventWhereUniqueInput | ClubEventWhereUniqueInput[]
    update?: ClubEventUpdateWithWhereUniqueWithoutClubBookInput | ClubEventUpdateWithWhereUniqueWithoutClubBookInput[]
    updateMany?: ClubEventUpdateManyWithWhereWithoutClubBookInput | ClubEventUpdateManyWithWhereWithoutClubBookInput[]
    deleteMany?: ClubEventScalarWhereInput | ClubEventScalarWhereInput[]
  }

  export type ClubBookCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ClubBookCreateWithoutMessagesInput, ClubBookUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClubBookCreateOrConnectWithoutMessagesInput
    connect?: ClubBookWhereUniqueInput
  }

  export type ClubBookUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ClubBookCreateWithoutMessagesInput, ClubBookUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClubBookCreateOrConnectWithoutMessagesInput
    upsert?: ClubBookUpsertWithoutMessagesInput
    connect?: ClubBookWhereUniqueInput
    update?: XOR<XOR<ClubBookUpdateToOneWithWhereWithoutMessagesInput, ClubBookUpdateWithoutMessagesInput>, ClubBookUncheckedUpdateWithoutMessagesInput>
  }

  export type ClubBookCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<ClubBookCreateWithoutArtifactsInput, ClubBookUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ClubBookCreateOrConnectWithoutArtifactsInput
    connect?: ClubBookWhereUniqueInput
  }

  export type ClubBookUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<ClubBookCreateWithoutArtifactsInput, ClubBookUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ClubBookCreateOrConnectWithoutArtifactsInput
    upsert?: ClubBookUpsertWithoutArtifactsInput
    connect?: ClubBookWhereUniqueInput
    update?: XOR<XOR<ClubBookUpdateToOneWithWhereWithoutArtifactsInput, ClubBookUpdateWithoutArtifactsInput>, ClubBookUncheckedUpdateWithoutArtifactsInput>
  }

  export type ChannelMessageCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMessageCreateWithoutChannelInput, ChannelMessageUncheckedCreateWithoutChannelInput> | ChannelMessageCreateWithoutChannelInput[] | ChannelMessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMessageCreateOrConnectWithoutChannelInput | ChannelMessageCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMessageCreateManyChannelInputEnvelope
    connect?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
  }

  export type ChannelMessageUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMessageCreateWithoutChannelInput, ChannelMessageUncheckedCreateWithoutChannelInput> | ChannelMessageCreateWithoutChannelInput[] | ChannelMessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMessageCreateOrConnectWithoutChannelInput | ChannelMessageCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMessageCreateManyChannelInputEnvelope
    connect?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
  }

  export type ChannelMessageUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMessageCreateWithoutChannelInput, ChannelMessageUncheckedCreateWithoutChannelInput> | ChannelMessageCreateWithoutChannelInput[] | ChannelMessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMessageCreateOrConnectWithoutChannelInput | ChannelMessageCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMessageUpsertWithWhereUniqueWithoutChannelInput | ChannelMessageUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMessageCreateManyChannelInputEnvelope
    set?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    disconnect?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    delete?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    connect?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    update?: ChannelMessageUpdateWithWhereUniqueWithoutChannelInput | ChannelMessageUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMessageUpdateManyWithWhereWithoutChannelInput | ChannelMessageUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMessageScalarWhereInput | ChannelMessageScalarWhereInput[]
  }

  export type ChannelMessageUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMessageCreateWithoutChannelInput, ChannelMessageUncheckedCreateWithoutChannelInput> | ChannelMessageCreateWithoutChannelInput[] | ChannelMessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMessageCreateOrConnectWithoutChannelInput | ChannelMessageCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMessageUpsertWithWhereUniqueWithoutChannelInput | ChannelMessageUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMessageCreateManyChannelInputEnvelope
    set?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    disconnect?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    delete?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    connect?: ChannelMessageWhereUniqueInput | ChannelMessageWhereUniqueInput[]
    update?: ChannelMessageUpdateWithWhereUniqueWithoutChannelInput | ChannelMessageUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMessageUpdateManyWithWhereWithoutChannelInput | ChannelMessageUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMessageScalarWhereInput | ChannelMessageScalarWhereInput[]
  }

  export type ChannelCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput
    connect?: ChannelWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput
    upsert?: ChannelUpsertWithoutMessagesInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutMessagesInput, ChannelUpdateWithoutMessagesInput>, ChannelUncheckedUpdateWithoutMessagesInput>
  }

  export type LikeCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostImageCreateNestedManyWithoutPostInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostImageUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
  }

  export type LikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostImageUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    upsert?: PostImageUpsertWithWhereUniqueWithoutPostInput | PostImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    set?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    disconnect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    delete?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    update?: PostImageUpdateWithWhereUniqueWithoutPostInput | PostImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostImageUpdateManyWithWhereWithoutPostInput | PostImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostImageUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    upsert?: PostImageUpsertWithWhereUniqueWithoutPostInput | PostImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    set?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    disconnect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    delete?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    update?: PostImageUpdateWithWhereUniqueWithoutPostInput | PostImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostImageUpdateManyWithWhereWithoutPostInput | PostImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutImagesInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    upsert?: PostUpsertWithoutImagesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutImagesInput, PostUpdateWithoutImagesInput>, PostUncheckedUpdateWithoutImagesInput>
  }

  export type PostCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    upsert?: PostUpsertWithoutLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PollOptionCreateNestedManyWithoutPollInput = {
    create?: XOR<PollOptionCreateWithoutPollInput, PollOptionUncheckedCreateWithoutPollInput> | PollOptionCreateWithoutPollInput[] | PollOptionUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutPollInput | PollOptionCreateOrConnectWithoutPollInput[]
    createMany?: PollOptionCreateManyPollInputEnvelope
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
  }

  export type PollVoteCreateNestedManyWithoutPollInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type PollOptionUncheckedCreateNestedManyWithoutPollInput = {
    create?: XOR<PollOptionCreateWithoutPollInput, PollOptionUncheckedCreateWithoutPollInput> | PollOptionCreateWithoutPollInput[] | PollOptionUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutPollInput | PollOptionCreateOrConnectWithoutPollInput[]
    createMany?: PollOptionCreateManyPollInputEnvelope
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
  }

  export type PollVoteUncheckedCreateNestedManyWithoutPollInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type PollOptionUpdateManyWithoutPollNestedInput = {
    create?: XOR<PollOptionCreateWithoutPollInput, PollOptionUncheckedCreateWithoutPollInput> | PollOptionCreateWithoutPollInput[] | PollOptionUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutPollInput | PollOptionCreateOrConnectWithoutPollInput[]
    upsert?: PollOptionUpsertWithWhereUniqueWithoutPollInput | PollOptionUpsertWithWhereUniqueWithoutPollInput[]
    createMany?: PollOptionCreateManyPollInputEnvelope
    set?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    disconnect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    delete?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    update?: PollOptionUpdateWithWhereUniqueWithoutPollInput | PollOptionUpdateWithWhereUniqueWithoutPollInput[]
    updateMany?: PollOptionUpdateManyWithWhereWithoutPollInput | PollOptionUpdateManyWithWhereWithoutPollInput[]
    deleteMany?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[]
  }

  export type PollVoteUpdateManyWithoutPollNestedInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutPollInput | PollVoteUpsertWithWhereUniqueWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutPollInput | PollVoteUpdateWithWhereUniqueWithoutPollInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutPollInput | PollVoteUpdateManyWithWhereWithoutPollInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type PollOptionUncheckedUpdateManyWithoutPollNestedInput = {
    create?: XOR<PollOptionCreateWithoutPollInput, PollOptionUncheckedCreateWithoutPollInput> | PollOptionCreateWithoutPollInput[] | PollOptionUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollOptionCreateOrConnectWithoutPollInput | PollOptionCreateOrConnectWithoutPollInput[]
    upsert?: PollOptionUpsertWithWhereUniqueWithoutPollInput | PollOptionUpsertWithWhereUniqueWithoutPollInput[]
    createMany?: PollOptionCreateManyPollInputEnvelope
    set?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    disconnect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    delete?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[]
    update?: PollOptionUpdateWithWhereUniqueWithoutPollInput | PollOptionUpdateWithWhereUniqueWithoutPollInput[]
    updateMany?: PollOptionUpdateManyWithWhereWithoutPollInput | PollOptionUpdateManyWithWhereWithoutPollInput[]
    deleteMany?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[]
  }

  export type PollVoteUncheckedUpdateManyWithoutPollNestedInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutPollInput | PollVoteUpsertWithWhereUniqueWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutPollInput | PollVoteUpdateWithWhereUniqueWithoutPollInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutPollInput | PollVoteUpdateManyWithWhereWithoutPollInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type PollCreateNestedOneWithoutOptionsInput = {
    create?: XOR<PollCreateWithoutOptionsInput, PollUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: PollCreateOrConnectWithoutOptionsInput
    connect?: PollWhereUniqueInput
  }

  export type BookCreateNestedOneWithoutPollOptionsInput = {
    create?: XOR<BookCreateWithoutPollOptionsInput, BookUncheckedCreateWithoutPollOptionsInput>
    connectOrCreate?: BookCreateOrConnectWithoutPollOptionsInput
    connect?: BookWhereUniqueInput
  }

  export type PollVoteCreateNestedManyWithoutOptionInput = {
    create?: XOR<PollVoteCreateWithoutOptionInput, PollVoteUncheckedCreateWithoutOptionInput> | PollVoteCreateWithoutOptionInput[] | PollVoteUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutOptionInput | PollVoteCreateOrConnectWithoutOptionInput[]
    createMany?: PollVoteCreateManyOptionInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type PollVoteUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<PollVoteCreateWithoutOptionInput, PollVoteUncheckedCreateWithoutOptionInput> | PollVoteCreateWithoutOptionInput[] | PollVoteUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutOptionInput | PollVoteCreateOrConnectWithoutOptionInput[]
    createMany?: PollVoteCreateManyOptionInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type PollUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<PollCreateWithoutOptionsInput, PollUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: PollCreateOrConnectWithoutOptionsInput
    upsert?: PollUpsertWithoutOptionsInput
    connect?: PollWhereUniqueInput
    update?: XOR<XOR<PollUpdateToOneWithWhereWithoutOptionsInput, PollUpdateWithoutOptionsInput>, PollUncheckedUpdateWithoutOptionsInput>
  }

  export type BookUpdateOneWithoutPollOptionsNestedInput = {
    create?: XOR<BookCreateWithoutPollOptionsInput, BookUncheckedCreateWithoutPollOptionsInput>
    connectOrCreate?: BookCreateOrConnectWithoutPollOptionsInput
    upsert?: BookUpsertWithoutPollOptionsInput
    disconnect?: BookWhereInput | boolean
    delete?: BookWhereInput | boolean
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutPollOptionsInput, BookUpdateWithoutPollOptionsInput>, BookUncheckedUpdateWithoutPollOptionsInput>
  }

  export type PollVoteUpdateManyWithoutOptionNestedInput = {
    create?: XOR<PollVoteCreateWithoutOptionInput, PollVoteUncheckedCreateWithoutOptionInput> | PollVoteCreateWithoutOptionInput[] | PollVoteUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutOptionInput | PollVoteCreateOrConnectWithoutOptionInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutOptionInput | PollVoteUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: PollVoteCreateManyOptionInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutOptionInput | PollVoteUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutOptionInput | PollVoteUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type PollVoteUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<PollVoteCreateWithoutOptionInput, PollVoteUncheckedCreateWithoutOptionInput> | PollVoteCreateWithoutOptionInput[] | PollVoteUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutOptionInput | PollVoteCreateOrConnectWithoutOptionInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutOptionInput | PollVoteUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: PollVoteCreateManyOptionInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutOptionInput | PollVoteUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutOptionInput | PollVoteUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type PollCreateNestedOneWithoutVotesInput = {
    create?: XOR<PollCreateWithoutVotesInput, PollUncheckedCreateWithoutVotesInput>
    connectOrCreate?: PollCreateOrConnectWithoutVotesInput
    connect?: PollWhereUniqueInput
  }

  export type PollOptionCreateNestedOneWithoutVotesInput = {
    create?: XOR<PollOptionCreateWithoutVotesInput, PollOptionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: PollOptionCreateOrConnectWithoutVotesInput
    connect?: PollOptionWhereUniqueInput
  }

  export type PollUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<PollCreateWithoutVotesInput, PollUncheckedCreateWithoutVotesInput>
    connectOrCreate?: PollCreateOrConnectWithoutVotesInput
    upsert?: PollUpsertWithoutVotesInput
    connect?: PollWhereUniqueInput
    update?: XOR<XOR<PollUpdateToOneWithWhereWithoutVotesInput, PollUpdateWithoutVotesInput>, PollUncheckedUpdateWithoutVotesInput>
  }

  export type PollOptionUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<PollOptionCreateWithoutVotesInput, PollOptionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: PollOptionCreateOrConnectWithoutVotesInput
    upsert?: PollOptionUpsertWithoutVotesInput
    connect?: PollOptionWhereUniqueInput
    update?: XOR<XOR<PollOptionUpdateToOneWithWhereWithoutVotesInput, PollOptionUpdateWithoutVotesInput>, PollOptionUncheckedUpdateWithoutVotesInput>
  }

  export type ClubBookCreateNestedOneWithoutEventsInput = {
    create?: XOR<ClubBookCreateWithoutEventsInput, ClubBookUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClubBookCreateOrConnectWithoutEventsInput
    connect?: ClubBookWhereUniqueInput
  }

  export type ClubEventParticipantCreateNestedManyWithoutEventInput = {
    create?: XOR<ClubEventParticipantCreateWithoutEventInput, ClubEventParticipantUncheckedCreateWithoutEventInput> | ClubEventParticipantCreateWithoutEventInput[] | ClubEventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventParticipantCreateOrConnectWithoutEventInput | ClubEventParticipantCreateOrConnectWithoutEventInput[]
    createMany?: ClubEventParticipantCreateManyEventInputEnvelope
    connect?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
  }

  export type ClubEventPhotoCreateNestedManyWithoutEventInput = {
    create?: XOR<ClubEventPhotoCreateWithoutEventInput, ClubEventPhotoUncheckedCreateWithoutEventInput> | ClubEventPhotoCreateWithoutEventInput[] | ClubEventPhotoUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutEventInput | ClubEventPhotoCreateOrConnectWithoutEventInput[]
    createMany?: ClubEventPhotoCreateManyEventInputEnvelope
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
  }

  export type ClubEventParticipantUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ClubEventParticipantCreateWithoutEventInput, ClubEventParticipantUncheckedCreateWithoutEventInput> | ClubEventParticipantCreateWithoutEventInput[] | ClubEventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventParticipantCreateOrConnectWithoutEventInput | ClubEventParticipantCreateOrConnectWithoutEventInput[]
    createMany?: ClubEventParticipantCreateManyEventInputEnvelope
    connect?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
  }

  export type ClubEventPhotoUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ClubEventPhotoCreateWithoutEventInput, ClubEventPhotoUncheckedCreateWithoutEventInput> | ClubEventPhotoCreateWithoutEventInput[] | ClubEventPhotoUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutEventInput | ClubEventPhotoCreateOrConnectWithoutEventInput[]
    createMany?: ClubEventPhotoCreateManyEventInputEnvelope
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClubBookUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ClubBookCreateWithoutEventsInput, ClubBookUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClubBookCreateOrConnectWithoutEventsInput
    upsert?: ClubBookUpsertWithoutEventsInput
    disconnect?: ClubBookWhereInput | boolean
    delete?: ClubBookWhereInput | boolean
    connect?: ClubBookWhereUniqueInput
    update?: XOR<XOR<ClubBookUpdateToOneWithWhereWithoutEventsInput, ClubBookUpdateWithoutEventsInput>, ClubBookUncheckedUpdateWithoutEventsInput>
  }

  export type ClubEventParticipantUpdateManyWithoutEventNestedInput = {
    create?: XOR<ClubEventParticipantCreateWithoutEventInput, ClubEventParticipantUncheckedCreateWithoutEventInput> | ClubEventParticipantCreateWithoutEventInput[] | ClubEventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventParticipantCreateOrConnectWithoutEventInput | ClubEventParticipantCreateOrConnectWithoutEventInput[]
    upsert?: ClubEventParticipantUpsertWithWhereUniqueWithoutEventInput | ClubEventParticipantUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ClubEventParticipantCreateManyEventInputEnvelope
    set?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    disconnect?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    delete?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    connect?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    update?: ClubEventParticipantUpdateWithWhereUniqueWithoutEventInput | ClubEventParticipantUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ClubEventParticipantUpdateManyWithWhereWithoutEventInput | ClubEventParticipantUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ClubEventParticipantScalarWhereInput | ClubEventParticipantScalarWhereInput[]
  }

  export type ClubEventPhotoUpdateManyWithoutEventNestedInput = {
    create?: XOR<ClubEventPhotoCreateWithoutEventInput, ClubEventPhotoUncheckedCreateWithoutEventInput> | ClubEventPhotoCreateWithoutEventInput[] | ClubEventPhotoUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutEventInput | ClubEventPhotoCreateOrConnectWithoutEventInput[]
    upsert?: ClubEventPhotoUpsertWithWhereUniqueWithoutEventInput | ClubEventPhotoUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ClubEventPhotoCreateManyEventInputEnvelope
    set?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    disconnect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    delete?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    update?: ClubEventPhotoUpdateWithWhereUniqueWithoutEventInput | ClubEventPhotoUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ClubEventPhotoUpdateManyWithWhereWithoutEventInput | ClubEventPhotoUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ClubEventPhotoScalarWhereInput | ClubEventPhotoScalarWhereInput[]
  }

  export type ClubEventParticipantUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ClubEventParticipantCreateWithoutEventInput, ClubEventParticipantUncheckedCreateWithoutEventInput> | ClubEventParticipantCreateWithoutEventInput[] | ClubEventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventParticipantCreateOrConnectWithoutEventInput | ClubEventParticipantCreateOrConnectWithoutEventInput[]
    upsert?: ClubEventParticipantUpsertWithWhereUniqueWithoutEventInput | ClubEventParticipantUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ClubEventParticipantCreateManyEventInputEnvelope
    set?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    disconnect?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    delete?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    connect?: ClubEventParticipantWhereUniqueInput | ClubEventParticipantWhereUniqueInput[]
    update?: ClubEventParticipantUpdateWithWhereUniqueWithoutEventInput | ClubEventParticipantUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ClubEventParticipantUpdateManyWithWhereWithoutEventInput | ClubEventParticipantUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ClubEventParticipantScalarWhereInput | ClubEventParticipantScalarWhereInput[]
  }

  export type ClubEventPhotoUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ClubEventPhotoCreateWithoutEventInput, ClubEventPhotoUncheckedCreateWithoutEventInput> | ClubEventPhotoCreateWithoutEventInput[] | ClubEventPhotoUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ClubEventPhotoCreateOrConnectWithoutEventInput | ClubEventPhotoCreateOrConnectWithoutEventInput[]
    upsert?: ClubEventPhotoUpsertWithWhereUniqueWithoutEventInput | ClubEventPhotoUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ClubEventPhotoCreateManyEventInputEnvelope
    set?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    disconnect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    delete?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    connect?: ClubEventPhotoWhereUniqueInput | ClubEventPhotoWhereUniqueInput[]
    update?: ClubEventPhotoUpdateWithWhereUniqueWithoutEventInput | ClubEventPhotoUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ClubEventPhotoUpdateManyWithWhereWithoutEventInput | ClubEventPhotoUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ClubEventPhotoScalarWhereInput | ClubEventPhotoScalarWhereInput[]
  }

  export type ClubEventCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ClubEventCreateWithoutParticipantsInput, ClubEventUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ClubEventCreateOrConnectWithoutParticipantsInput
    connect?: ClubEventWhereUniqueInput
  }

  export type ClubEventUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ClubEventCreateWithoutParticipantsInput, ClubEventUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ClubEventCreateOrConnectWithoutParticipantsInput
    upsert?: ClubEventUpsertWithoutParticipantsInput
    connect?: ClubEventWhereUniqueInput
    update?: XOR<XOR<ClubEventUpdateToOneWithWhereWithoutParticipantsInput, ClubEventUpdateWithoutParticipantsInput>, ClubEventUncheckedUpdateWithoutParticipantsInput>
  }

  export type ClubEventCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ClubEventCreateWithoutPhotosInput, ClubEventUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ClubEventCreateOrConnectWithoutPhotosInput
    connect?: ClubEventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClubEventPhotosInput = {
    create?: XOR<UserCreateWithoutClubEventPhotosInput, UserUncheckedCreateWithoutClubEventPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubEventPhotosInput
    connect?: UserWhereUniqueInput
  }

  export type ClubEventUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ClubEventCreateWithoutPhotosInput, ClubEventUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ClubEventCreateOrConnectWithoutPhotosInput
    upsert?: ClubEventUpsertWithoutPhotosInput
    connect?: ClubEventWhereUniqueInput
    update?: XOR<XOR<ClubEventUpdateToOneWithWhereWithoutPhotosInput, ClubEventUpdateWithoutPhotosInput>, ClubEventUncheckedUpdateWithoutPhotosInput>
  }

  export type UserUpdateOneRequiredWithoutClubEventPhotosNestedInput = {
    create?: XOR<UserCreateWithoutClubEventPhotosInput, UserUncheckedCreateWithoutClubEventPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubEventPhotosInput
    upsert?: UserUpsertWithoutClubEventPhotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClubEventPhotosInput, UserUpdateWithoutClubEventPhotosInput>, UserUncheckedUpdateWithoutClubEventPhotosInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserCityCreateWithoutUserInput = {
    id?: string
    city: string
  }

  export type UserCityUncheckedCreateWithoutUserInput = {
    id?: string
    city: string
  }

  export type UserCityCreateOrConnectWithoutUserInput = {
    where: UserCityWhereUniqueInput
    create: XOR<UserCityCreateWithoutUserInput, UserCityUncheckedCreateWithoutUserInput>
  }

  export type UserCityCreateManyUserInputEnvelope = {
    data: UserCityCreateManyUserInput | UserCityCreateManyUserInput[]
  }

  export type BookCreateWithoutCreatedByUserInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageCreateNestedManyWithoutBookInput
    clubBooks?: ClubBookCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageUncheckedCreateNestedManyWithoutBookInput
    clubBooks?: ClubBookUncheckedCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutCreatedByUserInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutCreatedByUserInput, BookUncheckedCreateWithoutCreatedByUserInput>
  }

  export type BookCreateManyCreatedByUserInputEnvelope = {
    data: BookCreateManyCreatedByUserInput | BookCreateManyCreatedByUserInput[]
  }

  export type ClubBookCreateWithoutCreatedByUserInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    book: BookCreateNestedOneWithoutClubBooksInput
    messages?: ClubBookMessageCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactCreateNestedManyWithoutClubBookInput
    events?: ClubEventCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    bookId: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    messages?: ClubBookMessageUncheckedCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactUncheckedCreateNestedManyWithoutClubBookInput
    events?: ClubEventUncheckedCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookCreateOrConnectWithoutCreatedByUserInput = {
    where: ClubBookWhereUniqueInput
    create: XOR<ClubBookCreateWithoutCreatedByUserInput, ClubBookUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ClubBookCreateManyCreatedByUserInputEnvelope = {
    data: ClubBookCreateManyCreatedByUserInput | ClubBookCreateManyCreatedByUserInput[]
  }

  export type ClubEventPhotoCreateWithoutUserInput = {
    id?: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
    event: ClubEventCreateNestedOneWithoutPhotosInput
  }

  export type ClubEventPhotoUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type ClubEventPhotoCreateOrConnectWithoutUserInput = {
    where: ClubEventPhotoWhereUniqueInput
    create: XOR<ClubEventPhotoCreateWithoutUserInput, ClubEventPhotoUncheckedCreateWithoutUserInput>
  }

  export type ClubEventPhotoCreateManyUserInputEnvelope = {
    data: ClubEventPhotoCreateManyUserInput | ClubEventPhotoCreateManyUserInput[]
  }

  export type UserCityUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCityWhereUniqueInput
    update: XOR<UserCityUpdateWithoutUserInput, UserCityUncheckedUpdateWithoutUserInput>
    create: XOR<UserCityCreateWithoutUserInput, UserCityUncheckedCreateWithoutUserInput>
  }

  export type UserCityUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCityWhereUniqueInput
    data: XOR<UserCityUpdateWithoutUserInput, UserCityUncheckedUpdateWithoutUserInput>
  }

  export type UserCityUpdateManyWithWhereWithoutUserInput = {
    where: UserCityScalarWhereInput
    data: XOR<UserCityUpdateManyMutationInput, UserCityUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCityScalarWhereInput = {
    AND?: UserCityScalarWhereInput | UserCityScalarWhereInput[]
    OR?: UserCityScalarWhereInput[]
    NOT?: UserCityScalarWhereInput | UserCityScalarWhereInput[]
    id?: StringFilter<"UserCity"> | string
    userId?: StringFilter<"UserCity"> | string
    city?: StringFilter<"UserCity"> | string
  }

  export type BookUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutCreatedByUserInput, BookUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<BookCreateWithoutCreatedByUserInput, BookUncheckedCreateWithoutCreatedByUserInput>
  }

  export type BookUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutCreatedByUserInput, BookUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type BookUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type BookScalarWhereInput = {
    AND?: BookScalarWhereInput | BookScalarWhereInput[]
    OR?: BookScalarWhereInput[]
    NOT?: BookScalarWhereInput | BookScalarWhereInput[]
    id?: StringFilter<"Book"> | string
    title?: StringFilter<"Book"> | string
    author?: StringFilter<"Book"> | string
    coverUrl?: StringFilter<"Book"> | string
    synopsis?: StringFilter<"Book"> | string
    aiStyleDescription?: StringFilter<"Book"> | string
    createdByUserId?: StringNullableFilter<"Book"> | string | null
    indicationComment?: StringFilter<"Book"> | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
  }

  export type ClubBookUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: ClubBookWhereUniqueInput
    update: XOR<ClubBookUpdateWithoutCreatedByUserInput, ClubBookUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<ClubBookCreateWithoutCreatedByUserInput, ClubBookUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ClubBookUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: ClubBookWhereUniqueInput
    data: XOR<ClubBookUpdateWithoutCreatedByUserInput, ClubBookUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type ClubBookUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: ClubBookScalarWhereInput
    data: XOR<ClubBookUpdateManyMutationInput, ClubBookUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type ClubBookScalarWhereInput = {
    AND?: ClubBookScalarWhereInput | ClubBookScalarWhereInput[]
    OR?: ClubBookScalarWhereInput[]
    NOT?: ClubBookScalarWhereInput | ClubBookScalarWhereInput[]
    id?: StringFilter<"ClubBook"> | string
    bookId?: StringFilter<"ClubBook"> | string
    title?: StringFilter<"ClubBook"> | string
    author?: StringFilter<"ClubBook"> | string
    coverUrl?: StringFilter<"ClubBook"> | string
    colorKey?: StringFilter<"ClubBook"> | string
    city?: StringFilter<"ClubBook"> | string
    month?: IntFilter<"ClubBook"> | number
    year?: IntFilter<"ClubBook"> | number
    isActive?: BoolFilter<"ClubBook"> | boolean
    createdByUserId?: StringFilter<"ClubBook"> | string
    indicationComment?: StringFilter<"ClubBook"> | string
    createdAt?: DateTimeFilter<"ClubBook"> | Date | string
    activatedAt?: DateTimeNullableFilter<"ClubBook"> | Date | string | null
  }

  export type ClubEventPhotoUpsertWithWhereUniqueWithoutUserInput = {
    where: ClubEventPhotoWhereUniqueInput
    update: XOR<ClubEventPhotoUpdateWithoutUserInput, ClubEventPhotoUncheckedUpdateWithoutUserInput>
    create: XOR<ClubEventPhotoCreateWithoutUserInput, ClubEventPhotoUncheckedCreateWithoutUserInput>
  }

  export type ClubEventPhotoUpdateWithWhereUniqueWithoutUserInput = {
    where: ClubEventPhotoWhereUniqueInput
    data: XOR<ClubEventPhotoUpdateWithoutUserInput, ClubEventPhotoUncheckedUpdateWithoutUserInput>
  }

  export type ClubEventPhotoUpdateManyWithWhereWithoutUserInput = {
    where: ClubEventPhotoScalarWhereInput
    data: XOR<ClubEventPhotoUpdateManyMutationInput, ClubEventPhotoUncheckedUpdateManyWithoutUserInput>
  }

  export type ClubEventPhotoScalarWhereInput = {
    AND?: ClubEventPhotoScalarWhereInput | ClubEventPhotoScalarWhereInput[]
    OR?: ClubEventPhotoScalarWhereInput[]
    NOT?: ClubEventPhotoScalarWhereInput | ClubEventPhotoScalarWhereInput[]
    id?: StringFilter<"ClubEventPhoto"> | string
    eventId?: StringFilter<"ClubEventPhoto"> | string
    userId?: StringFilter<"ClubEventPhoto"> | string
    url?: StringFilter<"ClubEventPhoto"> | string
    caption?: StringNullableFilter<"ClubEventPhoto"> | string | null
    type?: StringFilter<"ClubEventPhoto"> | string
    createdAt?: DateTimeFilter<"ClubEventPhoto"> | Date | string
  }

  export type UserCreateWithoutCitiesInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBooks?: BookCreateNestedManyWithoutCreatedByUserInput
    createdClubBooks?: ClubBookCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCitiesInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdClubBooks?: ClubBookUncheckedCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCitiesInput, UserUncheckedCreateWithoutCitiesInput>
  }

  export type UserUpsertWithoutCitiesInput = {
    update: XOR<UserUpdateWithoutCitiesInput, UserUncheckedUpdateWithoutCitiesInput>
    create: XOR<UserCreateWithoutCitiesInput, UserUncheckedCreateWithoutCitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCitiesInput, UserUncheckedUpdateWithoutCitiesInput>
  }

  export type UserUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBooks?: BookUpdateManyWithoutCreatedByUserNestedInput
    createdClubBooks?: ClubBookUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdClubBooks?: ClubBookUncheckedUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryCreateWithoutBooksInput = {
    id?: string
    name: string
  }

  export type CategoryUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
  }

  export type CategoryCreateOrConnectWithoutBooksInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
  }

  export type BookStyleImageCreateWithoutBookInput = {
    id?: string
    url: string
  }

  export type BookStyleImageUncheckedCreateWithoutBookInput = {
    id?: string
    url: string
  }

  export type BookStyleImageCreateOrConnectWithoutBookInput = {
    where: BookStyleImageWhereUniqueInput
    create: XOR<BookStyleImageCreateWithoutBookInput, BookStyleImageUncheckedCreateWithoutBookInput>
  }

  export type BookStyleImageCreateManyBookInputEnvelope = {
    data: BookStyleImageCreateManyBookInput | BookStyleImageCreateManyBookInput[]
  }

  export type UserCreateWithoutCreatedBooksInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityCreateNestedManyWithoutUserInput
    createdClubBooks?: ClubBookCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedBooksInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityUncheckedCreateNestedManyWithoutUserInput
    createdClubBooks?: ClubBookUncheckedCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedBooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
  }

  export type ClubBookCreateWithoutBookInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    createdByUser: UserCreateNestedOneWithoutCreatedClubBooksInput
    messages?: ClubBookMessageCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactCreateNestedManyWithoutClubBookInput
    events?: ClubEventCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookUncheckedCreateWithoutBookInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    createdByUserId: string
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    messages?: ClubBookMessageUncheckedCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactUncheckedCreateNestedManyWithoutClubBookInput
    events?: ClubEventUncheckedCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookCreateOrConnectWithoutBookInput = {
    where: ClubBookWhereUniqueInput
    create: XOR<ClubBookCreateWithoutBookInput, ClubBookUncheckedCreateWithoutBookInput>
  }

  export type ClubBookCreateManyBookInputEnvelope = {
    data: ClubBookCreateManyBookInput | ClubBookCreateManyBookInput[]
  }

  export type PollOptionCreateWithoutBookInput = {
    id?: string
    type?: string
    text: string
    imageUrl?: string | null
    index: number
    poll: PollCreateNestedOneWithoutOptionsInput
    votes?: PollVoteCreateNestedManyWithoutOptionInput
  }

  export type PollOptionUncheckedCreateWithoutBookInput = {
    id?: string
    pollId: string
    type?: string
    text: string
    imageUrl?: string | null
    index: number
    votes?: PollVoteUncheckedCreateNestedManyWithoutOptionInput
  }

  export type PollOptionCreateOrConnectWithoutBookInput = {
    where: PollOptionWhereUniqueInput
    create: XOR<PollOptionCreateWithoutBookInput, PollOptionUncheckedCreateWithoutBookInput>
  }

  export type PollOptionCreateManyBookInputEnvelope = {
    data: PollOptionCreateManyBookInput | PollOptionCreateManyBookInput[]
  }

  export type CategoryUpsertWithWhereUniqueWithoutBooksInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutBooksInput, CategoryUncheckedUpdateWithoutBooksInput>
    create: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutBooksInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutBooksInput, CategoryUncheckedUpdateWithoutBooksInput>
  }

  export type CategoryUpdateManyWithWhereWithoutBooksInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutBooksInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
  }

  export type BookStyleImageUpsertWithWhereUniqueWithoutBookInput = {
    where: BookStyleImageWhereUniqueInput
    update: XOR<BookStyleImageUpdateWithoutBookInput, BookStyleImageUncheckedUpdateWithoutBookInput>
    create: XOR<BookStyleImageCreateWithoutBookInput, BookStyleImageUncheckedCreateWithoutBookInput>
  }

  export type BookStyleImageUpdateWithWhereUniqueWithoutBookInput = {
    where: BookStyleImageWhereUniqueInput
    data: XOR<BookStyleImageUpdateWithoutBookInput, BookStyleImageUncheckedUpdateWithoutBookInput>
  }

  export type BookStyleImageUpdateManyWithWhereWithoutBookInput = {
    where: BookStyleImageScalarWhereInput
    data: XOR<BookStyleImageUpdateManyMutationInput, BookStyleImageUncheckedUpdateManyWithoutBookInput>
  }

  export type BookStyleImageScalarWhereInput = {
    AND?: BookStyleImageScalarWhereInput | BookStyleImageScalarWhereInput[]
    OR?: BookStyleImageScalarWhereInput[]
    NOT?: BookStyleImageScalarWhereInput | BookStyleImageScalarWhereInput[]
    id?: StringFilter<"BookStyleImage"> | string
    bookId?: StringFilter<"BookStyleImage"> | string
    url?: StringFilter<"BookStyleImage"> | string
  }

  export type UserUpsertWithoutCreatedBooksInput = {
    update: XOR<UserUpdateWithoutCreatedBooksInput, UserUncheckedUpdateWithoutCreatedBooksInput>
    create: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBooksInput, UserUncheckedUpdateWithoutCreatedBooksInput>
  }

  export type UserUpdateWithoutCreatedBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUpdateManyWithoutUserNestedInput
    createdClubBooks?: ClubBookUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUncheckedUpdateManyWithoutUserNestedInput
    createdClubBooks?: ClubBookUncheckedUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClubBookUpsertWithWhereUniqueWithoutBookInput = {
    where: ClubBookWhereUniqueInput
    update: XOR<ClubBookUpdateWithoutBookInput, ClubBookUncheckedUpdateWithoutBookInput>
    create: XOR<ClubBookCreateWithoutBookInput, ClubBookUncheckedCreateWithoutBookInput>
  }

  export type ClubBookUpdateWithWhereUniqueWithoutBookInput = {
    where: ClubBookWhereUniqueInput
    data: XOR<ClubBookUpdateWithoutBookInput, ClubBookUncheckedUpdateWithoutBookInput>
  }

  export type ClubBookUpdateManyWithWhereWithoutBookInput = {
    where: ClubBookScalarWhereInput
    data: XOR<ClubBookUpdateManyMutationInput, ClubBookUncheckedUpdateManyWithoutBookInput>
  }

  export type PollOptionUpsertWithWhereUniqueWithoutBookInput = {
    where: PollOptionWhereUniqueInput
    update: XOR<PollOptionUpdateWithoutBookInput, PollOptionUncheckedUpdateWithoutBookInput>
    create: XOR<PollOptionCreateWithoutBookInput, PollOptionUncheckedCreateWithoutBookInput>
  }

  export type PollOptionUpdateWithWhereUniqueWithoutBookInput = {
    where: PollOptionWhereUniqueInput
    data: XOR<PollOptionUpdateWithoutBookInput, PollOptionUncheckedUpdateWithoutBookInput>
  }

  export type PollOptionUpdateManyWithWhereWithoutBookInput = {
    where: PollOptionScalarWhereInput
    data: XOR<PollOptionUpdateManyMutationInput, PollOptionUncheckedUpdateManyWithoutBookInput>
  }

  export type PollOptionScalarWhereInput = {
    AND?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[]
    OR?: PollOptionScalarWhereInput[]
    NOT?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[]
    id?: StringFilter<"PollOption"> | string
    pollId?: StringFilter<"PollOption"> | string
    type?: StringFilter<"PollOption"> | string
    text?: StringFilter<"PollOption"> | string
    imageUrl?: StringNullableFilter<"PollOption"> | string | null
    bookId?: StringNullableFilter<"PollOption"> | string | null
    index?: IntFilter<"PollOption"> | number
  }

  export type BookCreateWithoutStyleImagesInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutBooksInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBooksInput
    clubBooks?: ClubBookCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutStyleImagesInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    createdByUserId?: string | null
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutBooksInput
    clubBooks?: ClubBookUncheckedCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutStyleImagesInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutStyleImagesInput, BookUncheckedCreateWithoutStyleImagesInput>
  }

  export type BookUpsertWithoutStyleImagesInput = {
    update: XOR<BookUpdateWithoutStyleImagesInput, BookUncheckedUpdateWithoutStyleImagesInput>
    create: XOR<BookCreateWithoutStyleImagesInput, BookUncheckedCreateWithoutStyleImagesInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutStyleImagesInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutStyleImagesInput, BookUncheckedUpdateWithoutStyleImagesInput>
  }

  export type BookUpdateWithoutStyleImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutBooksNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBooksNestedInput
    clubBooks?: ClubBookUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutStyleImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutBooksNestedInput
    clubBooks?: ClubBookUncheckedUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookCreateWithoutCategoriesInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
    styleImages?: BookStyleImageCreateNestedManyWithoutBookInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBooksInput
    clubBooks?: ClubBookCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    createdByUserId?: string | null
    indicationComment?: string
    createdAt?: Date | string
    styleImages?: BookStyleImageUncheckedCreateNestedManyWithoutBookInput
    clubBooks?: ClubBookUncheckedCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutCategoriesInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutCategoriesInput, BookUncheckedCreateWithoutCategoriesInput>
  }

  export type BookUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutCategoriesInput, BookUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BookCreateWithoutCategoriesInput, BookUncheckedCreateWithoutCategoriesInput>
  }

  export type BookUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutCategoriesInput, BookUncheckedUpdateWithoutCategoriesInput>
  }

  export type BookUpdateManyWithWhereWithoutCategoriesInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type MembershipCreateWithoutGroupInput = {
    id?: string
    userId: string
    role: string
  }

  export type MembershipUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role: string
  }

  export type MembershipCreateOrConnectWithoutGroupInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutGroupInput, MembershipUncheckedCreateWithoutGroupInput>
  }

  export type MembershipCreateManyGroupInputEnvelope = {
    data: MembershipCreateManyGroupInput | MembershipCreateManyGroupInput[]
  }

  export type GroupInviteCreateWithoutGroupInput = {
    id?: string
    createdByUserId: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type GroupInviteUncheckedCreateWithoutGroupInput = {
    id?: string
    createdByUserId: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type GroupInviteCreateOrConnectWithoutGroupInput = {
    where: GroupInviteWhereUniqueInput
    create: XOR<GroupInviteCreateWithoutGroupInput, GroupInviteUncheckedCreateWithoutGroupInput>
  }

  export type GroupInviteCreateManyGroupInputEnvelope = {
    data: GroupInviteCreateManyGroupInput | GroupInviteCreateManyGroupInput[]
  }

  export type JoinRequestCreateWithoutGroupInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type JoinRequestUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type JoinRequestCreateOrConnectWithoutGroupInput = {
    where: JoinRequestWhereUniqueInput
    create: XOR<JoinRequestCreateWithoutGroupInput, JoinRequestUncheckedCreateWithoutGroupInput>
  }

  export type JoinRequestCreateManyGroupInputEnvelope = {
    data: JoinRequestCreateManyGroupInput | JoinRequestCreateManyGroupInput[]
  }

  export type GroupBookOfMonthSelectionCreateWithoutGroupInput = {
    id?: string
    bookId: string
    setByUserId: string
    setAt?: Date | string
  }

  export type GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput = {
    id?: string
    bookId: string
    setByUserId: string
    setAt?: Date | string
  }

  export type GroupBookOfMonthSelectionCreateOrConnectWithoutGroupInput = {
    where: GroupBookOfMonthSelectionWhereUniqueInput
    create: XOR<GroupBookOfMonthSelectionCreateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput>
  }

  export type GroupBookOfMonthSelectionCreateManyGroupInputEnvelope = {
    data: GroupBookOfMonthSelectionCreateManyGroupInput | GroupBookOfMonthSelectionCreateManyGroupInput[]
  }

  export type MembershipUpsertWithWhereUniqueWithoutGroupInput = {
    where: MembershipWhereUniqueInput
    update: XOR<MembershipUpdateWithoutGroupInput, MembershipUncheckedUpdateWithoutGroupInput>
    create: XOR<MembershipCreateWithoutGroupInput, MembershipUncheckedCreateWithoutGroupInput>
  }

  export type MembershipUpdateWithWhereUniqueWithoutGroupInput = {
    where: MembershipWhereUniqueInput
    data: XOR<MembershipUpdateWithoutGroupInput, MembershipUncheckedUpdateWithoutGroupInput>
  }

  export type MembershipUpdateManyWithWhereWithoutGroupInput = {
    where: MembershipScalarWhereInput
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutGroupInput>
  }

  export type MembershipScalarWhereInput = {
    AND?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    OR?: MembershipScalarWhereInput[]
    NOT?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    id?: StringFilter<"Membership"> | string
    groupId?: StringFilter<"Membership"> | string
    userId?: StringFilter<"Membership"> | string
    role?: StringFilter<"Membership"> | string
  }

  export type GroupInviteUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupInviteWhereUniqueInput
    update: XOR<GroupInviteUpdateWithoutGroupInput, GroupInviteUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupInviteCreateWithoutGroupInput, GroupInviteUncheckedCreateWithoutGroupInput>
  }

  export type GroupInviteUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupInviteWhereUniqueInput
    data: XOR<GroupInviteUpdateWithoutGroupInput, GroupInviteUncheckedUpdateWithoutGroupInput>
  }

  export type GroupInviteUpdateManyWithWhereWithoutGroupInput = {
    where: GroupInviteScalarWhereInput
    data: XOR<GroupInviteUpdateManyMutationInput, GroupInviteUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupInviteScalarWhereInput = {
    AND?: GroupInviteScalarWhereInput | GroupInviteScalarWhereInput[]
    OR?: GroupInviteScalarWhereInput[]
    NOT?: GroupInviteScalarWhereInput | GroupInviteScalarWhereInput[]
    id?: StringFilter<"GroupInvite"> | string
    groupId?: StringFilter<"GroupInvite"> | string
    createdByUserId?: StringFilter<"GroupInvite"> | string
    createdAt?: DateTimeFilter<"GroupInvite"> | Date | string
    revokedAt?: DateTimeNullableFilter<"GroupInvite"> | Date | string | null
  }

  export type JoinRequestUpsertWithWhereUniqueWithoutGroupInput = {
    where: JoinRequestWhereUniqueInput
    update: XOR<JoinRequestUpdateWithoutGroupInput, JoinRequestUncheckedUpdateWithoutGroupInput>
    create: XOR<JoinRequestCreateWithoutGroupInput, JoinRequestUncheckedCreateWithoutGroupInput>
  }

  export type JoinRequestUpdateWithWhereUniqueWithoutGroupInput = {
    where: JoinRequestWhereUniqueInput
    data: XOR<JoinRequestUpdateWithoutGroupInput, JoinRequestUncheckedUpdateWithoutGroupInput>
  }

  export type JoinRequestUpdateManyWithWhereWithoutGroupInput = {
    where: JoinRequestScalarWhereInput
    data: XOR<JoinRequestUpdateManyMutationInput, JoinRequestUncheckedUpdateManyWithoutGroupInput>
  }

  export type JoinRequestScalarWhereInput = {
    AND?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
    OR?: JoinRequestScalarWhereInput[]
    NOT?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
    id?: StringFilter<"JoinRequest"> | string
    groupId?: StringFilter<"JoinRequest"> | string
    userId?: StringFilter<"JoinRequest"> | string
    status?: StringFilter<"JoinRequest"> | string
    createdAt?: DateTimeFilter<"JoinRequest"> | Date | string
  }

  export type GroupBookOfMonthSelectionUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupBookOfMonthSelectionWhereUniqueInput
    update: XOR<GroupBookOfMonthSelectionUpdateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupBookOfMonthSelectionCreateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedCreateWithoutGroupInput>
  }

  export type GroupBookOfMonthSelectionUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupBookOfMonthSelectionWhereUniqueInput
    data: XOR<GroupBookOfMonthSelectionUpdateWithoutGroupInput, GroupBookOfMonthSelectionUncheckedUpdateWithoutGroupInput>
  }

  export type GroupBookOfMonthSelectionUpdateManyWithWhereWithoutGroupInput = {
    where: GroupBookOfMonthSelectionScalarWhereInput
    data: XOR<GroupBookOfMonthSelectionUpdateManyMutationInput, GroupBookOfMonthSelectionUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupBookOfMonthSelectionScalarWhereInput = {
    AND?: GroupBookOfMonthSelectionScalarWhereInput | GroupBookOfMonthSelectionScalarWhereInput[]
    OR?: GroupBookOfMonthSelectionScalarWhereInput[]
    NOT?: GroupBookOfMonthSelectionScalarWhereInput | GroupBookOfMonthSelectionScalarWhereInput[]
    id?: StringFilter<"GroupBookOfMonthSelection"> | string
    groupId?: StringFilter<"GroupBookOfMonthSelection"> | string
    bookId?: StringFilter<"GroupBookOfMonthSelection"> | string
    setByUserId?: StringFilter<"GroupBookOfMonthSelection"> | string
    setAt?: DateTimeFilter<"GroupBookOfMonthSelection"> | Date | string
  }

  export type GroupCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    invites?: GroupInviteCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    invites?: GroupInviteUncheckedCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembershipsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembershipsInput, GroupUncheckedCreateWithoutMembershipsInput>
  }

  export type GroupUpsertWithoutMembershipsInput = {
    update: XOR<GroupUpdateWithoutMembershipsInput, GroupUncheckedUpdateWithoutMembershipsInput>
    create: XOR<GroupCreateWithoutMembershipsInput, GroupUncheckedCreateWithoutMembershipsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembershipsInput, GroupUncheckedUpdateWithoutMembershipsInput>
  }

  export type GroupUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: GroupInviteUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: GroupInviteUncheckedUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateWithoutJoinRequestsInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutGroupInput
    invites?: GroupInviteCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutJoinRequestsInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutGroupInput
    invites?: GroupInviteUncheckedCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutJoinRequestsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutJoinRequestsInput, GroupUncheckedCreateWithoutJoinRequestsInput>
  }

  export type GroupUpsertWithoutJoinRequestsInput = {
    update: XOR<GroupUpdateWithoutJoinRequestsInput, GroupUncheckedUpdateWithoutJoinRequestsInput>
    create: XOR<GroupCreateWithoutJoinRequestsInput, GroupUncheckedCreateWithoutJoinRequestsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutJoinRequestsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutJoinRequestsInput, GroupUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type GroupUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutGroupNestedInput
    invites?: GroupInviteUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutGroupNestedInput
    invites?: GroupInviteUncheckedUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateWithoutInvitesInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutGroupInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutInvitesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutInvitesInput, GroupUncheckedCreateWithoutInvitesInput>
  }

  export type GroupUpsertWithoutInvitesInput = {
    update: XOR<GroupUpdateWithoutInvitesInput, GroupUncheckedUpdateWithoutInvitesInput>
    create: XOR<GroupCreateWithoutInvitesInput, GroupUncheckedCreateWithoutInvitesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutInvitesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutInvitesInput, GroupUncheckedUpdateWithoutInvitesInput>
  }

  export type GroupUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutGroupNestedInput
    bookOfMonthSelections?: GroupBookOfMonthSelectionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateWithoutBookOfMonthSelectionsInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutGroupInput
    invites?: GroupInviteCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutBookOfMonthSelectionsInput = {
    id?: string
    name: string
    description: string
    ownerId: string
    createdAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutGroupInput
    invites?: GroupInviteUncheckedCreateNestedManyWithoutGroupInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutBookOfMonthSelectionsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutBookOfMonthSelectionsInput, GroupUncheckedCreateWithoutBookOfMonthSelectionsInput>
  }

  export type GroupUpsertWithoutBookOfMonthSelectionsInput = {
    update: XOR<GroupUpdateWithoutBookOfMonthSelectionsInput, GroupUncheckedUpdateWithoutBookOfMonthSelectionsInput>
    create: XOR<GroupCreateWithoutBookOfMonthSelectionsInput, GroupUncheckedCreateWithoutBookOfMonthSelectionsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutBookOfMonthSelectionsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutBookOfMonthSelectionsInput, GroupUncheckedUpdateWithoutBookOfMonthSelectionsInput>
  }

  export type GroupUpdateWithoutBookOfMonthSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutGroupNestedInput
    invites?: GroupInviteUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutBookOfMonthSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutGroupNestedInput
    invites?: GroupInviteUncheckedUpdateManyWithoutGroupNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserCreateWithoutCreatedClubBooksInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityCreateNestedManyWithoutUserInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedClubBooksInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityUncheckedCreateNestedManyWithoutUserInput
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByUserInput
    clubEventPhotos?: ClubEventPhotoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedClubBooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedClubBooksInput, UserUncheckedCreateWithoutCreatedClubBooksInput>
  }

  export type BookCreateWithoutClubBooksInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageCreateNestedManyWithoutBookInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBooksInput
    pollOptions?: PollOptionCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutClubBooksInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    createdByUserId?: string | null
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageUncheckedCreateNestedManyWithoutBookInput
    pollOptions?: PollOptionUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutClubBooksInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutClubBooksInput, BookUncheckedCreateWithoutClubBooksInput>
  }

  export type ClubBookMessageCreateWithoutClubBookInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ClubBookMessageUncheckedCreateWithoutClubBookInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ClubBookMessageCreateOrConnectWithoutClubBookInput = {
    where: ClubBookMessageWhereUniqueInput
    create: XOR<ClubBookMessageCreateWithoutClubBookInput, ClubBookMessageUncheckedCreateWithoutClubBookInput>
  }

  export type ClubBookMessageCreateManyClubBookInputEnvelope = {
    data: ClubBookMessageCreateManyClubBookInput | ClubBookMessageCreateManyClubBookInput[]
  }

  export type ClubBookArtifactCreateWithoutClubBookInput = {
    id?: string
    fileName: string
    mimeType: string
    size: number
    url: string
    uploadedByUserId: string
    createdAt?: Date | string
  }

  export type ClubBookArtifactUncheckedCreateWithoutClubBookInput = {
    id?: string
    fileName: string
    mimeType: string
    size: number
    url: string
    uploadedByUserId: string
    createdAt?: Date | string
  }

  export type ClubBookArtifactCreateOrConnectWithoutClubBookInput = {
    where: ClubBookArtifactWhereUniqueInput
    create: XOR<ClubBookArtifactCreateWithoutClubBookInput, ClubBookArtifactUncheckedCreateWithoutClubBookInput>
  }

  export type ClubBookArtifactCreateManyClubBookInputEnvelope = {
    data: ClubBookArtifactCreateManyClubBookInput | ClubBookArtifactCreateManyClubBookInput[]
  }

  export type ClubEventCreateWithoutClubBookInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    participants?: ClubEventParticipantCreateNestedManyWithoutEventInput
    photos?: ClubEventPhotoCreateNestedManyWithoutEventInput
  }

  export type ClubEventUncheckedCreateWithoutClubBookInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    participants?: ClubEventParticipantUncheckedCreateNestedManyWithoutEventInput
    photos?: ClubEventPhotoUncheckedCreateNestedManyWithoutEventInput
  }

  export type ClubEventCreateOrConnectWithoutClubBookInput = {
    where: ClubEventWhereUniqueInput
    create: XOR<ClubEventCreateWithoutClubBookInput, ClubEventUncheckedCreateWithoutClubBookInput>
  }

  export type ClubEventCreateManyClubBookInputEnvelope = {
    data: ClubEventCreateManyClubBookInput | ClubEventCreateManyClubBookInput[]
  }

  export type UserUpsertWithoutCreatedClubBooksInput = {
    update: XOR<UserUpdateWithoutCreatedClubBooksInput, UserUncheckedUpdateWithoutCreatedClubBooksInput>
    create: XOR<UserCreateWithoutCreatedClubBooksInput, UserUncheckedCreateWithoutCreatedClubBooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedClubBooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedClubBooksInput, UserUncheckedUpdateWithoutCreatedClubBooksInput>
  }

  export type UserUpdateWithoutCreatedClubBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUpdateManyWithoutUserNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedClubBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUncheckedUpdateManyWithoutUserNestedInput
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByUserNestedInput
    clubEventPhotos?: ClubEventPhotoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookUpsertWithoutClubBooksInput = {
    update: XOR<BookUpdateWithoutClubBooksInput, BookUncheckedUpdateWithoutClubBooksInput>
    create: XOR<BookCreateWithoutClubBooksInput, BookUncheckedCreateWithoutClubBooksInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutClubBooksInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutClubBooksInput, BookUncheckedUpdateWithoutClubBooksInput>
  }

  export type BookUpdateWithoutClubBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUpdateManyWithoutBookNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBooksNestedInput
    pollOptions?: PollOptionUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutClubBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUncheckedUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUncheckedUpdateManyWithoutBookNestedInput
  }

  export type ClubBookMessageUpsertWithWhereUniqueWithoutClubBookInput = {
    where: ClubBookMessageWhereUniqueInput
    update: XOR<ClubBookMessageUpdateWithoutClubBookInput, ClubBookMessageUncheckedUpdateWithoutClubBookInput>
    create: XOR<ClubBookMessageCreateWithoutClubBookInput, ClubBookMessageUncheckedCreateWithoutClubBookInput>
  }

  export type ClubBookMessageUpdateWithWhereUniqueWithoutClubBookInput = {
    where: ClubBookMessageWhereUniqueInput
    data: XOR<ClubBookMessageUpdateWithoutClubBookInput, ClubBookMessageUncheckedUpdateWithoutClubBookInput>
  }

  export type ClubBookMessageUpdateManyWithWhereWithoutClubBookInput = {
    where: ClubBookMessageScalarWhereInput
    data: XOR<ClubBookMessageUpdateManyMutationInput, ClubBookMessageUncheckedUpdateManyWithoutClubBookInput>
  }

  export type ClubBookMessageScalarWhereInput = {
    AND?: ClubBookMessageScalarWhereInput | ClubBookMessageScalarWhereInput[]
    OR?: ClubBookMessageScalarWhereInput[]
    NOT?: ClubBookMessageScalarWhereInput | ClubBookMessageScalarWhereInput[]
    id?: StringFilter<"ClubBookMessage"> | string
    clubBookId?: StringFilter<"ClubBookMessage"> | string
    userId?: StringFilter<"ClubBookMessage"> | string
    text?: StringFilter<"ClubBookMessage"> | string
    createdAt?: DateTimeFilter<"ClubBookMessage"> | Date | string
  }

  export type ClubBookArtifactUpsertWithWhereUniqueWithoutClubBookInput = {
    where: ClubBookArtifactWhereUniqueInput
    update: XOR<ClubBookArtifactUpdateWithoutClubBookInput, ClubBookArtifactUncheckedUpdateWithoutClubBookInput>
    create: XOR<ClubBookArtifactCreateWithoutClubBookInput, ClubBookArtifactUncheckedCreateWithoutClubBookInput>
  }

  export type ClubBookArtifactUpdateWithWhereUniqueWithoutClubBookInput = {
    where: ClubBookArtifactWhereUniqueInput
    data: XOR<ClubBookArtifactUpdateWithoutClubBookInput, ClubBookArtifactUncheckedUpdateWithoutClubBookInput>
  }

  export type ClubBookArtifactUpdateManyWithWhereWithoutClubBookInput = {
    where: ClubBookArtifactScalarWhereInput
    data: XOR<ClubBookArtifactUpdateManyMutationInput, ClubBookArtifactUncheckedUpdateManyWithoutClubBookInput>
  }

  export type ClubBookArtifactScalarWhereInput = {
    AND?: ClubBookArtifactScalarWhereInput | ClubBookArtifactScalarWhereInput[]
    OR?: ClubBookArtifactScalarWhereInput[]
    NOT?: ClubBookArtifactScalarWhereInput | ClubBookArtifactScalarWhereInput[]
    id?: StringFilter<"ClubBookArtifact"> | string
    clubBookId?: StringFilter<"ClubBookArtifact"> | string
    fileName?: StringFilter<"ClubBookArtifact"> | string
    mimeType?: StringFilter<"ClubBookArtifact"> | string
    size?: IntFilter<"ClubBookArtifact"> | number
    url?: StringFilter<"ClubBookArtifact"> | string
    uploadedByUserId?: StringFilter<"ClubBookArtifact"> | string
    createdAt?: DateTimeFilter<"ClubBookArtifact"> | Date | string
  }

  export type ClubEventUpsertWithWhereUniqueWithoutClubBookInput = {
    where: ClubEventWhereUniqueInput
    update: XOR<ClubEventUpdateWithoutClubBookInput, ClubEventUncheckedUpdateWithoutClubBookInput>
    create: XOR<ClubEventCreateWithoutClubBookInput, ClubEventUncheckedCreateWithoutClubBookInput>
  }

  export type ClubEventUpdateWithWhereUniqueWithoutClubBookInput = {
    where: ClubEventWhereUniqueInput
    data: XOR<ClubEventUpdateWithoutClubBookInput, ClubEventUncheckedUpdateWithoutClubBookInput>
  }

  export type ClubEventUpdateManyWithWhereWithoutClubBookInput = {
    where: ClubEventScalarWhereInput
    data: XOR<ClubEventUpdateManyMutationInput, ClubEventUncheckedUpdateManyWithoutClubBookInput>
  }

  export type ClubEventScalarWhereInput = {
    AND?: ClubEventScalarWhereInput | ClubEventScalarWhereInput[]
    OR?: ClubEventScalarWhereInput[]
    NOT?: ClubEventScalarWhereInput | ClubEventScalarWhereInput[]
    id?: StringFilter<"ClubEvent"> | string
    title?: StringFilter<"ClubEvent"> | string
    description?: StringFilter<"ClubEvent"> | string
    city?: StringFilter<"ClubEvent"> | string
    location?: StringFilter<"ClubEvent"> | string
    addressStreet?: StringNullableFilter<"ClubEvent"> | string | null
    addressNumber?: StringNullableFilter<"ClubEvent"> | string | null
    addressDistrict?: StringNullableFilter<"ClubEvent"> | string | null
    addressCity?: StringNullableFilter<"ClubEvent"> | string | null
    addressState?: StringNullableFilter<"ClubEvent"> | string | null
    addressZip?: StringNullableFilter<"ClubEvent"> | string | null
    latitude?: FloatNullableFilter<"ClubEvent"> | number | null
    longitude?: FloatNullableFilter<"ClubEvent"> | number | null
    startAt?: DateTimeFilter<"ClubEvent"> | Date | string
    endAt?: DateTimeNullableFilter<"ClubEvent"> | Date | string | null
    clubBookId?: StringNullableFilter<"ClubEvent"> | string | null
    createdById?: StringFilter<"ClubEvent"> | string
    createdAt?: DateTimeFilter<"ClubEvent"> | Date | string
  }

  export type ClubBookCreateWithoutMessagesInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    createdByUser: UserCreateNestedOneWithoutCreatedClubBooksInput
    book: BookCreateNestedOneWithoutClubBooksInput
    artifacts?: ClubBookArtifactCreateNestedManyWithoutClubBookInput
    events?: ClubEventCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookUncheckedCreateWithoutMessagesInput = {
    id?: string
    bookId: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    createdByUserId: string
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    artifacts?: ClubBookArtifactUncheckedCreateNestedManyWithoutClubBookInput
    events?: ClubEventUncheckedCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookCreateOrConnectWithoutMessagesInput = {
    where: ClubBookWhereUniqueInput
    create: XOR<ClubBookCreateWithoutMessagesInput, ClubBookUncheckedCreateWithoutMessagesInput>
  }

  export type ClubBookUpsertWithoutMessagesInput = {
    update: XOR<ClubBookUpdateWithoutMessagesInput, ClubBookUncheckedUpdateWithoutMessagesInput>
    create: XOR<ClubBookCreateWithoutMessagesInput, ClubBookUncheckedCreateWithoutMessagesInput>
    where?: ClubBookWhereInput
  }

  export type ClubBookUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ClubBookWhereInput
    data: XOR<ClubBookUpdateWithoutMessagesInput, ClubBookUncheckedUpdateWithoutMessagesInput>
  }

  export type ClubBookUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneRequiredWithoutCreatedClubBooksNestedInput
    book?: BookUpdateOneRequiredWithoutClubBooksNestedInput
    artifacts?: ClubBookArtifactUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artifacts?: ClubBookArtifactUncheckedUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUncheckedUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookCreateWithoutArtifactsInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    createdByUser: UserCreateNestedOneWithoutCreatedClubBooksInput
    book: BookCreateNestedOneWithoutClubBooksInput
    messages?: ClubBookMessageCreateNestedManyWithoutClubBookInput
    events?: ClubEventCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookUncheckedCreateWithoutArtifactsInput = {
    id?: string
    bookId: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    createdByUserId: string
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    messages?: ClubBookMessageUncheckedCreateNestedManyWithoutClubBookInput
    events?: ClubEventUncheckedCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookCreateOrConnectWithoutArtifactsInput = {
    where: ClubBookWhereUniqueInput
    create: XOR<ClubBookCreateWithoutArtifactsInput, ClubBookUncheckedCreateWithoutArtifactsInput>
  }

  export type ClubBookUpsertWithoutArtifactsInput = {
    update: XOR<ClubBookUpdateWithoutArtifactsInput, ClubBookUncheckedUpdateWithoutArtifactsInput>
    create: XOR<ClubBookCreateWithoutArtifactsInput, ClubBookUncheckedCreateWithoutArtifactsInput>
    where?: ClubBookWhereInput
  }

  export type ClubBookUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: ClubBookWhereInput
    data: XOR<ClubBookUpdateWithoutArtifactsInput, ClubBookUncheckedUpdateWithoutArtifactsInput>
  }

  export type ClubBookUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneRequiredWithoutCreatedClubBooksNestedInput
    book?: BookUpdateOneRequiredWithoutClubBooksNestedInput
    messages?: ClubBookMessageUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ClubBookMessageUncheckedUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUncheckedUpdateManyWithoutClubBookNestedInput
  }

  export type ChannelMessageCreateWithoutChannelInput = {
    id: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ChannelMessageUncheckedCreateWithoutChannelInput = {
    id: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ChannelMessageCreateOrConnectWithoutChannelInput = {
    where: ChannelMessageWhereUniqueInput
    create: XOR<ChannelMessageCreateWithoutChannelInput, ChannelMessageUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMessageCreateManyChannelInputEnvelope = {
    data: ChannelMessageCreateManyChannelInput | ChannelMessageCreateManyChannelInput[]
  }

  export type ChannelMessageUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelMessageWhereUniqueInput
    update: XOR<ChannelMessageUpdateWithoutChannelInput, ChannelMessageUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelMessageCreateWithoutChannelInput, ChannelMessageUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMessageUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelMessageWhereUniqueInput
    data: XOR<ChannelMessageUpdateWithoutChannelInput, ChannelMessageUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelMessageUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelMessageScalarWhereInput
    data: XOR<ChannelMessageUpdateManyMutationInput, ChannelMessageUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelMessageScalarWhereInput = {
    AND?: ChannelMessageScalarWhereInput | ChannelMessageScalarWhereInput[]
    OR?: ChannelMessageScalarWhereInput[]
    NOT?: ChannelMessageScalarWhereInput | ChannelMessageScalarWhereInput[]
    id?: StringFilter<"ChannelMessage"> | string
    channelId?: StringFilter<"ChannelMessage"> | string
    userId?: StringFilter<"ChannelMessage"> | string
    text?: StringFilter<"ChannelMessage"> | string
    createdAt?: DateTimeFilter<"ChannelMessage"> | Date | string
  }

  export type ChannelCreateWithoutMessagesInput = {
    id: string
    name: string
    type: string
    cityCode?: string | null
    createdAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutMessagesInput = {
    id: string
    name: string
    type: string
    cityCode?: string | null
    createdAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutMessagesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
  }

  export type ChannelUpsertWithoutMessagesInput = {
    update: XOR<ChannelUpdateWithoutMessagesInput, ChannelUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutMessagesInput, ChannelUncheckedUpdateWithoutMessagesInput>
  }

  export type ChannelUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateWithoutPostInput = {
    id?: string
    userId: string
    type?: string
    createdAt?: Date | string
  }

  export type LikeUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    type?: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPostInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeCreateManyPostInputEnvelope = {
    data: LikeCreateManyPostInput | LikeCreateManyPostInput[]
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
  }

  export type PostImageCreateWithoutPostInput = {
    id?: string
    url: string
    index?: number
  }

  export type PostImageUncheckedCreateWithoutPostInput = {
    id?: string
    url: string
    index?: number
  }

  export type PostImageCreateOrConnectWithoutPostInput = {
    where: PostImageWhereUniqueInput
    create: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput>
  }

  export type PostImageCreateManyPostInputEnvelope = {
    data: PostImageCreateManyPostInput | PostImageCreateManyPostInput[]
  }

  export type LikeUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    type?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type PostImageUpsertWithWhereUniqueWithoutPostInput = {
    where: PostImageWhereUniqueInput
    update: XOR<PostImageUpdateWithoutPostInput, PostImageUncheckedUpdateWithoutPostInput>
    create: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput>
  }

  export type PostImageUpdateWithWhereUniqueWithoutPostInput = {
    where: PostImageWhereUniqueInput
    data: XOR<PostImageUpdateWithoutPostInput, PostImageUncheckedUpdateWithoutPostInput>
  }

  export type PostImageUpdateManyWithWhereWithoutPostInput = {
    where: PostImageScalarWhereInput
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyWithoutPostInput>
  }

  export type PostImageScalarWhereInput = {
    AND?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
    OR?: PostImageScalarWhereInput[]
    NOT?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
    id?: StringFilter<"PostImage"> | string
    postId?: StringFilter<"PostImage"> | string
    url?: StringFilter<"PostImage"> | string
    index?: IntFilter<"PostImage"> | number
  }

  export type PostCreateWithoutImagesInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    likes?: LikeCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutImagesInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutImagesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
  }

  export type PostUpsertWithoutImagesInput = {
    update: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutImagesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
  }

  export type PostUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutLikesInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLikesInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
  }

  export type PostUpsertWithoutLikesInput = {
    update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    likes?: LikeCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    text: string
    imageUrl?: string | null
    clubBookId?: string | null
    createdAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PollOptionCreateWithoutPollInput = {
    id?: string
    type?: string
    text: string
    imageUrl?: string | null
    index: number
    book?: BookCreateNestedOneWithoutPollOptionsInput
    votes?: PollVoteCreateNestedManyWithoutOptionInput
  }

  export type PollOptionUncheckedCreateWithoutPollInput = {
    id?: string
    type?: string
    text: string
    imageUrl?: string | null
    bookId?: string | null
    index: number
    votes?: PollVoteUncheckedCreateNestedManyWithoutOptionInput
  }

  export type PollOptionCreateOrConnectWithoutPollInput = {
    where: PollOptionWhereUniqueInput
    create: XOR<PollOptionCreateWithoutPollInput, PollOptionUncheckedCreateWithoutPollInput>
  }

  export type PollOptionCreateManyPollInputEnvelope = {
    data: PollOptionCreateManyPollInput | PollOptionCreateManyPollInput[]
  }

  export type PollVoteCreateWithoutPollInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    option: PollOptionCreateNestedOneWithoutVotesInput
  }

  export type PollVoteUncheckedCreateWithoutPollInput = {
    id?: string
    optionId: string
    userId: string
    createdAt?: Date | string
  }

  export type PollVoteCreateOrConnectWithoutPollInput = {
    where: PollVoteWhereUniqueInput
    create: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput>
  }

  export type PollVoteCreateManyPollInputEnvelope = {
    data: PollVoteCreateManyPollInput | PollVoteCreateManyPollInput[]
  }

  export type PollOptionUpsertWithWhereUniqueWithoutPollInput = {
    where: PollOptionWhereUniqueInput
    update: XOR<PollOptionUpdateWithoutPollInput, PollOptionUncheckedUpdateWithoutPollInput>
    create: XOR<PollOptionCreateWithoutPollInput, PollOptionUncheckedCreateWithoutPollInput>
  }

  export type PollOptionUpdateWithWhereUniqueWithoutPollInput = {
    where: PollOptionWhereUniqueInput
    data: XOR<PollOptionUpdateWithoutPollInput, PollOptionUncheckedUpdateWithoutPollInput>
  }

  export type PollOptionUpdateManyWithWhereWithoutPollInput = {
    where: PollOptionScalarWhereInput
    data: XOR<PollOptionUpdateManyMutationInput, PollOptionUncheckedUpdateManyWithoutPollInput>
  }

  export type PollVoteUpsertWithWhereUniqueWithoutPollInput = {
    where: PollVoteWhereUniqueInput
    update: XOR<PollVoteUpdateWithoutPollInput, PollVoteUncheckedUpdateWithoutPollInput>
    create: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput>
  }

  export type PollVoteUpdateWithWhereUniqueWithoutPollInput = {
    where: PollVoteWhereUniqueInput
    data: XOR<PollVoteUpdateWithoutPollInput, PollVoteUncheckedUpdateWithoutPollInput>
  }

  export type PollVoteUpdateManyWithWhereWithoutPollInput = {
    where: PollVoteScalarWhereInput
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyWithoutPollInput>
  }

  export type PollVoteScalarWhereInput = {
    AND?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
    OR?: PollVoteScalarWhereInput[]
    NOT?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
    id?: StringFilter<"PollVote"> | string
    pollId?: StringFilter<"PollVote"> | string
    optionId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
  }

  export type PollCreateWithoutOptionsInput = {
    id?: string
    clubBookId?: string | null
    city?: string
    userId: string
    question: string
    description?: string | null
    imageUrl?: string | null
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: Date | string
    votes?: PollVoteCreateNestedManyWithoutPollInput
  }

  export type PollUncheckedCreateWithoutOptionsInput = {
    id?: string
    clubBookId?: string | null
    city?: string
    userId: string
    question: string
    description?: string | null
    imageUrl?: string | null
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: Date | string
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput
  }

  export type PollCreateOrConnectWithoutOptionsInput = {
    where: PollWhereUniqueInput
    create: XOR<PollCreateWithoutOptionsInput, PollUncheckedCreateWithoutOptionsInput>
  }

  export type BookCreateWithoutPollOptionsInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageCreateNestedManyWithoutBookInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBooksInput
    clubBooks?: ClubBookCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutPollOptionsInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    createdByUserId?: string | null
    indicationComment?: string
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutBooksInput
    styleImages?: BookStyleImageUncheckedCreateNestedManyWithoutBookInput
    clubBooks?: ClubBookUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutPollOptionsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutPollOptionsInput, BookUncheckedCreateWithoutPollOptionsInput>
  }

  export type PollVoteCreateWithoutOptionInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    poll: PollCreateNestedOneWithoutVotesInput
  }

  export type PollVoteUncheckedCreateWithoutOptionInput = {
    id?: string
    pollId: string
    userId: string
    createdAt?: Date | string
  }

  export type PollVoteCreateOrConnectWithoutOptionInput = {
    where: PollVoteWhereUniqueInput
    create: XOR<PollVoteCreateWithoutOptionInput, PollVoteUncheckedCreateWithoutOptionInput>
  }

  export type PollVoteCreateManyOptionInputEnvelope = {
    data: PollVoteCreateManyOptionInput | PollVoteCreateManyOptionInput[]
  }

  export type PollUpsertWithoutOptionsInput = {
    update: XOR<PollUpdateWithoutOptionsInput, PollUncheckedUpdateWithoutOptionsInput>
    create: XOR<PollCreateWithoutOptionsInput, PollUncheckedCreateWithoutOptionsInput>
    where?: PollWhereInput
  }

  export type PollUpdateToOneWithWhereWithoutOptionsInput = {
    where?: PollWhereInput
    data: XOR<PollUpdateWithoutOptionsInput, PollUncheckedUpdateWithoutOptionsInput>
  }

  export type PollUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PollVoteUpdateManyWithoutPollNestedInput
  }

  export type PollUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput
  }

  export type BookUpsertWithoutPollOptionsInput = {
    update: XOR<BookUpdateWithoutPollOptionsInput, BookUncheckedUpdateWithoutPollOptionsInput>
    create: XOR<BookCreateWithoutPollOptionsInput, BookUncheckedCreateWithoutPollOptionsInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutPollOptionsInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutPollOptionsInput, BookUncheckedUpdateWithoutPollOptionsInput>
  }

  export type BookUpdateWithoutPollOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUpdateManyWithoutBookNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBooksNestedInput
    clubBooks?: ClubBookUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutPollOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUncheckedUpdateManyWithoutBookNestedInput
    clubBooks?: ClubBookUncheckedUpdateManyWithoutBookNestedInput
  }

  export type PollVoteUpsertWithWhereUniqueWithoutOptionInput = {
    where: PollVoteWhereUniqueInput
    update: XOR<PollVoteUpdateWithoutOptionInput, PollVoteUncheckedUpdateWithoutOptionInput>
    create: XOR<PollVoteCreateWithoutOptionInput, PollVoteUncheckedCreateWithoutOptionInput>
  }

  export type PollVoteUpdateWithWhereUniqueWithoutOptionInput = {
    where: PollVoteWhereUniqueInput
    data: XOR<PollVoteUpdateWithoutOptionInput, PollVoteUncheckedUpdateWithoutOptionInput>
  }

  export type PollVoteUpdateManyWithWhereWithoutOptionInput = {
    where: PollVoteScalarWhereInput
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyWithoutOptionInput>
  }

  export type PollCreateWithoutVotesInput = {
    id?: string
    clubBookId?: string | null
    city?: string
    userId: string
    question: string
    description?: string | null
    imageUrl?: string | null
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: Date | string
    options?: PollOptionCreateNestedManyWithoutPollInput
  }

  export type PollUncheckedCreateWithoutVotesInput = {
    id?: string
    clubBookId?: string | null
    city?: string
    userId: string
    question: string
    description?: string | null
    imageUrl?: string | null
    multiChoice?: boolean
    publicVotes?: boolean
    createdAt?: Date | string
    options?: PollOptionUncheckedCreateNestedManyWithoutPollInput
  }

  export type PollCreateOrConnectWithoutVotesInput = {
    where: PollWhereUniqueInput
    create: XOR<PollCreateWithoutVotesInput, PollUncheckedCreateWithoutVotesInput>
  }

  export type PollOptionCreateWithoutVotesInput = {
    id?: string
    type?: string
    text: string
    imageUrl?: string | null
    index: number
    poll: PollCreateNestedOneWithoutOptionsInput
    book?: BookCreateNestedOneWithoutPollOptionsInput
  }

  export type PollOptionUncheckedCreateWithoutVotesInput = {
    id?: string
    pollId: string
    type?: string
    text: string
    imageUrl?: string | null
    bookId?: string | null
    index: number
  }

  export type PollOptionCreateOrConnectWithoutVotesInput = {
    where: PollOptionWhereUniqueInput
    create: XOR<PollOptionCreateWithoutVotesInput, PollOptionUncheckedCreateWithoutVotesInput>
  }

  export type PollUpsertWithoutVotesInput = {
    update: XOR<PollUpdateWithoutVotesInput, PollUncheckedUpdateWithoutVotesInput>
    create: XOR<PollCreateWithoutVotesInput, PollUncheckedCreateWithoutVotesInput>
    where?: PollWhereInput
  }

  export type PollUpdateToOneWithWhereWithoutVotesInput = {
    where?: PollWhereInput
    data: XOR<PollUpdateWithoutVotesInput, PollUncheckedUpdateWithoutVotesInput>
  }

  export type PollUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: PollOptionUpdateManyWithoutPollNestedInput
  }

  export type PollUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    multiChoice?: BoolFieldUpdateOperationsInput | boolean
    publicVotes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: PollOptionUncheckedUpdateManyWithoutPollNestedInput
  }

  export type PollOptionUpsertWithoutVotesInput = {
    update: XOR<PollOptionUpdateWithoutVotesInput, PollOptionUncheckedUpdateWithoutVotesInput>
    create: XOR<PollOptionCreateWithoutVotesInput, PollOptionUncheckedCreateWithoutVotesInput>
    where?: PollOptionWhereInput
  }

  export type PollOptionUpdateToOneWithWhereWithoutVotesInput = {
    where?: PollOptionWhereInput
    data: XOR<PollOptionUpdateWithoutVotesInput, PollOptionUncheckedUpdateWithoutVotesInput>
  }

  export type PollOptionUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
    poll?: PollUpdateOneRequiredWithoutOptionsNestedInput
    book?: BookUpdateOneWithoutPollOptionsNestedInput
  }

  export type PollOptionUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bookId?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type ClubBookCreateWithoutEventsInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    createdByUser: UserCreateNestedOneWithoutCreatedClubBooksInput
    book: BookCreateNestedOneWithoutClubBooksInput
    messages?: ClubBookMessageCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookUncheckedCreateWithoutEventsInput = {
    id?: string
    bookId: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    createdByUserId: string
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
    messages?: ClubBookMessageUncheckedCreateNestedManyWithoutClubBookInput
    artifacts?: ClubBookArtifactUncheckedCreateNestedManyWithoutClubBookInput
  }

  export type ClubBookCreateOrConnectWithoutEventsInput = {
    where: ClubBookWhereUniqueInput
    create: XOR<ClubBookCreateWithoutEventsInput, ClubBookUncheckedCreateWithoutEventsInput>
  }

  export type ClubEventParticipantCreateWithoutEventInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type ClubEventParticipantUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type ClubEventParticipantCreateOrConnectWithoutEventInput = {
    where: ClubEventParticipantWhereUniqueInput
    create: XOR<ClubEventParticipantCreateWithoutEventInput, ClubEventParticipantUncheckedCreateWithoutEventInput>
  }

  export type ClubEventParticipantCreateManyEventInputEnvelope = {
    data: ClubEventParticipantCreateManyEventInput | ClubEventParticipantCreateManyEventInput[]
  }

  export type ClubEventPhotoCreateWithoutEventInput = {
    id?: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutClubEventPhotosInput
  }

  export type ClubEventPhotoUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type ClubEventPhotoCreateOrConnectWithoutEventInput = {
    where: ClubEventPhotoWhereUniqueInput
    create: XOR<ClubEventPhotoCreateWithoutEventInput, ClubEventPhotoUncheckedCreateWithoutEventInput>
  }

  export type ClubEventPhotoCreateManyEventInputEnvelope = {
    data: ClubEventPhotoCreateManyEventInput | ClubEventPhotoCreateManyEventInput[]
  }

  export type ClubBookUpsertWithoutEventsInput = {
    update: XOR<ClubBookUpdateWithoutEventsInput, ClubBookUncheckedUpdateWithoutEventsInput>
    create: XOR<ClubBookCreateWithoutEventsInput, ClubBookUncheckedCreateWithoutEventsInput>
    where?: ClubBookWhereInput
  }

  export type ClubBookUpdateToOneWithWhereWithoutEventsInput = {
    where?: ClubBookWhereInput
    data: XOR<ClubBookUpdateWithoutEventsInput, ClubBookUncheckedUpdateWithoutEventsInput>
  }

  export type ClubBookUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneRequiredWithoutCreatedClubBooksNestedInput
    book?: BookUpdateOneRequiredWithoutClubBooksNestedInput
    messages?: ClubBookMessageUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ClubBookMessageUncheckedUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUncheckedUpdateManyWithoutClubBookNestedInput
  }

  export type ClubEventParticipantUpsertWithWhereUniqueWithoutEventInput = {
    where: ClubEventParticipantWhereUniqueInput
    update: XOR<ClubEventParticipantUpdateWithoutEventInput, ClubEventParticipantUncheckedUpdateWithoutEventInput>
    create: XOR<ClubEventParticipantCreateWithoutEventInput, ClubEventParticipantUncheckedCreateWithoutEventInput>
  }

  export type ClubEventParticipantUpdateWithWhereUniqueWithoutEventInput = {
    where: ClubEventParticipantWhereUniqueInput
    data: XOR<ClubEventParticipantUpdateWithoutEventInput, ClubEventParticipantUncheckedUpdateWithoutEventInput>
  }

  export type ClubEventParticipantUpdateManyWithWhereWithoutEventInput = {
    where: ClubEventParticipantScalarWhereInput
    data: XOR<ClubEventParticipantUpdateManyMutationInput, ClubEventParticipantUncheckedUpdateManyWithoutEventInput>
  }

  export type ClubEventParticipantScalarWhereInput = {
    AND?: ClubEventParticipantScalarWhereInput | ClubEventParticipantScalarWhereInput[]
    OR?: ClubEventParticipantScalarWhereInput[]
    NOT?: ClubEventParticipantScalarWhereInput | ClubEventParticipantScalarWhereInput[]
    id?: StringFilter<"ClubEventParticipant"> | string
    eventId?: StringFilter<"ClubEventParticipant"> | string
    userId?: StringFilter<"ClubEventParticipant"> | string
    status?: StringFilter<"ClubEventParticipant"> | string
    createdAt?: DateTimeFilter<"ClubEventParticipant"> | Date | string
  }

  export type ClubEventPhotoUpsertWithWhereUniqueWithoutEventInput = {
    where: ClubEventPhotoWhereUniqueInput
    update: XOR<ClubEventPhotoUpdateWithoutEventInput, ClubEventPhotoUncheckedUpdateWithoutEventInput>
    create: XOR<ClubEventPhotoCreateWithoutEventInput, ClubEventPhotoUncheckedCreateWithoutEventInput>
  }

  export type ClubEventPhotoUpdateWithWhereUniqueWithoutEventInput = {
    where: ClubEventPhotoWhereUniqueInput
    data: XOR<ClubEventPhotoUpdateWithoutEventInput, ClubEventPhotoUncheckedUpdateWithoutEventInput>
  }

  export type ClubEventPhotoUpdateManyWithWhereWithoutEventInput = {
    where: ClubEventPhotoScalarWhereInput
    data: XOR<ClubEventPhotoUpdateManyMutationInput, ClubEventPhotoUncheckedUpdateManyWithoutEventInput>
  }

  export type ClubEventCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    clubBook?: ClubBookCreateNestedOneWithoutEventsInput
    photos?: ClubEventPhotoCreateNestedManyWithoutEventInput
  }

  export type ClubEventUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    clubBookId?: string | null
    createdById: string
    createdAt?: Date | string
    photos?: ClubEventPhotoUncheckedCreateNestedManyWithoutEventInput
  }

  export type ClubEventCreateOrConnectWithoutParticipantsInput = {
    where: ClubEventWhereUniqueInput
    create: XOR<ClubEventCreateWithoutParticipantsInput, ClubEventUncheckedCreateWithoutParticipantsInput>
  }

  export type ClubEventUpsertWithoutParticipantsInput = {
    update: XOR<ClubEventUpdateWithoutParticipantsInput, ClubEventUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ClubEventCreateWithoutParticipantsInput, ClubEventUncheckedCreateWithoutParticipantsInput>
    where?: ClubEventWhereInput
  }

  export type ClubEventUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ClubEventWhereInput
    data: XOR<ClubEventUpdateWithoutParticipantsInput, ClubEventUncheckedUpdateWithoutParticipantsInput>
  }

  export type ClubEventUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubBook?: ClubBookUpdateOneWithoutEventsNestedInput
    photos?: ClubEventPhotoUpdateManyWithoutEventNestedInput
  }

  export type ClubEventUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ClubEventPhotoUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ClubEventCreateWithoutPhotosInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    clubBook?: ClubBookCreateNestedOneWithoutEventsInput
    participants?: ClubEventParticipantCreateNestedManyWithoutEventInput
  }

  export type ClubEventUncheckedCreateWithoutPhotosInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    clubBookId?: string | null
    createdById: string
    createdAt?: Date | string
    participants?: ClubEventParticipantUncheckedCreateNestedManyWithoutEventInput
  }

  export type ClubEventCreateOrConnectWithoutPhotosInput = {
    where: ClubEventWhereUniqueInput
    create: XOR<ClubEventCreateWithoutPhotosInput, ClubEventUncheckedCreateWithoutPhotosInput>
  }

  export type UserCreateWithoutClubEventPhotosInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityCreateNestedManyWithoutUserInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByUserInput
    createdClubBooks?: ClubBookCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutClubEventPhotosInput = {
    id: string
    name: string
    bio: string
    avatarUrl: string
    coverUrl?: string
    isAdmin?: boolean
    passwordHash?: string
    passwordResetCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: UserCityUncheckedCreateNestedManyWithoutUserInput
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdClubBooks?: ClubBookUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutClubEventPhotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClubEventPhotosInput, UserUncheckedCreateWithoutClubEventPhotosInput>
  }

  export type ClubEventUpsertWithoutPhotosInput = {
    update: XOR<ClubEventUpdateWithoutPhotosInput, ClubEventUncheckedUpdateWithoutPhotosInput>
    create: XOR<ClubEventCreateWithoutPhotosInput, ClubEventUncheckedCreateWithoutPhotosInput>
    where?: ClubEventWhereInput
  }

  export type ClubEventUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ClubEventWhereInput
    data: XOR<ClubEventUpdateWithoutPhotosInput, ClubEventUncheckedUpdateWithoutPhotosInput>
  }

  export type ClubEventUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubBook?: ClubBookUpdateOneWithoutEventsNestedInput
    participants?: ClubEventParticipantUpdateManyWithoutEventNestedInput
  }

  export type ClubEventUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clubBookId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ClubEventParticipantUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutClubEventPhotosInput = {
    update: XOR<UserUpdateWithoutClubEventPhotosInput, UserUncheckedUpdateWithoutClubEventPhotosInput>
    create: XOR<UserCreateWithoutClubEventPhotosInput, UserUncheckedCreateWithoutClubEventPhotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClubEventPhotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClubEventPhotosInput, UserUncheckedUpdateWithoutClubEventPhotosInput>
  }

  export type UserUpdateWithoutClubEventPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUpdateManyWithoutUserNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByUserNestedInput
    createdClubBooks?: ClubBookUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClubEventPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: UserCityUncheckedUpdateManyWithoutUserNestedInput
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdClubBooks?: ClubBookUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserCityCreateManyUserInput = {
    id?: string
    city: string
  }

  export type BookCreateManyCreatedByUserInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    synopsis?: string
    aiStyleDescription?: string
    indicationComment?: string
    createdAt?: Date | string
  }

  export type ClubBookCreateManyCreatedByUserInput = {
    id?: string
    bookId: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
  }

  export type ClubEventPhotoCreateManyUserInput = {
    id?: string
    eventId: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type UserCityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type UserCityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type UserCityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type BookUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUpdateManyWithoutBookNestedInput
    clubBooks?: ClubBookUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutBooksNestedInput
    styleImages?: BookStyleImageUncheckedUpdateManyWithoutBookNestedInput
    clubBooks?: ClubBookUncheckedUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book?: BookUpdateOneRequiredWithoutClubBooksNestedInput
    messages?: ClubBookMessageUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ClubBookMessageUncheckedUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUncheckedUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUncheckedUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubEventPhotoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: ClubEventUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type ClubEventPhotoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventPhotoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookStyleImageCreateManyBookInput = {
    id?: string
    url: string
  }

  export type ClubBookCreateManyBookInput = {
    id?: string
    title: string
    author: string
    coverUrl?: string
    colorKey: string
    city?: string
    month: number
    year: number
    isActive?: boolean
    createdByUserId: string
    indicationComment?: string
    createdAt?: Date | string
    activatedAt?: Date | string | null
  }

  export type PollOptionCreateManyBookInput = {
    id?: string
    pollId: string
    type?: string
    text: string
    imageUrl?: string | null
    index: number
  }

  export type CategoryUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BookStyleImageUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BookStyleImageUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BookStyleImageUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ClubBookUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneRequiredWithoutCreatedClubBooksNestedInput
    messages?: ClubBookMessageUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ClubBookMessageUncheckedUpdateManyWithoutClubBookNestedInput
    artifacts?: ClubBookArtifactUncheckedUpdateManyWithoutClubBookNestedInput
    events?: ClubEventUncheckedUpdateManyWithoutClubBookNestedInput
  }

  export type ClubBookUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    colorKey?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PollOptionUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
    poll?: PollUpdateOneRequiredWithoutOptionsNestedInput
    votes?: PollVoteUpdateManyWithoutOptionNestedInput
  }

  export type PollOptionUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
    votes?: PollVoteUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type PollOptionUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type BookUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    styleImages?: BookStyleImageUpdateManyWithoutBookNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBooksNestedInput
    clubBooks?: ClubBookUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    styleImages?: BookStyleImageUncheckedUpdateManyWithoutBookNestedInput
    clubBooks?: ClubBookUncheckedUpdateManyWithoutBookNestedInput
    pollOptions?: PollOptionUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    aiStyleDescription?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    indicationComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateManyGroupInput = {
    id?: string
    userId: string
    role: string
  }

  export type GroupInviteCreateManyGroupInput = {
    id?: string
    createdByUserId: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type JoinRequestCreateManyGroupInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type GroupBookOfMonthSelectionCreateManyGroupInput = {
    id?: string
    bookId: string
    setByUserId: string
    setAt?: Date | string
  }

  export type MembershipUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type MembershipUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type MembershipUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GroupInviteUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupInviteUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupInviteUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JoinRequestUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JoinRequestUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JoinRequestUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupBookOfMonthSelectionUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    setByUserId?: StringFieldUpdateOperationsInput | string
    setAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupBookOfMonthSelectionUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    setByUserId?: StringFieldUpdateOperationsInput | string
    setAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupBookOfMonthSelectionUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    setByUserId?: StringFieldUpdateOperationsInput | string
    setAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookMessageCreateManyClubBookInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ClubBookArtifactCreateManyClubBookInput = {
    id?: string
    fileName: string
    mimeType: string
    size: number
    url: string
    uploadedByUserId: string
    createdAt?: Date | string
  }

  export type ClubEventCreateManyClubBookInput = {
    id?: string
    title: string
    description: string
    city?: string
    location: string
    addressStreet?: string | null
    addressNumber?: string | null
    addressDistrict?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    latitude?: number | null
    longitude?: number | null
    startAt: Date | string
    endAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
  }

  export type ClubBookMessageUpdateWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookMessageUncheckedUpdateWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookMessageUncheckedUpdateManyWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookArtifactUpdateWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookArtifactUncheckedUpdateWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubBookArtifactUncheckedUpdateManyWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventUpdateWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ClubEventParticipantUpdateManyWithoutEventNestedInput
    photos?: ClubEventPhotoUpdateManyWithoutEventNestedInput
  }

  export type ClubEventUncheckedUpdateWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ClubEventParticipantUncheckedUpdateManyWithoutEventNestedInput
    photos?: ClubEventPhotoUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ClubEventUncheckedUpdateManyWithoutClubBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    addressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelMessageCreateManyChannelInput = {
    id: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type ChannelMessageUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelMessageUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelMessageUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyPostInput = {
    id?: string
    userId: string
    type?: string
    createdAt?: Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type PostImageCreateManyPostInput = {
    id?: string
    url: string
    index?: number
  }

  export type LikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PostImageUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PostImageUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PollOptionCreateManyPollInput = {
    id?: string
    type?: string
    text: string
    imageUrl?: string | null
    bookId?: string | null
    index: number
  }

  export type PollVoteCreateManyPollInput = {
    id?: string
    optionId: string
    userId: string
    createdAt?: Date | string
  }

  export type PollOptionUpdateWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
    book?: BookUpdateOneWithoutPollOptionsNestedInput
    votes?: PollVoteUpdateManyWithoutOptionNestedInput
  }

  export type PollOptionUncheckedUpdateWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bookId?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
    votes?: PollVoteUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type PollOptionUncheckedUpdateManyWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bookId?: NullableStringFieldUpdateOperationsInput | string | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type PollVoteUpdateWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: PollOptionUpdateOneRequiredWithoutVotesNestedInput
  }

  export type PollVoteUncheckedUpdateWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteCreateManyOptionInput = {
    id?: string
    pollId: string
    userId: string
    createdAt?: Date | string
  }

  export type PollVoteUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poll?: PollUpdateOneRequiredWithoutVotesNestedInput
  }

  export type PollVoteUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventParticipantCreateManyEventInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type ClubEventPhotoCreateManyEventInput = {
    id?: string
    userId: string
    url: string
    caption?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type ClubEventParticipantUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventParticipantUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventParticipantUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventPhotoUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClubEventPhotosNestedInput
  }

  export type ClubEventPhotoUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubEventPhotoUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}